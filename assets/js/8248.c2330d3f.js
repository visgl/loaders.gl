/*! For license information please see 8248.c2330d3f.js.LICENSE.txt */
(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8248],{31029:(e,t,n)=>{"use strict";n.d(t,{ij:()=>g});var i=n(48764).Buffer;new Uint8Array([0]);const o=[171,75,84,88,32,50,48,187,13,10,26,10];var s,r,a,l,c,u,h,d;!function(e){e[e.NONE=0]="NONE",e[e.BASISLZ=1]="BASISLZ",e[e.ZSTD=2]="ZSTD",e[e.ZLIB=3]="ZLIB"}(s||(s={})),function(e){e[e.BASICFORMAT=0]="BASICFORMAT"}(r||(r={})),function(e){e[e.UNSPECIFIED=0]="UNSPECIFIED",e[e.ETC1S=163]="ETC1S",e[e.UASTC=166]="UASTC"}(a||(a={})),function(e){e[e.UNSPECIFIED=0]="UNSPECIFIED",e[e.SRGB=1]="SRGB"}(l||(l={})),function(e){e[e.UNSPECIFIED=0]="UNSPECIFIED",e[e.LINEAR=1]="LINEAR",e[e.SRGB=2]="SRGB",e[e.ITU=3]="ITU",e[e.NTSC=4]="NTSC",e[e.SLOG=5]="SLOG",e[e.SLOG2=6]="SLOG2"}(c||(c={})),function(e){e[e.ALPHA_STRAIGHT=0]="ALPHA_STRAIGHT",e[e.ALPHA_PREMULTIPLIED=1]="ALPHA_PREMULTIPLIED"}(u||(u={})),function(e){e[e.RGB=0]="RGB",e[e.RRR=3]="RRR",e[e.GGG=4]="GGG",e[e.AAA=15]="AAA"}(h||(h={})),function(e){e[e.RGB=0]="RGB",e[e.RGBA=3]="RGBA",e[e.RRR=4]="RRR",e[e.RRRG=5]="RRRG"}(d||(d={}));class p{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=s.NONE,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:r.BASICFORMAT,versionNumber:2,descriptorBlockSize:40,colorModel:a.UNSPECIFIED,colorPrimaries:l.SRGB,transferFunction:l.SRGB,flags:u.ALPHA_STRAIGHT,texelBlockDimension:{x:4,y:4,z:1,w:1},bytesPlane:[],samples:[]}],this.keyValue={},this.globalData=null}}class f{constructor(e,t,n,i){this._dataView=new DataView(e.buffer,e.byteOffset+t,n),this._littleEndian=i,this._offset=0}_nextUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}_nextUint16(){const e=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,e}_nextUint32(){const e=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint64(){const e=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,e}_skip(e){return this._offset+=e,this}_scan(e,t=0){const n=this._offset;let i=0;for(;this._dataView.getUint8(this._offset)!==t&&i<e;)i++,this._offset++;return i<e&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+n,i)}}function m(e){return"undefined"!=typeof TextDecoder?(new TextDecoder).decode(e):i.from(e).toString("utf8")}function g(e){const t=new Uint8Array(e.buffer,e.byteOffset,o.length);if(t[0]!==o[0]||t[1]!==o[1]||t[2]!==o[2]||t[3]!==o[3]||t[4]!==o[4]||t[5]!==o[5]||t[6]!==o[6]||t[7]!==o[7]||t[8]!==o[8]||t[9]!==o[9]||t[10]!==o[10]||t[11]!==o[11])throw new Error("Missing KTX 2.0 identifier.");const n=new p,i=17*Uint32Array.BYTES_PER_ELEMENT,s=new f(e,o.length,i,!0);n.vkFormat=s._nextUint32(),n.typeSize=s._nextUint32(),n.pixelWidth=s._nextUint32(),n.pixelHeight=s._nextUint32(),n.pixelDepth=s._nextUint32(),n.layerCount=s._nextUint32(),n.faceCount=s._nextUint32();const r=s._nextUint32();n.supercompressionScheme=s._nextUint32();const a=s._nextUint32(),l=s._nextUint32(),c=s._nextUint32(),u=s._nextUint32(),h=s._nextUint64(),d=s._nextUint64(),g=new f(e,o.length+i,3*r*8,!0);for(let o=0;o<r;o++)n.levels.push({levelData:new Uint8Array(e.buffer,e.byteOffset+g._nextUint64(),g._nextUint64()),uncompressedByteLength:g._nextUint64()});const _=new f(e,a,l,!0),v={vendorId:_._skip(4)._nextUint16(),descriptorType:_._nextUint16(),versionNumber:_._nextUint16(),descriptorBlockSize:_._nextUint16(),colorModel:_._nextUint8(),colorPrimaries:_._nextUint8(),transferFunction:_._nextUint8(),flags:_._nextUint8(),texelBlockDimension:{x:_._nextUint8()+1,y:_._nextUint8()+1,z:_._nextUint8()+1,w:_._nextUint8()+1},bytesPlane:[_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8()],samples:[]},S=(v.descriptorBlockSize/4-6)/4;for(let o=0;o<S;o++)v.samples[o]={bitOffset:_._nextUint16(),bitLength:_._nextUint8(),channelID:_._nextUint8(),samplePosition:[_._nextUint8(),_._nextUint8(),_._nextUint8(),_._nextUint8()],sampleLower:_._nextUint32(),sampleUpper:_._nextUint32()};n.dataFormatDescriptor.length=0,n.dataFormatDescriptor.push(v);const x=new f(e,c,u,!0);for(;x._offset<u;){const e=x._nextUint32(),t=x._scan(e),i=m(t),o=x._scan(e-t.byteLength);n.keyValue[i]=i.match(/^ktx/i)?m(o):o,e%4&&x._skip(4-e%4)}if(d<=0)return n;const b=new f(e,h,d,!0),y=b._nextUint16(),M=b._nextUint16(),A=b._nextUint32(),C=b._nextUint32(),R=b._nextUint32(),E=b._nextUint32(),L=[];for(let o=0;o<r;o++)L.push({imageFlags:b._nextUint32(),rgbSliceByteOffset:b._nextUint32(),rgbSliceByteLength:b._nextUint32(),alphaSliceByteOffset:b._nextUint32(),alphaSliceByteLength:b._nextUint32()});const P=h+b._offset,I=P+A,T=I+C,N=T+R,w=new Uint8Array(e.buffer,e.byteOffset+P,A),O=new Uint8Array(e.buffer,e.byteOffset+I,C),U=new Uint8Array(e.buffer,e.byteOffset+T,R),B=new Uint8Array(e.buffer,e.byteOffset+N,E);return n.globalData={endpointCount:y,selectorCount:M,imageDescs:L,endpointsData:w,selectorsData:O,tablesData:U,extendedData:B},n}},20514:function(e,t){var n,i,o;i=[],void 0===(o="function"==typeof(n=function(){"use strict";function e(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function t(e){return!0===(e&&e.__isLong__)}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0,enumerable:!1,configurable:!1}),e.isLong=t;var n={},i={};function o(e,t){var o,s,a;return t?(a=0<=(e>>>=0)&&e<256)&&(s=i[e])?s:(o=r(e,(0|e)<0?-1:0,!0),a&&(i[e]=o),o):(a=-128<=(e|=0)&&e<128)&&(s=n[e])?s:(o=r(e,e<0?-1:0,!1),a&&(n[e]=o),o)}function s(e,t){if(isNaN(e)||!isFinite(e))return t?g:m;if(t){if(e<0)return g;if(e>=d)return b}else{if(e<=-p)return y;if(e+1>=p)return x}return e<0?s(-e,t).neg():r(e%h|0,e/h|0,t)}function r(t,n,i){return new e(t,n,i)}e.fromInt=o,e.fromNumber=s,e.fromBits=r;var a=Math.pow;function l(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return m;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var i;if((i=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===i)return l(e.substring(1),t,n).neg();for(var o=s(a(n,8)),r=m,c=0;c<e.length;c+=8){var u=Math.min(8,e.length-c),h=parseInt(e.substring(c,c+u),n);if(u<8){var d=s(a(n,u));r=r.mul(d).add(s(h))}else r=(r=r.mul(o)).add(s(h))}return r.unsigned=t,r}function c(t){return t instanceof e?t:"number"==typeof t?s(t):"string"==typeof t?l(t):r(t.low,t.high,t.unsigned)}e.fromString=l,e.fromValue=c;var u=65536,h=u*u,d=h*h,p=d/2,f=o(1<<24),m=o(0);e.ZERO=m;var g=o(0,!0);e.UZERO=g;var _=o(1);e.ONE=_;var v=o(1,!0);e.UONE=v;var S=o(-1);e.NEG_ONE=S;var x=r(-1,2147483647,!1);e.MAX_VALUE=x;var b=r(-1,-1,!0);e.MAX_UNSIGNED_VALUE=b;var y=r(0,-2147483648,!1);e.MIN_VALUE=y;var M=e.prototype;return M.toInt=function(){return this.unsigned?this.low>>>0:this.low},M.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},M.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(y)){var t=s(e),n=this.div(t),i=n.mul(t).sub(this);return n.toString(e)+i.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var o=s(a(e,6),this.unsigned),r=this,l="";;){var c=r.div(o),u=(r.sub(c.mul(o)).toInt()>>>0).toString(e);if((r=c).isZero())return u+l;for(;u.length<6;)u="0"+u;l=""+u+l}},M.getHighBits=function(){return this.high},M.getHighBitsUnsigned=function(){return this.high>>>0},M.getLowBits=function(){return this.low},M.getLowBitsUnsigned=function(){return this.low>>>0},M.getNumBitsAbs=function(){if(this.isNegative())return this.eq(y)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},M.isZero=function(){return 0===this.high&&0===this.low},M.isNegative=function(){return!this.unsigned&&this.high<0},M.isPositive=function(){return this.unsigned||this.high>=0},M.isOdd=function(){return 1==(1&this.low)},M.isEven=function(){return 0==(1&this.low)},M.equals=function(e){return t(e)||(e=c(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},M.eq=M.equals,M.notEquals=function(e){return!this.eq(e)},M.neq=M.notEquals,M.lessThan=function(e){return this.comp(e)<0},M.lt=M.lessThan,M.lessThanOrEqual=function(e){return this.comp(e)<=0},M.lte=M.lessThanOrEqual,M.greaterThan=function(e){return this.comp(e)>0},M.gt=M.greaterThan,M.greaterThanOrEqual=function(e){return this.comp(e)>=0},M.gte=M.greaterThanOrEqual,M.compare=function(e){if(t(e)||(e=c(e)),this.eq(e))return 0;var n=this.isNegative(),i=e.isNegative();return n&&!i?-1:!n&&i?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},M.comp=M.compare,M.negate=function(){return!this.unsigned&&this.eq(y)?y:this.not().add(_)},M.neg=M.negate,M.add=function(e){t(e)||(e=c(e));var n=this.high>>>16,i=65535&this.high,o=this.low>>>16,s=65535&this.low,a=e.high>>>16,l=65535&e.high,u=e.low>>>16,h=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=o+u)>>>16,h+=(d+=i+l)>>>16,h+=n+a,r((p&=65535)<<16|(f&=65535),(h&=65535)<<16|(d&=65535),this.unsigned)},M.subtract=function(e){return t(e)||(e=c(e)),this.add(e.neg())},M.sub=M.subtract,M.multiply=function(e){if(this.isZero())return m;if(t(e)||(e=c(e)),e.isZero())return m;if(this.eq(y))return e.isOdd()?y:m;if(e.eq(y))return this.isOdd()?y:m;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(f)&&e.lt(f))return s(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,i=65535&this.high,o=this.low>>>16,a=65535&this.low,l=e.high>>>16,u=65535&e.high,h=e.low>>>16,d=65535&e.low,p=0,g=0,_=0,v=0;return _+=(v+=a*d)>>>16,g+=(_+=o*d)>>>16,_&=65535,g+=(_+=a*h)>>>16,p+=(g+=i*d)>>>16,g&=65535,p+=(g+=o*h)>>>16,g&=65535,p+=(g+=a*u)>>>16,p+=n*d+i*h+o*u+a*l,r((_&=65535)<<16|(v&=65535),(p&=65535)<<16|(g&=65535),this.unsigned)},M.mul=M.multiply,M.divide=function(e){if(t(e)||(e=c(e)),e.isZero())throw Error("division by zero");if(this.isZero())return this.unsigned?g:m;var n,i,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return g;if(e.gt(this.shru(1)))return v;o=g}else{if(this.eq(y))return e.eq(_)||e.eq(S)?y:e.eq(y)?_:(n=this.shr(1).div(e).shl(1)).eq(m)?e.isNegative()?_:S:(i=this.sub(e.mul(n)),o=n.add(i.div(e)));if(e.eq(y))return this.unsigned?g:m;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=m}for(i=this;i.gte(e);){n=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var r=Math.ceil(Math.log(n)/Math.LN2),l=r<=48?1:a(2,r-48),u=s(n),h=u.mul(e);h.isNegative()||h.gt(i);)h=(u=s(n-=l,this.unsigned)).mul(e);u.isZero()&&(u=_),o=o.add(u),i=i.sub(h)}return o},M.div=M.divide,M.modulo=function(e){return t(e)||(e=c(e)),this.sub(this.div(e).mul(e))},M.mod=M.modulo,M.not=function(){return r(~this.low,~this.high,this.unsigned)},M.and=function(e){return t(e)||(e=c(e)),r(this.low&e.low,this.high&e.high,this.unsigned)},M.or=function(e){return t(e)||(e=c(e)),r(this.low|e.low,this.high|e.high,this.unsigned)},M.xor=function(e){return t(e)||(e=c(e)),r(this.low^e.low,this.high^e.high,this.unsigned)},M.shiftLeft=function(e){return t(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?r(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):r(0,this.low<<e-32,this.unsigned)},M.shl=M.shiftLeft,M.shiftRight=function(e){return t(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?r(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):r(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},M.shr=M.shiftRight,M.shiftRightUnsigned=function(e){if(t(e)&&(e=e.toInt()),0==(e&=63))return this;var n=this.high;return e<32?r(this.low>>>e|n<<32-e,n>>>e,this.unsigned):r(32===e?n:n>>>e-32,0,this.unsigned)},M.shru=M.shiftRightUnsigned,M.toSigned=function(){return this.unsigned?r(this.low,this.high,!1):this},M.toUnsigned=function(){return this.unsigned?this:r(this.low,this.high,!0)},M.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},M.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24&255,255&e,e>>>8&255,e>>>16&255,e>>>24&255]},M.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24&255,e>>>16&255,e>>>8&255,255&e,t>>>24&255,t>>>16&255,t>>>8&255,255&t]},e})?n.apply(t,i):n)||(e.exports=o)},85403:(e,t,n)=>{"use strict";n.d(t,{Z:()=>he});var i=n(21973),o=n(79185),s=n(74791),r=n(69180),a=n(99296),l=n(82998),c=n(81014),u=n(76166);const h={name:"pbr",vs:"uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\nout vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\nvec4 pos = u_ModelMatrix * position;\npbr_vPosition = vec3(pos.xyz) / pos.w;\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\nvec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\nvec3 bitangentW = cross(normalW, tangentW) * tangent.w;\npbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\npbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n#ifdef HAS_UV\npbr_vUV = uv;\n#else\npbr_vUV = vec2(0.,0.);\n#endif\n}\n",fs:"precision highp float;\nuniform bool pbr_uUnlit;\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\nin vec3 pbr_vPosition;\nin vec2 pbr_vUV;\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\nstruct PBRInfo\n{\nfloat NdotL;\nfloat NdotV;\nfloat NdotH;\nfloat LdotH;\nfloat VdotH;\nfloat perceptualRoughness;\nfloat metalness;\nvec3 reflectance0;\nvec3 reflectance90;\nfloat alphaRoughness;\nvec3 diffuseColor;\nvec3 specularColor;\nvec3 n;\nvec3 v;\n};\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\nvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\nvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\nvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\nreturn vec4(linOut,srgbIn.w);;\n#else\nreturn srgbIn;\n#endif\n}\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\nvec3 pos_dx = dFdx(pbr_vPosition);\nvec3 pos_dy = dFdy(pbr_vPosition);\nvec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\nvec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\nvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n#ifdef HAS_NORMALS\nvec3 ng = normalize(pbr_vNormal);\n#else\nvec3 ng = cross(pos_dx, pos_dy);\n#endif\nt = normalize(t - ng * dot(ng, t));\nvec3 b = normalize(cross(ng, t));\nmat3 tbn = mat3(t, b, ng);\n#else\nmat3 tbn = pbr_vTBN;\n#endif\n#ifdef HAS_NORMALMAP\nvec3 n = texture(u_NormalSampler, pbr_vUV).rgb;\nn = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\nvec3 n = normalize(tbn[2].xyz);\n#endif\nreturn n;\n}\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\nfloat mipCount = 9.0;\nfloat lod = (pbrInputs.perceptualRoughness * mipCount);\nvec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,\nvec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\nvec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n#ifdef USE_TEX_LOD\nvec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\nvec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\nvec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\nvec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\ndiffuse *= u_ScaleIBLAmbient.x;\nspecular *= u_ScaleIBLAmbient.y;\nreturn diffuse + specular;\n}\n#endif\nvec3 diffuse(PBRInfo pbrInputs)\n{\nreturn pbrInputs.diffuseColor / M_PI;\n}\nvec3 specularReflection(PBRInfo pbrInputs)\n{\nreturn pbrInputs.reflectance0 +\n(pbrInputs.reflectance90 - pbrInputs.reflectance0) *\npow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\nfloat NdotL = pbrInputs.NdotL;\nfloat NdotV = pbrInputs.NdotV;\nfloat r = pbrInputs.alphaRoughness;\nfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\nfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\nreturn attenuationL * attenuationV;\n}\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\nfloat roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\nfloat f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\nreturn roughnessSq / (M_PI * f * f);\n}\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\npbrInputs.NdotL = 1.0;\npbrInputs.NdotH = 0.0;\npbrInputs.LdotH = 0.0;\npbrInputs.VdotH = 1.0;\n}\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\nvec3 n = pbrInputs.n;\nvec3 v = pbrInputs.v;\nvec3 l = normalize(lightDirection);\nvec3 h = normalize(l+v);\npbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\npbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\npbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\npbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\nvec3 light_direction = normalize(pointLight.position - pbr_vPosition);\nPBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\nvec3 F = specularReflection(pbrInputs);\nfloat G = geometricOcclusion(pbrInputs);\nfloat D = microfacetDistribution(pbrInputs);\nvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\nvec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\nreturn pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\nvec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\nvec4 baseColor = u_BaseColorFactor;\n#endif\n#ifdef ALPHA_CUTOFF\nif (baseColor.a < u_AlphaCutoff) {\ndiscard;\n}\n#endif\nvec3 color = vec3(0, 0, 0);\nif(pbr_uUnlit){\ncolor.rgb = baseColor.rgb;\n}\nelse{\nfloat perceptualRoughness = u_MetallicRoughnessValues.y;\nfloat metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\nvec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);\nperceptualRoughness = mrSample.g * perceptualRoughness;\nmetallic = mrSample.b * metallic;\n#endif\nperceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\nmetallic = clamp(metallic, 0.0, 1.0);\nfloat alphaRoughness = perceptualRoughness * perceptualRoughness;\nvec3 f0 = vec3(0.04);\nvec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\ndiffuseColor *= 1.0 - metallic;\nvec3 specularColor = mix(f0, baseColor.rgb, metallic);\nfloat reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\nfloat reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\nvec3 specularEnvironmentR0 = specularColor.rgb;\nvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\nvec3 n = getNormal();\nvec3 v = normalize(u_Camera - pbr_vPosition);\nfloat NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\nvec3 reflection = -normalize(reflect(v, n));\nPBRInfo pbrInputs = PBRInfo(\n0.0,\nNdotV,\n0.0,\n0.0,\n0.0,\nperceptualRoughness,\nmetallic,\nspecularEnvironmentR0,\nspecularEnvironmentR90,\nalphaRoughness,\ndiffuseColor,\nspecularColor,\nn,\nv\n);\n#ifdef USE_LIGHTS\nPBRInfo_setAmbientLight(pbrInputs);\ncolor += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\nfor(int i = 0; i < lighting_uDirectionalLightCount; i++) {\nif (i < lighting_uDirectionalLightCount) {\nPBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\ncolor += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n}\n}\nfor(int i = 0; i < lighting_uPointLightCount; i++) {\nif (i < lighting_uPointLightCount) {\nPBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\nfloat attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\ncolor += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n}\n}\n#endif\n#ifdef USE_IBL\ncolor += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\nfloat ao = texture(u_OcclusionSampler, pbr_vUV).r;\ncolor = mix(color, color * ao, u_OcclusionStrength);\n#endif\n#ifdef HAS_EMISSIVEMAP\nvec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\ncolor += emissive;\n#endif\n#ifdef PBR_DEBUG\ncolor = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\ncolor = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\ncolor = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n}\nreturn vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n",defines:{LIGHTING_FRAGMENT:1},dependencies:[n(1937).H]};var d=n(88026),p=n(88393),f=n(93234),m=n(68821);class g{id;matrix=new f.y;display=!0;position=new m.P;rotation=new m.P;scale=new m.P(1,1,1);userData={};props={};constructor(e={}){const{id:t}=e;this.id=t||(0,d.h)(this.constructor.name),this._setScenegraphNodeProps(e)}getBounds(){return null}destroy(){}delete(){this.destroy()}setProps(e){return this._setScenegraphNodeProps(e),this}toString(){return`{type: ScenegraphNode, id: ${this.id})}`}setPosition(e){return(0,p.h)(3===e.length,"setPosition requires vector argument"),this.position=e,this}setRotation(e){return(0,p.h)(3===e.length,"setRotation requires vector argument"),this.rotation=e,this}setScale(e){return(0,p.h)(3===e.length,"setScale requires vector argument"),this.scale=e,this}setMatrix(e,t=!0){t?this.matrix.copy(e):this.matrix=e}setMatrixComponents(e){const{position:t,rotation:n,scale:i,update:o=!0}=e;return t&&this.setPosition(t),n&&this.setRotation(n),i&&this.setScale(i),o&&this.updateMatrix(),this}updateMatrix(){const e=this.position,t=this.rotation,n=this.scale;return this.matrix.identity(),this.matrix.translate(e),this.matrix.rotateXYZ(t),this.matrix.scale(n),this}update(e={}){const{position:t,rotation:n,scale:i}=e;return t&&this.setPosition(t),n&&this.setRotation(n),i&&this.setScale(i),this.updateMatrix(),this}getCoordinateUniforms(e,t){(0,p.h)(e),t=t||this.matrix;const n=new f.y(e).multiplyRight(t),i=n.invert(),o=i.transpose();return{viewMatrix:e,modelMatrix:t,objectMatrix:t,worldMatrix:n,worldInverseMatrix:i,worldInverseTransposeMatrix:o}}_setScenegraphNodeProps(e){"display"in e&&(this.display=e.display),"position"in e&&this.setPosition(e.position),"rotation"in e&&this.setRotation(e.rotation),"scale"in e&&this.setScale(e.scale),"matrix"in e&&this.setMatrix(e.matrix),Object.assign(this.props,e)}}var _=n(87767);class v extends g{children;constructor(e={}){e=Array.isArray(e)?{children:e}:e;const{children:t=[]}=e;_.c.assert(t.every((e=>e instanceof g)),"every child must an instance of ScenegraphNode"),super(e),this.children=t}getBounds(){const e=[[1/0,1/0,1/0],[-1/0,-1/0,-1/0]];return this.traverse(((t,{worldMatrix:n})=>{const i=t.getBounds();if(!i)return;const[o,s]=i,r=new m.P(o).add(s).divide([2,2,2]);n.transformAsPoint(r,r);const a=new m.P(s).subtract(o).divide([2,2,2]);n.transformAsVector(a,a);for(let l=0;l<8;l++){const t=new m.P(1&l?-1:1,2&l?-1:1,4&l?-1:1).multiply(a).add(r);for(let n=0;n<3;n++)e[0][n]=Math.min(e[0][n],t[n]),e[1][n]=Math.max(e[1][n],t[n])}})),Number.isFinite(e[0][0])?e:null}destroy(){this.children.forEach((e=>e.destroy())),this.removeAll(),super.destroy()}add(...e){for(const t of e)Array.isArray(t)?this.add(...t):this.children.push(t);return this}remove(e){const t=this.children,n=t.indexOf(e);return n>-1&&t.splice(n,1),this}removeAll(){return this.children=[],this}traverse(e,{worldMatrix:t=new f.y}={}){const n=new f.y(t).multiplyRight(this.matrix);for(const i of this.children)i instanceof v?i.traverse(e,{worldMatrix:n}):e(i,{worldMatrix:n})}}class S extends g{model;bounds=null;managedResources;constructor(e){super(e),this.model=e.model,this.managedResources=e.managedResources||[],this.bounds=e.bounds||null,this.setProps(e)}getBounds(){return this.bounds}destroy(){this.model&&(this.model.destroy(),this.model=null),this.managedResources.forEach((e=>e.destroy())),this.managedResources=[]}draw(e){return this.model.draw(e)}}var x=n(85105);const b={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},y={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};class M{name;startTime=0;playing=!0;speed=1;channels=[];constructor(e){Object.assign(this,e)}animate(e){if(!this.playing)return;const t=(e/1e3-this.startTime)*this.speed;this.channels.forEach((({sampler:e,target:n,path:i})=>{!function(e,{input:t,interpolation:n,output:i},o,s){const r=t[t.length-1],a=e%r,l=t.findIndex((e=>e>=a)),c=Math.max(0,l-1);if(!Array.isArray(o[s]))switch(s){case"translation":o[s]=[0,0,0];break;case"rotation":o[s]=[0,0,0,1];break;case"scale":o[s]=[1,1,1];break;default:_.c.warn(`Bad animation path ${s}`)()}(0,p.h)(o[s].length===i[c].length);const u=t[c],h=t[l];switch(n){case"STEP":!function(e,t,n){for(let i=0;i<n.length;i++)e[t][i]=n[i]}(o,s,i[c]);break;case"LINEAR":if(h>u){const e=(a-u)/(h-u);!function(e,t,n,i,o){if("rotation"===t){E.slerp({start:n,target:i,ratio:o});for(let n=0;n<E.length;n++)e[t][n]=E[n]}else for(let s=0;s<n.length;s++)e[t][s]=o*i[s]+(1-o)*n[s]}(o,s,i[c],i[l],e)}break;case"CUBICSPLINE":if(h>u){const e=(a-u)/(h-u),t=h-u;!function(e,t,{p0:n,outTangent0:i,inTangent1:o,p1:s,tDiff:r,ratio:a}){for(let l=0;l<e[t].length;l++){const c=i[l]*r,u=o[l]*r;e[t][l]=(2*Math.pow(a,3)-3*Math.pow(a,2)+1)*n[l]+(Math.pow(a,3)-2*Math.pow(a,2)+a)*c+(-2*Math.pow(a,3)+3*Math.pow(a,2))*s[l]+(Math.pow(a,3)-Math.pow(a,2))*u}}(o,s,{p0:i[3*c+1],outTangent0:i[3*c+2],inTangent1:i[3*l+0],p1:i[3*l+1],tDiff:t,ratio:e})}break;default:_.c.warn(`Interpolation ${n} not supported`)()}}(t,e,n,i),function(e,t){t.matrix.identity(),e.translation&&t.matrix.translate(e.translation);if(e.rotation){const n=R.fromQuaternion(e.rotation);t.matrix.multiplyRight(n)}e.scale&&t.matrix.scale(e.scale)}(n,n._node)}))}}class A{animations;constructor(e){this.animations=e.animations.map(((t,n)=>{const i=t.name||`Animation-${n}`,o=t.samplers.map((({input:t,interpolation:n="LINEAR",output:i})=>({input:C(e.accessors[t]),interpolation:n,output:C(e.accessors[i])}))),s=t.channels.map((({sampler:t,target:n})=>({sampler:o[t],target:e.nodes[n.node],path:n.path})));return new M({name:i,channels:s})}))}animate(e){this.setTime(e)}setTime(e){this.animations.forEach((t=>t.animate(e)))}getAnimations(){return this.animations}}function C(e){if(!e._animation){const t=y[e.componentType],n=b[e.type],i=n*e.count,{buffer:o,byteOffset:s}=e.bufferView.data,r=new t(o,s+(e.byteOffset||0),i);if(1===n)e._animation=Array.from(r);else{const t=[];for(let e=0;e<r.length;e+=n)t.push(Array.from(r.slice(e,e+n)));e._animation=t}}return e._animation}const R=new f.y;const E=new x._;var L,P=n(47594);function I(e,t,n,i){const o={defines:{MANUAL_SRGB:1,SRGB_FAST_APPROXIMATION:1},bindings:{},uniforms:{u_Camera:[0,0,0],u_MetallicRoughnessValues:[1,1]},parameters:{},glParameters:{},generatedTextures:[]};o.defines.USE_TEX_LOD=1;const{imageBasedLightingEnvironment:s}=i;return s&&(o.bindings.u_DiffuseEnvSampler=s.diffuseEnvSampler,o.bindings.u_SpecularEnvSampler=s.specularEnvSampler,o.bindings.u_brdfLUT=s.brdfLutTexture,o.uniforms.u_ScaleIBLAmbient=[1,1]),i?.pbrDebug&&(o.defines.PBR_DEBUG=1,o.uniforms.u_ScaleDiffBaseMR=[0,0,0,0],o.uniforms.u_ScaleFGDSpec=[0,0,0,0]),n.NORMAL&&(o.defines.HAS_NORMALS=1),n.TANGENT&&i?.useTangents&&(o.defines.HAS_TANGENTS=1),n.TEXCOORD_0&&(o.defines.HAS_UV=1),i?.imageBasedLightingEnvironment&&(o.defines.USE_IBL=1),i?.lights&&(o.defines.USE_LIGHTS=1),t&&function(e,t,n){n.uniforms.pbr_uUnlit=Boolean(t.unlit),t.pbrMetallicRoughness&&function(e,t,n){t.baseColorTexture&&T(e,t.baseColorTexture,"u_BaseColorSampler","HAS_BASECOLORMAP",n);n.uniforms.u_BaseColorFactor=t.baseColorFactor||[1,1,1,1],t.metallicRoughnessTexture&&T(e,t.metallicRoughnessTexture,"u_MetallicRoughnessSampler","HAS_METALROUGHNESSMAP",n);const{metallicFactor:i=1,roughnessFactor:o=1}=t;n.uniforms.u_MetallicRoughnessValues=[i,o]}(e,t.pbrMetallicRoughness,n);if(t.normalTexture){T(e,t.normalTexture,"u_NormalSampler","HAS_NORMALMAP",n);const{scale:i=1}=t.normalTexture;n.uniforms.u_NormalScale=i}if(t.occlusionTexture){T(e,t.occlusionTexture,"u_OcclusionSampler","HAS_OCCLUSIONMAP",n);const{strength:i=1}=t.occlusionTexture;n.uniforms.u_OcclusionStrength=i}t.emissiveTexture&&(T(e,t.emissiveTexture,"u_EmissiveSampler","HAS_EMISSIVEMAP",n),n.uniforms.u_EmissiveFactor=t.emissiveFactor||[0,0,0]);switch(t.alphaMode){case"MASK":const{alphaCutoff:e=.5}=t;n.defines.ALPHA_CUTOFF=1,n.uniforms.u_AlphaCutoff=e;break;case"BLEND":_.c.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(),n.parameters.blendColorOperation="add",n.parameters.blendColorSrcFactor="src-alpha",n.parameters.blendColorDstFactor="one-minus-src-alpha",n.parameters.blendAlphaOperation="add",n.parameters.blendAlphaSrcFactor="one",n.parameters.blendAlphaDstFactor="one-minus-src-alpha",n.glParameters.blend=!0,n.glParameters.blendEquation=L.FUNC_ADD,n.glParameters.blendFunc=[L.SRC_ALPHA,L.ONE_MINUS_SRC_ALPHA,L.ONE,L.ONE_MINUS_SRC_ALPHA]}}(e,t,o),o}function T(e,t,n,i=null,o){const s=t?.texture?.sampler?.parameters||{},r=t.texture.source.image;let a,l={};r.compressed?(a=r,l={[L.TEXTURE_MIN_FILTER]:r.data.length>1?L.LINEAR_MIPMAP_NEAREST:L.LINEAR}):a={data:r};const c=e.createTexture({id:t.uniformName||t.id,parameters:{...s,...l},pixelStore:{[L.UNPACK_FLIP_Y_WEBGL]:!1},...a});o.bindings[n]=c,i&&(o.defines[i]=1),o.generatedTextures.push(c)}!function(e){e[e.FUNC_ADD=32774]="FUNC_ADD",e[e.ONE=1]="ONE",e[e.SRC_ALPHA=770]="SRC_ALPHA",e[e.ONE_MINUS_SRC_ALPHA=771]="ONE_MINUS_SRC_ALPHA",e[e.TEXTURE_MIN_FILTER=10241]="TEXTURE_MIN_FILTER",e[e.LINEAR=9729]="LINEAR",e[e.LINEAR_MIPMAP_NEAREST=9985]="LINEAR_MIPMAP_NEAREST",e[e.UNPACK_FLIP_Y_WEBGL=37440]="UNPACK_FLIP_Y_WEBGL"}(L||(L={}));function N(e,t){return`#version 300 es\n${t}`}const w={modelOptions:{},pbrDebug:!1,imageBasedLightingEnvironment:null,lights:!0,useTangents:!1};class O{device;options;gltf;constructor(e,t={}){this.device=e,this.options={...w,...t}}instantiate(e){this.gltf=e;return(e.scenes||[]).map((e=>this.createScene(e)))}createAnimator(){return Array.isArray(this.gltf.animations)?new A(this.gltf):null}createScene(e){const t=(e.nodes||[]).map((e=>this.createNode(e)));return new v({id:e.name||e.id,children:t})}createNode(e){if(!e._node){const t=(e.children||[]).map((e=>this.createNode(e)));e.mesh&&t.push(this.createMesh(e.mesh));const n=new v({id:e.name||e.id,children:t});if(e.matrix)n.setMatrix(e.matrix);else{if(n.matrix.identity(),e.translation&&n.matrix.translate(e.translation),e.rotation){const t=(new f.y).fromQuaternion(e.rotation);n.matrix.multiplyRight(t)}e.scale&&n.matrix.scale(e.scale)}e._node=n}return e._node}createMesh(e){if(!e._mesh){const t=(e.primitives||[]).map(((t,n)=>this.createPrimitive(t,n,e))),n=new v({id:e.name||e.id,children:t});e._mesh=n}return e._mesh}createPrimitive(e,t,n){const i=e.name||`${n.name||n.id}-primitive-${t}`,o=function(e){switch(e){case U.POINTS:return"point-list";case U.LINES:return"line-list";case U.LINE_STRIP:return"line-strip";case U.LINE_LOOP:return"line-loop-webgl";case U.TRIANGLES:return"triangle-list";case U.TRIANGLE_STRIP:return"triangle-strip";case U.TRIANGLE_FAN:return"triangle-fan-webgl";default:throw new Error(e)}}(e.mode||4),s=e.indices?e.indices.count:this.getVertexCount(e.attributes),r=function(e,t){const{id:n,geometry:i,material:o,vertexCount:s,materialOptions:r,modelOptions:a}=t,l=I(e,o,i.attributes,r);_.c.info(4,"createGLTFModel defines: ",l.defines)();const c={id:n,geometry:i,topology:i.topology,vertexCount:s,modules:[h],vs:N(0,"\n#pragma vscode_glsllint_stage: vert\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  // _attr vec4 POSITION;\n  _attr vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // _attr vec4 NORMAL;\n    _attr vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // _attr vec2 TEXCOORD_0;\n    _attr vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n"),fs:N(0,"\n#pragma vscode_glsllint_stage: frag\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n"),...a,bindings:{...l.bindings,...a.bindings},defines:{...l.defines,...a.defines},parameters:{depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",cullMode:"back",...l.parameters,...a.parameters},uniforms:{...l.uniforms,...a.uniforms}},u=new P.H(e,c);return new S({managedResources:[],model:u})}(this.device,{id:i,geometry:this.createGeometry(i,e,o),material:e.material,materialOptions:this.options,modelOptions:this.options.modelOptions,vertexCount:s});return r.bounds=[e.attributes.POSITION.min,e.attributes.POSITION.max],r}getVertexCount(e){throw new Error("getVertexCount not implemented")}createGeometry(e,t,n){const o={};for(const[i,s]of Object.entries(t.attributes)){const{components:e,size:t,value:n}=s;o[i]={size:t??e,value:n}}return new i.Z({id:e,topology:n,indices:t.indices.value,attributes:o})}createBuffer(e,t){e.bufferView||(e.bufferView={});const{bufferView:n}=e;return n.lumaBuffers||(n.lumaBuffers={}),n.lumaBuffers[t]||(n.lumaBuffers[t]=this.device.createBuffer({id:`from-${n.id}`,data:n.data||e.value})),n.lumaBuffers[t]}createSampler(e){return e}needsPOT(){return!1}}var U;!function(e){e[e.POINTS=0]="POINTS",e[e.LINES=1]="LINES",e[e.LINE_LOOP=2]="LINE_LOOP",e[e.LINE_STRIP=3]="LINE_STRIP",e[e.TRIANGLES=4]="TRIANGLES",e[e.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",e[e.TRIANGLE_FAN=6]="TRIANGLE_FAN"}(U||(U={}));var B=n(6780),F=n(75784);async function z(e){const t=[];return e.scenes.forEach((e=>{e.traverse((e=>{Object.values(e.model.uniforms).forEach((e=>{!1===e.loaded&&t.push(e)}))}))})),await async function(e){for(;e();)await new Promise((e=>requestAnimationFrame(e)))}((()=>t.some((e=>!e.loaded))))}var D=n(69012);const G=Math.PI/180,H=new Float32Array(16),V=new Float32Array(12);function k(e,t,n){const i=t[0]*G,o=t[1]*G,s=t[2]*G,r=Math.sin(s),a=Math.sin(i),l=Math.sin(o),c=Math.cos(s),u=Math.cos(i),h=Math.cos(o),d=n[0],p=n[1],f=n[2];e[0]=d*h*u,e[1]=d*l*u,e[2]=d*-a,e[3]=p*(-l*c+h*a*r),e[4]=p*(h*c+l*a*r),e[5]=p*u*r,e[6]=f*(l*r+h*a*c),e[7]=f*(-h*r+l*a*c),e[8]=f*u*c}function q(e){return e[0]=e[0],e[1]=e[1],e[2]=e[2],e[3]=e[4],e[4]=e[5],e[5]=e[6],e[6]=e[8],e[7]=e[9],e[8]=e[10],e[9]=e[12],e[10]=e[13],e[11]=e[14],e.subarray(0,12)}const Z={size:12,accessor:["getOrientation","getScale","getTranslation","getTransformMatrix"],shaderAttributes:{instanceModelMatrixCol0:{size:3,elementOffset:0},instanceModelMatrixCol1:{size:3,elementOffset:3},instanceModelMatrixCol2:{size:3,elementOffset:6},instanceTranslation:{size:3,elementOffset:9}},update(e,{startRow:t,endRow:n}){const{data:i,getOrientation:o,getScale:s,getTranslation:r,getTransformMatrix:a}=this.props,l=Array.isArray(a),c=l&&16===a.length,u=Array.isArray(s),h=Array.isArray(o),d=Array.isArray(r),p=c||!l&&Boolean(a(i[0]));e.constant=p?c:h&&u&&d;const f=e.value;if(e.constant){let t;if(p)H.set(a),t=q(H);else{t=V;k(t,o,s),t.set(r,9)}e.value=new Float32Array(t)}else{let l=t*e.size;const{iterable:m,objectInfo:g}=(0,D.jB)(i,t,n);for(const e of m){let t;if(g.index++,p)H.set(c?a:a(e,g)),t=q(H);else{t=V;k(t,h?o:o(e,g),u?s:s(e,g)),t.set(d?r:r(e,g),9)}f[l++]=t[0],f[l++]=t[1],f[l++]=t[2],f[l++]=t[3],f[l++]=t[4],f[l++]=t[5],f[l++]=t[6],f[l++]=t[7],f[l++]=t[8],f[l++]=t[9],f[l++]=t[10],f[l++]=t[11]}}}};function j(e,t){return t===r.COORDINATE_SYSTEM.CARTESIAN||t===r.COORDINATE_SYSTEM.METER_OFFSETS||t===r.COORDINATE_SYSTEM.DEFAULT&&!e.isGeospatial}const X=[255,255,255,255],K={scenegraph:{type:"object",value:null,async:!0},getScene:e=>e&&e.scenes?"object"==typeof e.scene?e.scene:e.scenes[e.scene||0]:e,getAnimator:e=>e&&e.animator,_animations:null,sizeScale:{type:"number",value:1,min:0},sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:X},_lighting:"flat",_imageBasedLightingEnvironment:void 0,getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},loaders:[B.E]};class $ extends l.Z{static{this.defaultProps=K}static{this.layerName="ScenegraphLayer"}getShaders(){const e=[c.Z,u.Z];return"pbr"===this.props._lighting&&e.push(h),super.getShaders({vs:"#version 300 es\n#define SHADER_NAME scenegraph-layer-vertex-shader\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\nin vec3 positions;\n#ifdef HAS_UV\nin vec2 texCoords;\n#endif\n#ifdef MODULE_PBR\n#ifdef HAS_NORMALS\nin vec3 normals;\n#endif\n#endif\nout vec4 vColor;\n#ifndef MODULE_PBR\n#ifdef HAS_UV\nout vec2 vTEXCOORD_0;\n#endif\n#endif\nvoid main(void) {\n#if defined(HAS_UV) && !defined(MODULE_PBR)\nvTEXCOORD_0 = texCoords;\ngeometry.uv = texCoords;\n#endif\ngeometry.worldPosition = instancePositions;\ngeometry.pickingColor = instancePickingColors;\nmat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\nvec3 normal = vec3(0.0, 0.0, 1.0);\n#ifdef MODULE_PBR\n#ifdef HAS_NORMALS\nnormal = instanceModelMatrix * (sceneModelMatrix * vec4(normals, 0.0)).xyz;\n#endif\n#endif\nfloat originalSize = project_size_to_pixel(sizeScale);\nfloat clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\nvec3 pos = (instanceModelMatrix * (sceneModelMatrix * vec4(positions, 1.0)).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\nif(composeModelMatrix) {\nDECKGL_FILTER_SIZE(pos, geometry);\ngeometry.normal = project_normal(normal);\ngeometry.worldPosition += pos;\ngl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n}\nelse {\npos = project_size(pos);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\ngeometry.normal = project_normal(normal);\n}\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n#ifdef MODULE_PBR\npbr_vPosition = geometry.position.xyz;\n#ifdef HAS_NORMALS\npbr_vNormal = geometry.normal;\n#endif\n#ifdef HAS_UV\npbr_vUV = texCoords;\n#else\npbr_vUV = vec2(0., 0.);\n#endif\ngeometry.uv = pbr_vUV;\n#endif\nvColor = instanceColors;\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME scenegraph-layer-fragment-shader\nuniform float opacity;\nin vec4 vColor;\nout vec4 fragColor;\n#ifndef MODULE_PBR\n#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\nin vec2 vTEXCOORD_0;\nuniform sampler2D u_BaseColorSampler;\n#endif\n#endif\nvoid main(void) {\n#ifdef MODULE_PBR\nfragColor = vColor * pbr_filterColor(vec4(0));\ngeometry.uv = pbr_vUV;\n#else\n#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\nfragColor = vColor * texture(u_BaseColorSampler, vTEXCOORD_0);\ngeometry.uv = vTEXCOORD_0;\n#else\nfragColor = vColor;\n#endif\n#endif\nfragColor.a *= opacity;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:e})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),accessor:"getPosition",transition:!0},instanceColors:{type:"unorm8",size:this.props.colorFormat.length,accessor:"getColor",defaultValue:X,transition:!0},instanceModelMatrix:Z})}updateState(e){super.updateState(e);const{props:t,oldProps:n}=e;t.scenegraph!==n.scenegraph?this._updateScenegraph():t._animations!==n._animations&&this._applyAnimationsProp(this.state.animator,t._animations)}finalizeState(e){super.finalizeState(e),this.state.scenegraph?.destroy()}get isLoaded(){return Boolean(this.state?.scenegraph&&super.isLoaded)}_updateScenegraph(){const e=this.props,{device:t}=this.context;let n=null;if(e.scenegraph instanceof g)n={scenes:[e.scenegraph]};else if(e.scenegraph&&"object"==typeof e.scenegraph){const i=e.scenegraph,o=i.json?(0,F.w)(i):i,s=function(e,t,n){const i=new O(e,n);return{scenes:i.instantiate(t),animator:i.createAnimator()}}(t,o,this._getModelOptions());n={gltf:o,...s},z(s).then((()=>{this.setNeedsRedraw()})).catch((e=>{this.raiseError(e,"loading glTF")}))}const i={layer:this,device:this.context.device},o=e.getScene(n,i),r=e.getAnimator(n,i);if(o instanceof v){this.state.scenegraph?.destroy(),this._applyAnimationsProp(r,e._animations);const t=[];o.traverse((e=>{e instanceof S&&t.push(e.model)})),this.setState({scenegraph:o,animator:r,models:t}),this.getAttributeManager().invalidateAll()}else null!==o&&s.Z.warn("invalid scenegraph:",o)()}_applyAnimationsProp(e,t){if(!e||!t)return;const n=e.getAnimations();Object.keys(t).sort().forEach((e=>{const i=t[e];if("*"===e)n.forEach((e=>{Object.assign(e,i)}));else if(Number.isFinite(Number(e))){const t=Number(e);t>=0&&t<n.length?Object.assign(n[t],i):s.Z.warn(`animation ${e} not found`)()}else{const t=n.find((({name:t})=>t===e));t?Object.assign(t,i):s.Z.warn(`animation ${e} not found`)()}}))}_getModelOptions(){const{_imageBasedLightingEnvironment:e}=this.props;let t;return e&&(t="function"==typeof e?e({gl:this.context.gl,layer:this}):e),{imageBasedLightingEnvironment:t,modelOptions:{id:this.props.id,isInstanced:!0,bufferLayout:this.getAttributeManager().getBufferLayouts(),...this.getShaders()},useTangents:!1}}draw({context:e}){if(!this.state.scenegraph)return;this.props._animations&&this.state.animator&&(this.state.animator.animate(e.timeline.getTime()),this.setNeedsRedraw());const{viewport:t,renderPass:n}=this.context,{sizeScale:i,sizeMinPixels:o,sizeMaxPixels:s,opacity:r,coordinateSystem:a}=this.props,l=this.getNumInstances();this.state.scenegraph.traverse(((e,{worldMatrix:c})=>{if(e instanceof S){const{model:u}=e;u.setInstanceCount(l),u.setUniforms({sizeScale:i,opacity:r,sizeMinPixels:o,sizeMaxPixels:s,composeModelMatrix:j(t,a),sceneModelMatrix:c,u_Camera:u.uniforms.project_uCameraPosition}),u.draw(n)}}))}}var W=n(62602),Y=n(66223);var Q=n(98218);function J(e){const t=e.positions||e.POSITION;s.Z.assert(t,'no "postions" or "POSITION" attribute in mesh');const n=t.value.length/t.size;let i=e.COLOR_0||e.colors;i||(i={size:3,value:new Float32Array(3*n).fill(1)});let o=e.NORMAL||e.normals;o||(o={size:3,value:new Float32Array(3*n).fill(0)});let r=e.TEXCOORD_0||e.texCoords;return r||(r={size:2,value:new Float32Array(2*n).fill(0)}),{positions:t,colors:i,normals:o,texCoords:r}}function ee(e){return e instanceof i.Z?(e.attributes=J(e.attributes),e):e.attributes?new i.Z({...e,topology:"triangle-list",attributes:J(e.attributes)}):new i.Z({topology:"triangle-list",attributes:J(e)})}const te={mesh:{type:"object",value:null,async:!0},texture:{type:"image",value:null,async:!0},sizeScale:{type:"number",value:1,min:0},_instanced:!0,wireframe:!1,material:!0,getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:[0,0,0,255]},getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},textureParameters:{type:"object",ignore:!0,value:null}};class ne extends l.Z{static{this.defaultProps=te}static{this.layerName="SimpleMeshLayer"}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.uv = texCoords;\ngeometry.pickingColor = instancePickingColors;\nvTexCoord = texCoords;\ncameraPosition = project_uCameraPosition;\nvColor = vec4(colors * instanceColors.rgb, instanceColors.a);\nmat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\nvec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\nif (composeModelMatrix) {\nDECKGL_FILTER_SIZE(pos, geometry);\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\ngeometry.worldPosition += pos;\ngl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\ngeometry.position = position_commonspace;\n}\nelse {\npos = project_size(pos);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\ngeometry.position = position_commonspace;\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\n}\ngeometry.normal = normals_commonspace;\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\nprecision highp float;\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = vTexCoord;\nvec3 normal;\nif (flatShading) {\nnormal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n} else {\nnormal = normals_commonspace;\n}\nvec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\nDECKGL_FILTER_COLOR(color, geometry);\nvec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\nfragColor = vec4(lightColor, color.a * opacity);\n}\n",modules:[c.Z,W.s,u.Z]})}getBounds(){if(this.props._instanced)return super.getBounds();let e=this.state.positionBounds;if(e)return e;const{mesh:t}=this.props;if(!t)return null;if(e=t.header?.boundingBox,!e){const{attributes:n}=ee(t);n.POSITION=n.POSITION||n.positions,e=(0,Q.v)(n)}return this.state.positionBounds=e,e}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{transition:!0,type:"float64",fp64:this.use64bitPositions(),size:3,accessor:"getPosition"},instanceColors:{type:"unorm8",transition:!0,size:this.props.colorFormat.length,accessor:"getColor",defaultValue:[0,0,0,255]},instanceModelMatrix:Z}),this.setState({emptyTexture:this.context.device.createTexture({data:new Uint8Array(4),width:1,height:1})})}updateState(e){super.updateState(e);const{props:t,oldProps:n,changeFlags:i}=e;if(t.mesh!==n.mesh||i.extensionsChanged){if(this.state.positionBounds=null,this.state.model?.destroy(),t.mesh){this.state.model=this.getModel(t.mesh);const e=t.mesh.attributes||t.mesh;this.setState({hasNormals:Boolean(e.NORMAL||e.normals)})}this.getAttributeManager().invalidateAll()}t.texture!==n.texture&&t.texture instanceof Y.x&&this.setTexture(t.texture),this.state.model&&this.state.model.setTopology(this.props.wireframe?"line-strip":"triangle-list")}finalizeState(e){super.finalizeState(e),this.state.emptyTexture.delete()}draw({uniforms:e}){const{model:t}=this.state;if(!t)return;const{viewport:n,renderPass:i}=this.context,{sizeScale:o,coordinateSystem:s,_instanced:r}=this.props;t.setUniforms(e),t.setUniforms({sizeScale:o,composeModelMatrix:!r||j(n,s),flatShading:!this.state.hasNormals}),t.draw(i)}get isLoaded(){return Boolean(this.state?.model&&super.isLoaded)}getModel(e){const t=new P.H(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:ee(e),isInstanced:!0}),{texture:n}=this.props,{emptyTexture:i}=this.state;return t.setBindings({sampler:n||i}),t.setUniforms({hasTexture:Boolean(n)}),t}setTexture(e){const{emptyTexture:t,model:n}=this.state;n&&(n.setBindings({sampler:e||t}),n.setUniforms({hasTexture:Boolean(e)}))}}const ie={pbrMaterial:{type:"object",value:null},featureIds:{type:"array",value:null,optional:!0}};class oe extends ne{static{this.layerName="MeshLayer"}static{this.defaultProps=ie}getShaders(){const e=super.getShaders();return e.modules.push(h),{...e,vs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nuniform bool pickFeatureIds;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec4 uvRegions;\nin vec3 featureIdsPickingColors;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\nvec2 applyUVRegion(vec2 uv) {\n#ifdef HAS_UV_REGIONS\nreturn fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;\n#else\nreturn uv;\n#endif\n}\nvoid main(void) {\nvec2 uv = applyUVRegion(texCoords);\ngeometry.uv = uv;\nif (pickFeatureIds) {\ngeometry.pickingColor = featureIdsPickingColors;\n} else {\ngeometry.pickingColor = instancePickingColors;\n}\nmat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\nvTexCoord = uv;\ncameraPosition = project_uCameraPosition;\nvColor = vec4(colors * instanceColors.rgb, instanceColors.a);\nvec3 pos = (instanceModelMatrix * positions) * sizeScale;\nvec3 projectedPosition = project_position(positions);\nposition_commonspace = vec4(projectedPosition, 1.0);\ngl_Position = project_common_position_to_clipspace(position_commonspace);\ngeometry.position = position_commonspace;\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\ngeometry.normal = normals_commonspace;\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n#ifdef MODULE_PBR\npbr_vPosition = geometry.position.xyz;\n#ifdef HAS_NORMALS\npbr_vNormal = geometry.normal;\n#endif\n#ifdef HAS_UV\npbr_vUV = uv;\n#else\npbr_vUV = vec2(0., 0.);\n#endif\ngeometry.uv = pbr_vUV;\n#endif\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\nprecision highp float;\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\n#ifdef MODULE_PBR\nfragColor = vColor * pbr_filterColor(vec4(0));\ngeometry.uv = pbr_vUV;\nfragColor.a *= opacity;\n#else\ngeometry.uv = vTexCoord;\nvec3 normal;\nif (flatShading) {\nnormal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n} else {\nnormal = normals_commonspace;\n}\nvec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\nvec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\nfragColor = vec4(lightColor, color.a * opacity);\n#endif\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n"}}initializeState(){const{featureIds:e}=this.props;super.initializeState();const t=this.getAttributeManager();e&&t.add({featureIdsPickingColors:{type:"uint8",size:3,noAlloc:!0,update:this.calculateFeatureIdsPickingColors}})}updateState(e){super.updateState(e);const{props:t,oldProps:n}=e;t.pbrMaterial!==n.pbrMaterial&&this.updatePbrMaterialUniforms(t.pbrMaterial)}draw(e){const{featureIds:t}=this.props;this.state.model&&(this.state.model.setUniforms({u_Camera:this.state.model.uniforms.project_uCameraPosition,pickFeatureIds:Boolean(t)}),super.draw(e))}getModel(e){const{id:t,pbrMaterial:n}=this.props,i=this.parseMaterial(n,e);this.setState({parsedPBRMaterial:i});const o=this.getShaders();!function(e){const t=e.positions||e.POSITION,n=t.value.length/t.size;e.COLOR_0||e.colors||(e.colors={size:4,value:new Uint8Array(4*n).fill(255),normalized:!0})}(e.attributes);return new P.H(this.context.device,{...this.getShaders(),id:t,geometry:e,bufferLayout:this.getAttributeManager().getBufferLayouts(),defines:{...o.defines,...i?.defines,HAS_UV_REGIONS:e.attributes.uvRegions?1:0},parameters:i?.parameters,isInstanced:!0})}updatePbrMaterialUniforms(e){const{model:t}=this.state;if(t){const{mesh:n}=this.props,i=this.parseMaterial(e,n);this.setState({parsedPBRMaterial:i}),t.setBindings(i.bindings),t.setUniforms(i.uniforms)}}parseMaterial(e,t){const n=Boolean(e.pbrMetallicRoughness&&e.pbrMetallicRoughness.baseColorTexture);return I(this.context.device,{unlit:n,...e},{NORMAL:t.attributes.normals,TEXCOORD_0:t.attributes.texCoords},{pbrDebug:!1,lights:!0,useTangents:!1})}calculateFeatureIdsPickingColors(e){const t=this.props.featureIds,n=new Uint8ClampedArray(t.length*e.size),i=[];for(let o=0;o<t.length;o++)this.encodePickingColor(t[o],i),n[3*o]=i[0],n[3*o+1]=i[1],n[3*o+2]=i[2];e.value=n}finalizeState(e){super.finalizeState(e),this.state.parsedPBRMaterial?.generatedTextures.forEach((e=>e.destroy())),this.setState({parsedPBRMaterial:null})}}var se=n(57291),re=n(76435),ae=n(99543),le=n(82736);const ce=[0],ue={getPointColor:{type:"accessor",value:[0,0,0,255]},pointSize:1,data:"",loader:le.u,onTilesetLoad:{type:"function",value:e=>{}},onTileLoad:{type:"function",value:e=>{}},onTileUnload:{type:"function",value:e=>{}},onTileError:{type:"function",value:(e,t,n)=>{}},_getMeshColor:{type:"function",value:e=>[255,255,255]}};class he extends o.Z{static{this.defaultProps=ue}static{this.layerName="Tile3DLayer"}initializeState(){"onTileLoadFail"in this.props&&s.Z.removed("onTileLoadFail","onTileError")(),this.state={layerMap:{},tileset3d:null,activeViewports:{},lastUpdatedViewports:null}}get isLoaded(){return Boolean(this.state?.tileset3d?.isLoaded()&&super.isLoaded)}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState({props:e,oldProps:t,changeFlags:n}){if(e.data&&e.data!==t.data&&this._loadTileset(e.data),n.viewportChanged){const{activeViewports:e}=this.state;Object.keys(e).length&&(this._updateTileset(e),this.state.lastUpdatedViewports=e,this.state.activeViewports={})}if(n.propsChanged){const{layerMap:e}=this.state;for(const t in e)e[t].needsUpdate=!0}}activateViewport(e){const{activeViewports:t,lastUpdatedViewports:n}=this.state;this.internalState.viewport=e,t[e.id]=e;const i=n?.[e.id];i&&e.equals(i)||(this.setChangeFlags({viewportChanged:!0}),this.setNeedsUpdate())}getPickingInfo({info:e,sourceLayer:t}){const n=t&&t.props.tile;return e.picked&&(e.object=n),e.sourceTile=n,e}filterSubLayer({layer:e,viewport:t}){const{tile:n}=e.props,{id:i}=t;return n.selected&&n.viewportIds.includes(i)}_updateAutoHighlight(e){const t=e.sourceTile,n=this.state.layerMap[t?.id];n&&n.layer&&n.layer.updateAutoHighlight(e)}async _loadTileset(e){const{loadOptions:t={}}=this.props,n=this.props.loader||this.props.loaders,i=Array.isArray(n)?n[0]:n,o={loadOptions:{...t}};let s=e;if(i.preload){const n=await i.preload(e,t);n.url&&(s=n.url),n.headers&&(o.loadOptions.fetch={...o.loadOptions.fetch,headers:n.headers}),Object.assign(o,n)}const r=await(0,se.z)(s,i,o.loadOptions),a=new re.u(r,{onTileLoad:this._onTileLoad.bind(this),onTileUnload:this._onTileUnload.bind(this),onTileError:this.props.onTileError,...o});this.setState({tileset3d:a,layerMap:{}}),this._updateTileset(this.state.activeViewports),this.props.onTilesetLoad(a)}_onTileLoad(e){const{lastUpdatedViewports:t}=this.state;this.props.onTileLoad(e),this._updateTileset(t),this.setNeedsUpdate()}_onTileUnload(e){delete this.state.layerMap[e.id],this.props.onTileUnload(e)}_updateTileset(e){if(!e)return;const{tileset3d:t}=this.state,{timeline:n}=this.context,i=Object.keys(e).length;n&&i&&t&&t.selectTiles(Object.values(e)).then((e=>{this.state.frameNumber!==e&&this.setState({frameNumber:e})}))}_getSubLayer(e,t){if(!e.content)return null;switch(e.type){case ae.R7.POINTCLOUD:return this._makePointCloudLayer(e,t);case ae.R7.SCENEGRAPH:return this._make3DModelLayer(e);case ae.R7.MESH:return this._makeSimpleMeshLayer(e,t);default:throw new Error(`Tile3DLayer: Failed to render layer of type ${e.content.type}`)}}_makePointCloudLayer(e,t){const{attributes:n,pointCount:i,constantRGBA:o,cartographicOrigin:s,modelMatrix:l}=e.content,{positions:c,normals:u,colors:h}=n;if(!c)return null;const d=t&&t.props.data||{header:{vertexCount:i},attributes:{POSITION:c,NORMAL:u,COLOR_0:h}},{pointSize:p,getPointColor:f}=this.props;return new(this.getSubLayerClass("pointcloud",a.Z))({pointSize:p},this.getSubLayerProps({id:"pointcloud"}),{id:`${this.id}-pointcloud-${e.id}`,tile:e,data:d,coordinateSystem:r.COORDINATE_SYSTEM.METER_OFFSETS,coordinateOrigin:s,modelMatrix:l,getColor:o||f,_offset:0})}_make3DModelLayer(e){const{gltf:t,instances:n,cartographicOrigin:i,modelMatrix:o}=e.content;return new(this.getSubLayerClass("scenegraph",$))({_lighting:"pbr"},this.getSubLayerProps({id:"scenegraph"}),{id:`${this.id}-scenegraph-${e.id}`,tile:e,data:n||ce,scenegraph:t,coordinateSystem:r.COORDINATE_SYSTEM.METER_OFFSETS,coordinateOrigin:i,modelMatrix:o,getTransformMatrix:e=>e.modelMatrix,getPosition:[0,0,0],_offset:0})}_makeSimpleMeshLayer(e,t){const n=e.content,{attributes:o,indices:s,modelMatrix:a,cartographicOrigin:l,coordinateSystem:c=r.COORDINATE_SYSTEM.METER_OFFSETS,material:u,featureIds:h}=n,{_getMeshColor:d}=this.props,p=t&&t.props.mesh||new i.Z({topology:"triangle-list",attributes:de(o),indices:s});return new(this.getSubLayerClass("mesh",oe))(this.getSubLayerProps({id:"mesh"}),{id:`${this.id}-mesh-${e.id}`,tile:e,mesh:p,data:ce,getColor:d(e),pbrMaterial:u,modelMatrix:a,coordinateOrigin:l,coordinateSystem:c,featureIds:h,_offset:0})}renderLayers(){const{tileset3d:e,layerMap:t}=this.state;return e?e.tiles.map((e=>{const n=t[e.id]=t[e.id]||{tile:e};let{layer:i}=n;return e.selected&&(i?n.needsUpdate&&(i=this._getSubLayer(e,i),n.needsUpdate=!1):i=this._getSubLayer(e)),n.layer=i,i})).filter(Boolean):null}}function de(e){const t={};return t.positions={...e.positions,value:new Float32Array(e.positions.value)},e.normals&&(t.normals=e.normals),e.texCoords&&(t.texCoords=e.texCoords),e.colors&&(t.colors=e.colors),e.uvRegions&&(t.uvRegions=e.uvRegions),t}},70311:(e,t,n)=>{"use strict";n.d(t,{F:()=>l});var i=n(99955),o=n(52025),s=n(22482),r=n(38560),a=n(43347);class l extends i.O{constructor(e=0,t=0){super(2),(0,o.kJ)(e)&&1===arguments.length?this.copy(e):(o.vc.debug&&((0,s.u5)(e),(0,s.u5)(t)),this[0]=e,this[1]=t)}set(e,t){return this[0]=e,this[1]=t,this.check()}copy(e){return this[0]=e[0],this[1]=e[1],this.check()}fromObject(e){return o.vc.debug&&((0,s.u5)(e.x),(0,s.u5)(e.y)),this[0]=e.x,this[1]=e.y,this.check()}toObject(e){return e.x=this[0],e.y=this[1],e}get ELEMENTS(){return 2}horizontalAngle(){return Math.atan2(this.y,this.x)}verticalAngle(){return Math.atan2(this.x,this.y)}transform(e){return this.transformAsPoint(e)}transformAsPoint(e){return(0,r.fF)(this,this,e),this.check()}transformAsVector(e){return(0,a.pb)(this,this,e),this.check()}transformByMatrix3(e){return(0,r.kK)(this,this,e),this.check()}transformByMatrix2x3(e){return(0,r.iu)(this,this,e),this.check()}transformByMatrix2(e){return(0,r.c)(this,this,e),this.check()}}},63677:(e,t,n)=>{"use strict";n.d(t,{H:()=>w});var i=n(81180),o=n(68821),s=n(12813),r=n(79951),a=n(91220),l=n(93234),c=n(52025);const u=6378137,h=6378137,d=6356752.314245179;Math.max(u,h,d);function p(e){return e}new o.P;function f(e,t=[],n=p){return"longitude"in e?(t[0]=n(e.longitude),t[1]=n(e.latitude),t[2]=e.height):"x"in e?(t[0]=n(e.x),t[1]=n(e.y),t[2]=e.z):(t[0]=n(e[0]),t[1]=n(e[1]),t[2]=e[2]),t}function m(e,t,n=p){return"longitude"in t?(t.longitude=n(e[0]),t.latitude=n(e[1]),t.height=e[2]):"x"in t?(t.x=n(e[0]),t.y=n(e[1]),t.z=e[2]):(t[0]=n(e[0]),t[1]=n(e[1]),t[2]=e[2]),t}const g=new o.P,_={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}},v={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},S={east:new o.P,north:new o.P,up:new o.P,west:new o.P,south:new o.P,down:new o.P},x=new o.P,b=new o.P,y=new o.P;function M(e,t,n,i,o,s){const a=_[t]&&_[t][n];let l,u,h;(0,r.h)(a&&(!i||i===a));const d=g.copy(o);if((0,c.fS)(d.x,0,1e-14)&&(0,c.fS)(d.y,0,1e-14)){const e=Math.sign(d.z);l=x.fromArray(v[t]),"east"!==t&&"west"!==t&&l.scale(e),u=b.fromArray(v[n]),"east"!==n&&"west"!==n&&u.scale(e),h=y.fromArray(v[i]),"east"!==i&&"west"!==i&&h.scale(e)}else{const{up:o,east:s,north:r}=S;s.set(-d.y,d.x,0).normalize(),e.geodeticSurfaceNormal(d,o),r.copy(o).cross(s);const{down:a,west:c,south:p}=S;a.copy(o).scale(-1),c.copy(s).scale(-1),p.copy(r).scale(-1),l=S[t],u=S[n],h=S[i]}return s[0]=l.x,s[1]=l.y,s[2]=l.z,s[3]=0,s[4]=u.x,s[5]=u.y,s[6]=u.z,s[7]=0,s[8]=h.x,s[9]=h.y,s[10]=h.z,s[11]=0,s[12]=d.x,s[13]=d.y,s[14]=d.z,s[15]=1,s}const A=new o.P,C=new o.P,R=new o.P;const E=new o.P,L=new o.P,P=new o.P,I=new o.P,T=new o.P,N=new o.P;class w{constructor(e=0,t=0,n=0){(0,i.Z)(this,"radii",void 0),(0,i.Z)(this,"radiiSquared",void 0),(0,i.Z)(this,"radiiToTheFourth",void 0),(0,i.Z)(this,"oneOverRadii",void 0),(0,i.Z)(this,"oneOverRadiiSquared",void 0),(0,i.Z)(this,"minimumRadius",void 0),(0,i.Z)(this,"maximumRadius",void 0),(0,i.Z)(this,"centerToleranceSquared",s.Bs),(0,i.Z)(this,"squaredXOverSquaredZ",void 0),(0,r.h)(e>=0),(0,r.h)(t>=0),(0,r.h)(n>=0),this.radii=new o.P(e,t,n),this.radiiSquared=new o.P(e*e,t*t,n*n),this.radiiToTheFourth=new o.P(e*e*e*e,t*t*t*t,n*n*n*n),this.oneOverRadii=new o.P(0===e?0:1/e,0===t?0:1/t,0===n?0:1/n),this.oneOverRadiiSquared=new o.P(0===e?0:1/(e*e),0===t?0:1/(t*t),0===n?0:1/(n*n)),this.minimumRadius=Math.min(e,t,n),this.maximumRadius=Math.max(e,t,n),0!==this.radiiSquared.z&&(this.squaredXOverSquaredZ=this.radiiSquared.x/this.radiiSquared.z),Object.freeze(this)}equals(e){return this===e||Boolean(e&&this.radii.equals(e.radii))}toString(){return this.radii.toString()}cartographicToCartesian(e,t=[0,0,0]){const n=L,i=P,[,,o]=e;this.geodeticSurfaceNormalCartographic(e,n),i.copy(this.radiiSquared).scale(n);const s=Math.sqrt(n.dot(i));return i.scale(1/s),n.scale(o),i.add(n),i.to(t)}cartesianToCartographic(e,t=[0,0,0]){N.from(e);const n=this.scaleToGeodeticSurface(N,I);if(!n)return;const i=this.geodeticSurfaceNormal(n,L),o=T;o.copy(N).subtract(n);const s=Math.atan2(i.y,i.x),r=Math.asin(i.z),l=Math.sign(a.AK(o,N))*a.kE(o);return m([s,r,l],t,c.vc._cartographicRadians?p:c.Ux)}eastNorthUpToFixedFrame(e,t=new l.y){return M(this,"east","north","up",e,t)}localFrameToFixedFrame(e,t,n,i,o=new l.y){return M(this,e,t,n,i,o)}geocentricSurfaceNormal(e,t=[0,0,0]){return E.from(e).normalize().to(t)}geodeticSurfaceNormalCartographic(e,t=[0,0,0]){const n=function(e,t=[]){return f(e,t,c.vc._cartographicRadians?p:c.Yr)}(e),i=n[0],o=n[1],s=Math.cos(o);return E.set(s*Math.cos(i),s*Math.sin(i),Math.sin(o)).normalize(),E.to(t)}geodeticSurfaceNormal(e,t=[0,0,0]){return E.from(e).scale(this.oneOverRadiiSquared).normalize().to(t)}scaleToGeodeticSurface(e,t){return function(e,t,n=[]){const{oneOverRadii:i,oneOverRadiiSquared:o,centerToleranceSquared:r}=t;A.from(e);const a=A.x,l=A.y,c=A.z,u=i.x,h=i.y,d=i.z,p=a*a*u*u,f=l*l*h*h,m=c*c*d*d,g=p+f+m,_=Math.sqrt(1/g);if(!Number.isFinite(_))return;const v=C;if(v.copy(e).scale(_),g<r)return v.to(n);const S=o.x,x=o.y,b=o.z,y=R;y.set(v.x*S*2,v.y*x*2,v.z*b*2);let M,E,L,P,I=(1-_)*A.len()/(.5*y.len()),T=0;do{I-=T,M=1/(1+I*S),E=1/(1+I*x),L=1/(1+I*b);const e=M*M,t=E*E,n=L*L;P=p*e+f*t+m*n-1,T=P/(-2*(p*(e*M)*S+f*(t*E)*x+m*(n*L)*b))}while(Math.abs(P)>s.KC);return A.scale([M,E,L]).to(n)}(e,this,t)}scaleToGeocentricSurface(e,t=[0,0,0]){I.from(e);const n=I.x,i=I.y,o=I.z,s=this.oneOverRadiiSquared,r=1/Math.sqrt(n*n*s.x+i*i*s.y+o*o*s.z);return I.multiplyScalar(r).to(t)}transformPositionToScaledSpace(e,t=[0,0,0]){return I.from(e).scale(this.oneOverRadii).to(t)}transformPositionFromScaledSpace(e,t=[0,0,0]){return I.from(e).scale(this.radii).to(t)}getSurfaceNormalIntersectionWithZAxis(e,t=0,n=[0,0,0]){(0,r.h)((0,c.fS)(this.radii.x,this.radii.y,s.H2)),(0,r.h)(this.radii.z>0),I.from(e);const i=I.z*(1-this.squaredXOverSquaredZ);if(!(Math.abs(i)>=this.radii.z-t))return I.set(0,0,i).to(n)}}(0,i.Z)(w,"WGS84",new w(u,h,d))},25811:(e,t,n)=>{"use strict";n.d(t,{ZP:()=>i});const i=new(n(79962).Z)({id:"@probe.gl/log"})}}]);