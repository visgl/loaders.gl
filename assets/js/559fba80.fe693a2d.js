"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1821],{97247:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(85893),s=n(11151);const o={},a="Roadmap",i={id:"arrowjs/roadmap",title:"Roadmap",description:"What's Next for Apache Arrow in Javascript",source:"@site/../docs/arrowjs/roadmap.md",sourceDirName:"arrowjs",slug:"/arrowjs/roadmap",permalink:"/docs/arrowjs/roadmap",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/arrowjs/roadmap.md",tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Feature Completeness",id:"feature-completeness",level:2}];function d(e){const t={h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"roadmap",children:"Roadmap"}),"\n",(0,r.jsx)(t.p,{children:"What's Next for Apache Arrow in Javascript"}),"\n",(0,r.jsx)(t.p,{children:"There are a lot of features we'd like to add over the next few Javascript releases:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Inline predicates"}),": Function calls in the inner loop of a scan over millions of records can be very expensive. We can potentially save that time by generating a new scan function with the predicates inlined when a filter is created."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Cache filter results"}),": Right now every time we do a scan on a filtered DataFrame we re-check the predicate on every row. There should be an (optional?) lazily computed index to store the predicate results for subsequent re-use."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Friendlier API"}),": I shouldn't have to write a custom scan function just to take a look at the results of a filter! Every DataFrame should have a toJSON() function (See ARROW-2202)."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"node.js \u2194 (Python, C++, Java, ...) interaction"}),": A big benefit of Arrow's common in-memory format is that different tools can operate on the same memory. Unfortunately we're pretty closed off in the browser, but node doesn't have that problem! Finishing ARROW-1700, node.js Plasma store client should make this type of interaction possible."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Have an idea? Tell us! Generally JIRAs are preferred but we'll take GitHub issues too. If you just want to discuss something, reach out on the mailing list or slack. But PRs are the best of all, we can always use more contributors!"}),"\n",(0,r.jsx)(t.h2,{id:"feature-completeness",children:"Feature Completeness"}),"\n",(0,r.jsx)(t.p,{children:"Ideally each Apache Arrow language binding would offer the same set of features, at least to the extent that the language/platform in question allows. In practice however, not all features have been implemented in all language bindings."}),"\n",(0,r.jsx)(t.p,{children:"In comparison with the C++ Arrow API bindings, there are some missing features in the JavaScript bindings:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Tensors are not yet supported."}),"\n",(0,r.jsx)(t.li,{children:"No explicit support for Apache Arrow Flight"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>a});var r=n(67294);const s={},o=r.createContext(s);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);