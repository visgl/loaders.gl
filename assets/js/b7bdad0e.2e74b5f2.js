"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[3410],{49622:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>a,toc:()=>l});var s=t(74848),n=t(28453);const d={},i="LERCLoader",a={id:"modules/lerc/api-reference/lerc-loader",title:"LERCLoader",description:"&nbsp;",source:"@site/../docs/modules/lerc/api-reference/lerc-loader.md",sourceDirName:"modules/lerc/api-reference",slug:"/modules/lerc/api-reference/lerc-loader",permalink:"/docs/modules/lerc/api-reference/lerc-loader",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/modules/lerc/api-reference/lerc-loader.md",tags:[],version:"current",frontMatter:{}},c={},l=[{value:"Usage",id:"usage",level:2},{value:"Parsed Data Format",id:"parsed-data-format",level:2},{value:"Options",id:"options",level:2}];function o(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"lercloader",children:"LERCLoader"}),"\n",(0,s.jsxs)("p",{class:"badges",children:[(0,s.jsx)("img",{src:"https://img.shields.io/badge/From-v3.3-blue.svg?style=flat-square",alt:"From-3.3"}),(0,s.jsx)(r.p,{children:"\xa0"}),(0,s.jsx)("img",{src:"https://img.shields.io/badge/-BETA-teal.svg",alt:"BETA"})]}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"LERCLoader"})," parses the binary compressed raster format as described in ",(0,s.jsx)(r.a,{href:"https://github.com/Esri/lerc/blob/master/doc/Lerc_ByteStream_Specification.pdf",children:"LERC Byte Stream Specification"}),"."]}),"\n",(0,s.jsx)(r.p,{children:'LERC (Limited Error Raster Compression), also written Lerc, is a format for compressed raster image data. It was developed by Esri.\nIt may appear in a file by itself, or as part of MRF format, or be used as a compression method in a format such as GeoTIFF.\nThere are two major versions, known as "Lerc1" and "Lerc2".'}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Loader"}),(0,s.jsx)(r.th,{children:"Characteristic"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"File Extension"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:".lrc"}),", ",(0,s.jsx)(r.code,{children:".lerc"}),", ",(0,s.jsx)(r.code,{children:".lerc2"}),", ",(0,s.jsx)(r.code,{children:".lerc1"})]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"File Type"}),(0,s.jsx)(r.td,{children:"Binary"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"File Format"}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Web_Map_Service",children:"LERC"})})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Data Format"}),(0,s.jsx)(r.td,{children:"Data structure"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Decoder Type"}),(0,s.jsx)(r.td,{children:"Synchronous"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Worker Thread Support"}),(0,s.jsx)(r.td,{children:"Yes"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Streaming Support"}),(0,s.jsx)(r.td,{children:"No"})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"import {LERCLoader} from '@loaders.gl/wms';\nimport {load} from '@loaders.gl/core';\n\n// Form a LERC request\nconst url = `${WFS_SERVICE_URL}?REQUEST=GetFeature&...`;\n\nconst data = await load(url, LERCLoader, options);\n"})}),"\n",(0,s.jsx)(r.h2,{id:"parsed-data-format",children:"Parsed Data Format"}),"\n",(0,s.jsxs)(r.p,{children:["Data returned by ",(0,s.jsx)(r.code,{children:"LERCLoader"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"export type LERCData = {\n  /**\tWidth of decoded image */\n  width: number;\n  /**\tHeight of decoded image */\n  height: number;\n  /**\tThe type of pixels represented in the output */\n  pixelType: LercPixelType;\n  /**\t[statistics_band1, statistics_band2, \u2026] Each element is a statistics object representing min and max values  */\n  statistics: BandStats[];\n  /**\t[band1, band2, \u2026] Each band is a typed array of width * height * depthCount */\n  pixels: TypedArray[];\n  /**\tTyped array with a size of width*height, or null if all pixels are valid */\n  mask: Uint8Array;\n  /**\tDepth count  */\n  depthCount: number;\n  /**\tarray\t[band1_mask, band2_mask, \u2026] Each band is a Uint8Array of width * height * depthCount */\n  bandMasks?: Uint8Array[];\n};\n\nexport type LercPixelType = 'S8' | 'U8' | 'S16' | 'U16' | 'S32' | 'U32' | 'F32' | 'F64';\n\nexport interface BandStats {\n  minValue: number;\n  maxValue: number;\n  depthStats?: {\n    minValues: Float64Array;\n    maxValues: Float64Array;\n  };\n}\n"})}),"\n",(0,s.jsx)(r.h2,{id:"options",children:"Options"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Option"}),(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Default"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"lerc.inputOffset?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"number"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"0"})}),(0,s.jsx)(r.td,{children:"The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"lerc.noDataValue?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"number"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"false"})}),(0,s.jsx)(r.td,{children:"It is recommended to use the returned mask instead of setting this value"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"lerc.returnInterleaved?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"boolean"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"false"})}),(0,s.jsx)(r.td,{children:"(ndepth LERC2 only) If true, returned depth values are pixel-interleaved"})]})]})]})]})}function h(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>a});var s=t(96540);const n={},d=s.createContext(n);function i(e){const r=s.useContext(d);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(d.Provider,{value:r},e.children)}}}]);