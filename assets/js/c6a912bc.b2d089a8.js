"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1890],{6759:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>d,contentTitle:()=>n,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=r(74848),t=r(28453);const i={},n="Introduction",o={id:"arrowjs/developer-guide/introduction",title:"Introduction",description:"Apache Arrow is a binary specification and set of libraries for representing Tables and Columns of strongly-typed fixed-width, variable-width, and nested data structures in-memory and over-the-wire.",source:"@site/../docs/arrowjs/developer-guide/introduction.md",sourceDirName:"arrowjs/developer-guide",slug:"/arrowjs/developer-guide/introduction",permalink:"/docs/arrowjs/developer-guide/introduction",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/arrowjs/developer-guide/introduction.md",tags:[],version:"current",frontMatter:{}},d={},l=[{value:"Components",id:"components",level:2},{value:"Data Types",id:"data-types",level:2},{value:"Fixed-width Data Types",id:"fixed-width-data-types",level:3},{value:"Variable-width Data Types",id:"variable-width-data-types",level:3},{value:"Composite Data Types",id:"composite-data-types",level:3}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.h1,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(s.p,{children:"Apache Arrow is a binary specification and set of libraries for representing Tables and Columns of strongly-typed fixed-width, variable-width, and nested data structures in-memory and over-the-wire."}),"\n",(0,a.jsx)(s.p,{children:"Arrow represents columns of values in sets of contiguous buffers. This is in contrast to a row-oriented representation, where the values for each row are stored in a contiguous buffer. The columnar representation makes it easier to take advantage of SIMD instruction sets in modern CPUs and GPUs, and can lead to dramatic performance improvements processing large amounts of data."}),"\n",(0,a.jsx)(s.h2,{id:"components",children:"Components"}),"\n",(0,a.jsx)(s.p,{children:"The Arrow library is organized into separate components responsible for creating, reading, writing, serializing, deserializing, or manipulating Tables or Columns."}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Data Types"})," - Classes that define the fixed-width, variable-width, and composite data types Arrow can represent"]}),"\n",(0,a.jsx)(s.li,{children:"Vectors - Classes to read and decode JavaScript values from the underlying buffers or Vectors for each data type"}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/builders",children:"Builders"})," - Classes to write and encode JavaScript values into the underlying buffers or Vectors for each data type"]}),"\n",(0,a.jsx)(s.li,{children:"Visitors - Classes to traverse, manipulate, read, write, or aggregate values from trees of Arrow Vectors or DataTypes"}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/reading-and-writing",children:"IPC Readers and Writers"})," - Classes to read and write the Arrow IPC (inter-process communication) binary file and stream formats"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/schemas",children:"Fields, Schemas, RecordBatches, Tables, and Columns"})," - Classes to describe, manipulate, read, and write groups of strongly-typed Vectors or Columns"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"data-types",children:"Data Types"}),"\n",(0,a.jsxs)(s.p,{children:["At the heart of Arrow is set of well-known logical ",(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"data types"}),", ensuring each Column in an Arrow Table is strongly-typed. These data types define how a Column's underlying buffers should be constructed and read, and includes configurable (and custom) metadata fields for further annotating a Column. A Schema describing each Column's name and data type is encoded alongside each Column's data buffers, allowing you to consume an Arrow data source without knowing the data types or column layout beforehand."]}),"\n",(0,a.jsxs)(s.p,{children:["Each data type falls into one of three rough categories: Fixed-width types, variable-width types, or composite types that contain other Arrow data types. All data types can represent null values, which are stored in a separate validity ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Mask_(computing)",children:"bitmask"}),". Follow the links below for a more detailed description of each data type."]}),"\n",(0,a.jsx)(s.h3,{id:"fixed-width-data-types",children:"Fixed-width Data Types"}),"\n",(0,a.jsxs)(s.p,{children:["Fixed-width data types describe physical primitive values (bytes or bits of some fixed size), or logical values that can be represented as primitive values. In addition to an optional ",(0,a.jsx)(s.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",children:(0,a.jsx)(s.code,{children:"Uint8Array"})})," validity bitmask, these data types have a physical data buffer (a ",(0,a.jsx)(s.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray#TypedArray_objects",children:(0,a.jsx)(s.code,{children:"TypedArray"})})," corresponding to the data type's physical element width)."]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Null"})," - A column of NULL values having no physical storage"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Bool"})," - Booleans as either 0 or 1 (bit-packed, LSB-ordered)"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Int"})," - Signed or unsigned 8, 16, 32, or 64-bit little-endian integers"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Float"})," - 2, 4, or 8-byte floating point values"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Decimal"})," - Precision-and-scale-based 128-bit decimal values"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"FixedSizeBinary"})," - A list of fixed-size binary sequences, where each value occupies the same number of bytes"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Date"})," - Date as signed 32-bit integer days or 64-bit integer milliseconds since the UNIX epoch"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Time"})," - Time as signed 32 or 64-bit integers, representing either seconds, millisecond, microseconds, or nanoseconds since midnight (00:00:00)"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Timestamp"})," - Exact timestamp as signed 64-bit integers, representing either seconds, milliseconds, microseconds, or nanoseconds since the UNIX epoch"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Interval"})," - Time intervals as pairs of either (year, month) or (day, time) in SQL style"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"FixedSizeList"})," - Fixed-size sequences of another logical Arrow data type"]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"variable-width-data-types",children:"Variable-width Data Types"}),"\n",(0,a.jsxs)(s.p,{children:["Variable-width types describe lists of values with different widths, including binary blobs, Utf8 code-points, or slices of another underlying Arrow data type. These types store the values contiguously in memory, and have a physical ",(0,a.jsx)(s.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",children:(0,a.jsx)(s.code,{children:"Int32Array"})})," of offsets that describe the start and end indicies of each list element."]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"List"})," - Variable-length sequences of another logical Arrow data type"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Utf8"})," - Variable-length byte sequences of UTF8 code-points (strings)"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Binary"})," - Variable-length byte sequences (no guarantee of UTF8-ness)"]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"composite-data-types",children:"Composite Data Types"}),"\n",(0,a.jsx)(s.p,{children:"Composite types don't have physical data buffers of their own. They contain other Arrow data types and delegate work to them."}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Union"})," - Union of logical child data types"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Map"})," - Map of named logical child data types"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Struct"})," - Struct of ordered logical child data types"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>n,x:()=>o});var a=r(96540);const t={},i=a.createContext(t);function n(e){const s=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:n(e.components),a.createElement(i.Provider,{value:s},e.children)}}}]);