"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[3863],{17361:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});var n=s(85893),o=s(11151);const t={},a="Handling Errors",i={id:"developer-guide/error-handling",title:"Handling Errors",description:"Applications that implement loading and saving of data typically wish to provide solid error handling. A number of error conditions can occur that are outside the applications control (missing files, unreadable files, incorrectly formatted files etc).Being able to catch these errors and surface meaningful error messages to the end user is important.",source:"@site/../docs/developer-guide/error-handling.md",sourceDirName:"developer-guide",slug:"/developer-guide/error-handling",permalink:"/docs/developer-guide/error-handling",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/developer-guide/error-handling.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Composite Loaders",permalink:"/docs/developer-guide/composite-loaders"},next:{title:"Development Environment",permalink:"/docs/developer-guide/dev-env"}},c={},d=[{value:"Types of Errors",id:"types-of-errors",level:2},{value:"Error Messages",id:"error-messages",level:3},{value:"parse Error Handling",id:"parse-error-handling",level:2},{value:"Handling Errors from Async Functions",id:"handling-errors-from-async-functions",level:2},{value:"fetch Error Handling",id:"fetch-error-handling",level:2}];function l(e){const r={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"handling-errors",children:"Handling Errors"}),"\n",(0,n.jsx)(r.p,{children:"Applications that implement loading and saving of data typically wish to provide solid error handling. A number of error conditions can occur that are outside the applications control (missing files, unreadable files, incorrectly formatted files etc).Being able to catch these errors and surface meaningful error messages to the end user is important."}),"\n",(0,n.jsx)(r.p,{children:"Ideally the applications wants a simple and clean API for performing loading, and still have the confidence that errors are caught and meaningful messages are presented to the user."}),"\n",(0,n.jsx)(r.h2,{id:"types-of-errors",children:"Types of Errors"}),"\n",(0,n.jsx)(r.p,{children:"There are three main types of errors that arise when attempting to load a data resource:"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsx)(r.li,{children:"There is some kind of network/resource access error, preventing the request for data from being completed."}),"\n",(0,n.jsx)(r.li,{children:"A request is sent to a server, but the server is unable to service the request due to some error condition (often illegal access tokens or request parameters) and sends an error response."}),"\n",(0,n.jsx)(r.li,{children:"The server returns data, but the parser is unable to parse it (perhaps due to the data being malformatted, or formatted according to an unsupported version of that format)."}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"loaders.gl can detect all of these error conditions and report the resulting errors in a unified way (the errors will be available as exceptions or rejected promises depending on your async programming style, see below)."}),"\n",(0,n.jsx)(r.h3,{id:"error-messages",children:"Error Messages"}),"\n",(0,n.jsx)(r.p,{children:"loaders.gl aims to produce concise, easy-to-understand error messages that can be presented directly to the end user."}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["When the ",(0,n.jsx)(r.code,{children:"fetch"})," call fails, any exceptions are passed to the user,"]}),"\n",(0,n.jsx)(r.li,{children:"When a loader fails, it generates an error message."}),"\n",(0,n.jsxs)(r.li,{children:["For server error responses, some basic information about the error is compiled into an error message (using e.g. ",(0,n.jsx)(r.code,{children:"response.status"}),", ",(0,n.jsx)(r.code,{children:"response.url"})," and occasionally ",(0,n.jsx)(r.code,{children:"response.text"}),")."]}),"\n"]}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsxs)(r.p,{children:["Note that while servers often send some information about errors in ",(0,n.jsx)(r.code,{children:"response.text()"})," when setting HTTP error codes, there are no universally accepted conventions for how servers format those error messages. Server error messages can be JSON or XML encoded for machine consumption, or generated in HTML or clear text format intended to be displayed directly to end user. Even when JSON or XML coded,"]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:['loaders.gl makes a "best effort" attempt to extract some meaningful error message from server responses. If you know how your specific service formats errors and want to extract these in a way that you can present to the user, you may want to take control of the ',(0,n.jsx)(r.code,{children:"fetch"})," calls and ",(0,n.jsx)(r.code,{children:"Response"})," status checking, see below."]}),"\n",(0,n.jsx)(r.h2,{id:"parse-error-handling",children:"parse Error Handling"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"parse"})," accepts fetch ",(0,n.jsx)(r.code,{children:"Response"})," objects, and ",(0,n.jsx)(r.code,{children:"parse"})," will check the status of the ",(0,n.jsx)(r.code,{children:"Response"})," before attempting to parse, and generate an exception if appropriate."]}),"\n",(0,n.jsx)(r.h2,{id:"handling-errors-from-async-functions",children:"Handling Errors from Async Functions"}),"\n",(0,n.jsxs)(r.p,{children:["Note that ",(0,n.jsx)(r.code,{children:"parse"})," is an async function, and in JavaScript, errors generated by async functions will be reported either as an exception or as a rejected promise, depending on how the async funtion was called (using promises or the ",(0,n.jsx)(r.code,{children:"await"})," keyword):"]}),"\n",(0,n.jsxs)(r.p,{children:["When using ",(0,n.jsx)(r.code,{children:"await"}),", errors are reported as exceptions"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",children:"try {\n  const response = await fetch(url);\n  const data = await parse(response);\n} catch (error) {\n  console.log(error);\n}\n"})}),"\n",(0,n.jsxs)(r.p,{children:["A rejected promise is generated when using ",(0,n.jsx)(r.code,{children:"Promise.then"}),"."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",children:"fetch(url)\n  .then((response) => parse(response))\n  .catch((error) => console.log(error));\n"})}),"\n",(0,n.jsx)(r.p,{children:"Also note that the Javascript runtime seamlessly converts errors between exceptions and promises in mixed code."}),"\n",(0,n.jsx)(r.h2,{id:"fetch-error-handling",children:"fetch Error Handling"}),"\n",(0,n.jsxs)(r.p,{children:["loaders.gl is designed around the use of the modern JavaScript ",(0,n.jsx)(r.code,{children:"fetch"})," API, so for additional context, it may help to review of how the JavaSctipt ",(0,n.jsx)(r.code,{children:"fetch"})," function handles errors."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"fetch"}),' separates between "network errors" that can be detected directly (these cause the ',(0,n.jsx)(r.code,{children:"fetch"})," to throw an exception) and server side errors that are reported asynchronously with HTTP status codes (in this case the ",(0,n.jsx)(r.code,{children:"Response"})," object offers accessors that must be called to check if the operation was successful before accessing data)."]}),"\n",(0,n.jsx)(r.p,{children:'Example: "manually" checking separately for fetch network errors and server errors:'}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",children:"// Check for network error\nlet response;\ntry {\n  response = await fetch(url);\n} catch (error) {\n  console.log('Network error');\n}\n\n// Check for server error\nif (!response.ok) {\n  console.log(`fetch failed with status ${response.status}`);\n}\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Note that servers often sends a message providing some detail about what went wrong, and that message can be accessed using the standard (asynchronous) ",(0,n.jsx)(r.code,{children:"response.text()"})," or ",(0,n.jsx)(r.code,{children:"response.json()"})," methods."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",children:"if (!response.ok) {\n  const errorMessage = await response.text();\n  // Custom parsing can be done here, if you know how your particular service formats errors\n  console.log(`fetch failed with status ${errorMessage}`);\n}\n"})})]})}function h(e={}){const{wrapper:r}={...(0,o.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},11151:(e,r,s)=>{s.d(r,{Z:()=>i,a:()=>a});var n=s(67294);const o={},t=n.createContext(o);function a(e){const r=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(t.Provider,{value:r},e.children)}}}]);