"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8177],{99568:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var t=n(85893),r=n(11151);const a={},o="GeoJSONLoader",i={id:"modules/json/api-reference/geojson-loader",title:"GeoJSONLoader",description:"Streaming loader for GeoJSON encoded files.",source:"@site/../docs/modules/json/api-reference/geojson-loader.md",sourceDirName:"modules/json/api-reference",slug:"/modules/json/api-reference/geojson-loader",permalink:"/docs/modules/json/api-reference/geojson-loader",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/modules/json/api-reference/geojson-loader.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"NDJSONLoader",permalink:"/docs/modules/json/api-reference/ndjson-loader"},next:{title:"GeoJSONWriter",permalink:"/docs/modules/json/api-reference/geojson-writer"}},d={},l=[{value:"Usage",id:"usage",level:2},{value:"Data Format",id:"data-format",level:2},{value:"Options",id:"options",level:2},{value:"JSONPaths",id:"jsonpaths",level:2},{value:"Attribution",id:"attribution",level:2}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"geojsonloader",children:"GeoJSONLoader"}),"\n",(0,t.jsx)(s.p,{children:"Streaming loader for GeoJSON encoded files."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Loader"}),(0,t.jsx)(s.th,{children:"Characteristic"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"File Extension"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:".geojson"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Media Type"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"application/geo+json"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"File Type"}),(0,t.jsx)(s.td,{children:"Text"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"File Format"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://geojson.org",children:"GeoJSON"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Data Format"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/docs/specifications/category-table",children:"Classic Table"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Supported APIs"}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"load"}),", ",(0,t.jsx)(s.code,{children:"parse"}),", ",(0,t.jsx)(s.code,{children:"parseSync"}),", ",(0,t.jsx)(s.code,{children:"parseInBatches"})]})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsx)(s.p,{children:"For simple usage, you can load and parse a JSON file atomically:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:"import {GeoJSONLoader} from '@loaders.gl/json';\nimport {load} from '@loaders.gl/core';\n\nconst data = await load(url, GeoJSONLoader, {json: options});\n"})}),"\n",(0,t.jsxs)(s.p,{children:['For larger files, GeoJSONLoader supports streaming JSON parsing, in which case it will yield "batches" of rows from one array.\nTo parse a stream of GeoJSON, the user can specify the ',(0,t.jsx)(s.code,{children:"options.json.jsonpaths"})," to stream the ",(0,t.jsx)(s.code,{children:"features"})," array."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:"import {GeoJSONLoader} from '@loaders.gl/json';\nimport {loadInBatches} from '@loaders.gl/core';\n\nconst batches = await loadInBatches('geojson.json', GeoJSONLoader, {json: {jsonpaths: ['$.features']}});\n\nfor await (const batch of batches) {\n  // batch.data will contain a number of rows\n  for (const feature of batch.data) {\n    switch (feature.geometry.type) {\n      case 'Polygon':\n      ...\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"If no JSONPath is specified the loader will stream the first array it encounters in the JSON payload."}),"\n",(0,t.jsxs)(s.p,{children:["When batch parsing an embedded JSON array as a table, it is possible to get access to the containing object supplying the ",(0,t.jsx)(s.code,{children:"{metadata: true}"})," option."]}),"\n",(0,t.jsxs)(s.p,{children:["The loader will yield an initial and a final batch with ",(0,t.jsx)(s.code,{children:"batch.container"})," providing the container object and ",(0,t.jsx)(s.code,{children:"batch.batchType"})," set to ",(0,t.jsx)(s.code,{children:"partial-result"})," and ",(0,t.jsx)(s.code,{children:"final-result"})," respectively."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:"import {GeoJSONLoader} from '@loaders.gl/json';\nimport {loadInBatches} from '@loaders.gl/core';\n\nconst batches = await loadInBatches('geojson.json', GeoJSONLoader);\n\nfor await (const batch of batches) {\n  switch (batch.batchType) {\n    case 'partial-result': // contains fields seen so far\n    case 'final-result': // contains all fields except the streamed array\n      console.log(batch.container);\n      break;\n    case 'data:\n      // batch.data will contain a number of rows\n      for (const feature of batch.data) {\n        switch (feature.geometry.type) {\n          case 'Polygon':\n          ...\n        }\n      }\n  }\n}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"data-format",children:"Data Format"}),"\n",(0,t.jsx)(s.p,{children:"Parsed batches are of the format"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"{\n  batchType: 'metadata' | 'partial-result' | 'final-result' | undefined;\n  jsonpath: string;\n\n  // standard batch payload\n  data: any[] | any;\n  bytesUsed: number;\n  batchCount: number;\n}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"options",children:"Options"}),"\n",(0,t.jsxs)(s.p,{children:["Supports table category options such as ",(0,t.jsx)(s.code,{children:"batchType"})," and ",(0,t.jsx)(s.code,{children:"batchSize"}),"."]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Option"}),(0,t.jsx)(s.th,{children:"From"}),(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Default"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"json.table"})}),(0,t.jsxs)(s.td,{children:["[",(0,t.jsx)(s.img,{src:"https://img.shields.io/badge/v2.0-blue.svg?style=flat-square",alt:"Website shields.io"}),"]"]}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"boolean"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"false"})}),(0,t.jsxs)(s.td,{children:["Parses non-streaming JSON as table, i.e. return the first embedded array in the JSON. Always ",(0,t.jsx)(s.code,{children:"true"})," during batched/streaming parsing."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"json.jsonpaths"})}),(0,t.jsxs)(s.td,{children:["[",(0,t.jsx)(s.img,{src:"https://img.shields.io/badge/v2.2-blue.svg?style=flat-square",alt:"Website shields.io"}),"]"]}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"string[]"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"[]"})}),(0,t.jsx)(s.td,{children:"A list of JSON paths (see below) indicating the array that can be streamed."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"metadata"})," (top level)"]}),(0,t.jsxs)(s.td,{children:["[",(0,t.jsx)(s.img,{src:"https://img.shields.io/badge/v2.2-blue.svg?style=flat-square",alt:"Website shields.io"}),"]"]}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"boolean"})}),(0,t.jsxs)(s.td,{children:["If ",(0,t.jsx)(s.code,{children:"true"}),", yields an initial and final batch containing the partial and final result (i.e. the root object, excluding the array being streamed)."]}),(0,t.jsx)(s.td,{})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"jsonpaths",children:"JSONPaths"}),"\n",(0,t.jsx)(s.p,{children:"A minimal subset of the JSONPath syntax is supported, to specify which array in a JSON object should be streamed as batchs."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.code,{children:"$.component1.component2.component3"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["No support for wildcards, brackets etc. Only paths starting with ",(0,t.jsx)(s.code,{children:"$"})," (JSON root) are supported."]}),"\n",(0,t.jsx)(s.li,{children:"Regardless of the paths provided, only arrays will be streamed."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"attribution",children:"Attribution"}),"\n",(0,t.jsxs)(s.p,{children:["This loader is based on a fork of dscape's ",(0,t.jsx)(s.a,{href:"https://github.com/dscape/clarinet",children:(0,t.jsx)(s.code,{children:"clarinet"})})," under BSD 2-clause license."]})]})}function h(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>i,a:()=>o});var t=n(67294);const r={},a=t.createContext(r);function o(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);