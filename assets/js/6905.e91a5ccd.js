"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6905],{9187:e=>{function t(e,t,i){i=i||2;var s,r,a,l,g,d,p,h=t&&t.length,x=h?t[0]*i:e.length,y=n(e,0,x,i,!0),v=[];if(!y||y.next===y.prev)return v;if(h&&(y=function(e,t,i,o){var s,r,a,l=[];for(s=0,r=t.length;s<r;s++)(a=n(e,t[s]*o,s<r-1?t[s+1]*o:e.length,o,!1))===a.next&&(a.steiner=!0),l.push(f(a));for(l.sort(c),s=0;s<l.length;s++)i=u(l[s],i);return i}(e,t,y,i)),e.length>80*i){s=a=e[0],r=l=e[1];for(var m=i;m<x;m+=i)(g=e[m])<s&&(s=g),(d=e[m+1])<r&&(r=d),g>a&&(a=g),d>l&&(l=d);p=0!==(p=Math.max(a-s,l-r))?32767/p:0}return o(y,v,i,s,r,p,0),v}function n(e,t,n,i,o){var s,r;if(o===w(e,t,n,i)>0)for(s=t;s<n;s+=i)r=L(s,e[s],e[s+1],r);else for(s=n-i;s>=t;s-=i)r=L(s,e[s],e[s+1],r);return r&&y(r,r.next)&&(S(r),r=r.next),r}function i(e,t){if(!e)return e;t||(t=e);var n,i=e;do{if(n=!1,i.steiner||!y(i,i.next)&&0!==x(i.prev,i,i.next))i=i.next;else{if(S(i),(i=t=i.prev)===i.next)break;n=!0}}while(n||i!==t);return t}function o(e,t,n,c,u,g,f){if(e){!f&&g&&function(e,t,n,i){var o=e;do{0===o.z&&(o.z=d(o.x,o.y,t,n,i)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){var t,n,i,o,s,r,a,l,c=1;do{for(n=e,e=null,s=null,r=0;n;){for(r++,i=n,a=0,t=0;t<c&&(a++,i=i.nextZ);t++);for(l=c;a>0||l>0&&i;)0!==a&&(0===l||!i||n.z<=i.z)?(o=n,n=n.nextZ,a--):(o=i,i=i.nextZ,l--),s?s.nextZ=o:e=o,o.prevZ=s,s=o;n=i}s.nextZ=null,c*=2}while(r>1)}(o)}(e,c,u,g);for(var p,h,x=e;e.prev!==e.next;)if(p=e.prev,h=e.next,g?r(e,c,u,g):s(e))t.push(p.i/n|0),t.push(e.i/n|0),t.push(h.i/n|0),S(e),e=h.next,x=h.next;else if((e=h)===x){f?1===f?o(e=a(i(e),t,n),t,n,c,u,g,2):2===f&&l(e,t,n,c,u,g):o(i(e),t,n,c,u,g,1);break}}}function s(e){var t=e.prev,n=e,i=e.next;if(x(t,n,i)>=0)return!1;for(var o=t.x,s=n.x,r=i.x,a=t.y,l=n.y,c=i.y,u=o<s?o<r?o:r:s<r?s:r,g=a<l?a<c?a:c:l<c?l:c,d=o>s?o>r?o:r:s>r?s:r,f=a>l?a>c?a:c:l>c?l:c,h=i.next;h!==t;){if(h.x>=u&&h.x<=d&&h.y>=g&&h.y<=f&&p(o,a,s,l,r,c,h.x,h.y)&&x(h.prev,h,h.next)>=0)return!1;h=h.next}return!0}function r(e,t,n,i){var o=e.prev,s=e,r=e.next;if(x(o,s,r)>=0)return!1;for(var a=o.x,l=s.x,c=r.x,u=o.y,g=s.y,f=r.y,h=a<l?a<c?a:c:l<c?l:c,y=u<g?u<f?u:f:g<f?g:f,v=a>l?a>c?a:c:l>c?l:c,m=u>g?u>f?u:f:g>f?g:f,P=d(h,y,t,n,i),_=d(v,m,t,n,i),C=e.prevZ,L=e.nextZ;C&&C.z>=P&&L&&L.z<=_;){if(C.x>=h&&C.x<=v&&C.y>=y&&C.y<=m&&C!==o&&C!==r&&p(a,u,l,g,c,f,C.x,C.y)&&x(C.prev,C,C.next)>=0)return!1;if(C=C.prevZ,L.x>=h&&L.x<=v&&L.y>=y&&L.y<=m&&L!==o&&L!==r&&p(a,u,l,g,c,f,L.x,L.y)&&x(L.prev,L,L.next)>=0)return!1;L=L.nextZ}for(;C&&C.z>=P;){if(C.x>=h&&C.x<=v&&C.y>=y&&C.y<=m&&C!==o&&C!==r&&p(a,u,l,g,c,f,C.x,C.y)&&x(C.prev,C,C.next)>=0)return!1;C=C.prevZ}for(;L&&L.z<=_;){if(L.x>=h&&L.x<=v&&L.y>=y&&L.y<=m&&L!==o&&L!==r&&p(a,u,l,g,c,f,L.x,L.y)&&x(L.prev,L,L.next)>=0)return!1;L=L.nextZ}return!0}function a(e,t,n){var o=e;do{var s=o.prev,r=o.next.next;!y(s,r)&&v(s,o,o.next,r)&&_(s,r)&&_(r,s)&&(t.push(s.i/n|0),t.push(o.i/n|0),t.push(r.i/n|0),S(o),S(o.next),o=e=r),o=o.next}while(o!==e);return i(o)}function l(e,t,n,s,r,a){var l=e;do{for(var c=l.next.next;c!==l.prev;){if(l.i!==c.i&&h(l,c)){var u=C(l,c);return l=i(l,l.next),u=i(u,u.next),o(l,t,n,s,r,a,0),void o(u,t,n,s,r,a,0)}c=c.next}l=l.next}while(l!==e)}function c(e,t){return e.x-t.x}function u(e,t){var n=function(e,t){var n,i=t,o=e.x,s=e.y,r=-1/0;do{if(s<=i.y&&s>=i.next.y&&i.next.y!==i.y){var a=i.x+(s-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(a<=o&&a>r&&(r=a,n=i.x<i.next.x?i:i.next,a===o))return n}i=i.next}while(i!==t);if(!n)return null;var l,c=n,u=n.x,d=n.y,f=1/0;i=n;do{o>=i.x&&i.x>=u&&o!==i.x&&p(s<d?o:r,s,u,d,s<d?r:o,s,i.x,i.y)&&(l=Math.abs(s-i.y)/(o-i.x),_(i,e)&&(l<f||l===f&&(i.x>n.x||i.x===n.x&&g(n,i)))&&(n=i,f=l)),i=i.next}while(i!==c);return n}(e,t);if(!n)return t;var o=C(n,e);return i(o,o.next),i(n,n.next)}function g(e,t){return x(e.prev,e,t.prev)<0&&x(t.next,e,e.next)<0}function d(e,t,n,i,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function f(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function p(e,t,n,i,o,s,r,a){return(o-r)*(t-a)>=(e-r)*(s-a)&&(e-r)*(i-a)>=(n-r)*(t-a)&&(n-r)*(s-a)>=(o-r)*(i-a)}function h(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&v(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(_(e,t)&&_(t,e)&&function(e,t){var n=e,i=!1,o=(e.x+t.x)/2,s=(e.y+t.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&o<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==e);return i}(e,t)&&(x(e.prev,e,t.prev)||x(e,t.prev,t))||y(e,t)&&x(e.prev,e,e.next)>0&&x(t.prev,t,t.next)>0)}function x(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function y(e,t){return e.x===t.x&&e.y===t.y}function v(e,t,n,i){var o=P(x(e,t,n)),s=P(x(e,t,i)),r=P(x(n,i,e)),a=P(x(n,i,t));return o!==s&&r!==a||(!(0!==o||!m(e,n,t))||(!(0!==s||!m(e,i,t))||(!(0!==r||!m(n,e,i))||!(0!==a||!m(n,t,i)))))}function m(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function P(e){return e>0?1:e<0?-1:0}function _(e,t){return x(e.prev,e,e.next)<0?x(e,t,e.next)>=0&&x(e,e.prev,t)>=0:x(e,t,e.prev)<0||x(e,e.next,t)<0}function C(e,t){var n=new b(e.i,e.x,e.y),i=new b(t.i,t.x,t.y),o=e.next,s=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function L(e,t,n,i){var o=new b(e,t,n);return i?(o.next=i.next,o.prev=i,i.next.prev=o,i.next=o):(o.prev=o,o.next=o),o}function S(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function b(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function w(e,t,n,i){for(var o=0,s=t,r=n-i;s<n;s+=i)o+=(e[r]-e[s])*(e[s+1]+e[r+1]),r=s;return o}e.exports=t,e.exports.default=t,t.deviation=function(e,t,n,i){var o=t&&t.length,s=o?t[0]*n:e.length,r=Math.abs(w(e,0,s,n));if(o)for(var a=0,l=t.length;a<l;a++){var c=t[a]*n,u=a<l-1?t[a+1]*n:e.length;r-=Math.abs(w(e,c,u,n))}var g=0;for(a=0;a<i.length;a+=3){var d=i[a]*n,f=i[a+1]*n,p=i[a+2]*n;g+=Math.abs((e[d]-e[p])*(e[f+1]-e[d+1])-(e[d]-e[f])*(e[p+1]-e[d+1]))}return 0===r&&0===g?0:Math.abs((g-r)/r)},t.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},i=0,o=0;o<e.length;o++){for(var s=0;s<e[o].length;s++)for(var r=0;r<t;r++)n.vertices.push(e[o][s][r]);o>0&&(i+=e[o-1].length,n.holes.push(i))}return n}},65757:(e,t,n)=>{n.d(t,{Z:()=>a});var i=n(69012),o=n(24946),s=n(28807),r=n(60909);class a{constructor(e){this.indexStarts=[0],this.vertexStarts=[0],this.vertexCount=0,this.instanceCount=0;const{attributes:t={}}=e;this.typedArrayManager=o.Z,this.attributes={},this._attributeDefs=t,this.opts=e,this.updateGeometry(e)}updateGeometry(e){Object.assign(this.opts,e);const{data:t,buffers:n={},getGeometry:i,geometryBuffer:o,positionFormat:r,dataChanged:a,normalize:l=!0}=this.opts;if(this.data=t,this.getGeometry=i,this.positionSize=o&&o.size||("XY"===r?2:3),this.buffers=n,this.normalize=l,o&&((0,s.Z)(t.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),l||(n.vertexPositions=o)),this.geometryBuffer=n.vertexPositions,Array.isArray(a))for(const s of a)this._rebuildGeometry(s);else this._rebuildGeometry()}updatePartialGeometry({startRow:e,endRow:t}){this._rebuildGeometry({startRow:e,endRow:t})}getGeometryFromBuffer(e){const t=e.value||e;return ArrayBuffer.isView(t)?(0,i.jr)(t,{size:this.positionSize,offset:e.offset,stride:e.stride,startIndices:this.data.startIndices}):null}_allocate(e,t){const{attributes:n,buffers:i,_attributeDefs:o,typedArrayManager:s}=this;for(const r in o)if(r in i)s.release(n[r]),n[r]=null;else{const i=o[r];i.copy=t,n[r]=s.allocate(n[r],e,i)}}_forEachGeometry(e,t,n){const{data:o,getGeometry:s}=this,{iterable:r,objectInfo:a}=(0,i.jB)(o,t,n);for(const i of r){a.index++;e(s?s(i,a):null,a.index)}}_rebuildGeometry(e){if(!this.data)return;let{indexStarts:t,vertexStarts:n,instanceCount:i}=this;const{data:o,geometryBuffer:s}=this,{startRow:a=0,endRow:l=1/0}=e||{},c={};if(e||(t=[0],n=[0]),this.normalize||!s)this._forEachGeometry(((e,t)=>{const i=e&&this.normalizeGeometry(e);c[t]=i,n[t+1]=n[t]+(i?this.getGeometrySize(i):0)}),a,l),i=n[n.length-1];else if(n=o.startIndices,i=n[o.length]||0,ArrayBuffer.isView(s))i=i||s.length/this.positionSize;else if(s instanceof r.l){const e=4*this.positionSize;i=i||s.byteLength/e}else if(s.buffer){const e=s.stride||4*this.positionSize;i=i||s.buffer.byteLength/e}else if(s.value){const e=s.value,t=s.stride/e.BYTES_PER_ELEMENT||this.positionSize;i=i||e.length/t}this._allocate(i,Boolean(e)),this.indexStarts=t,this.vertexStarts=n,this.instanceCount=i;const u={};this._forEachGeometry(((e,o)=>{const s=c[o]||e;u.vertexStart=n[o],u.indexStart=t[o];const r=o<n.length-1?n[o+1]:i;u.geometrySize=r-n[o],u.geometryIndex=o,this.updateGeometryAttributes(s,u)}),a,l),this.vertexCount=t[t.length-1]}}},6905:(e,t,n)=>{n.d(t,{Z:()=>ke});var i=n(79185);function o({data:e,getIndex:t,dataRange:n,replace:i}){const{startRow:o=0,endRow:s=1/0}=n,r=e.length;let a=r,l=r;for(let g=0;g<r;g++){const n=t(e[g]);if(a>g&&n>=o&&(a=g),n>=s){l=g;break}}let c=a;const u=l-a!==i.length?e.slice(l):void 0;for(let g=0;g<i.length;g++)e[c++]=i[g];if(u){for(let t=0;t<u.length;t++)e[c++]=u[t];e.length=c}return{startRow:a,endRow:a+i.length}}var s=n(69199),r=n(81014),a=n(76166),l=n(69180),c=n(74791),u=n(47594),g=n(21973);var d=n(57291),f=n(69012);const p=()=>{},h={minFilter:"linear",mipmapFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},x={x:0,y:0,width:0,height:0};function y(e,t,n,i){const o=Math.min(n/t.width,i/t.height),s=Math.floor(t.width*o),r=Math.floor(t.height*o);return 1===o?{data:t,width:s,height:r}:(e.canvas.height=r,e.canvas.width=s,e.clearRect(0,0,s,r),e.drawImage(t,0,0,t.width,t.height,0,0,s,r),{data:e.canvas,width:s,height:r})}function v(e){return e&&(e.id||e.url)}function m(e,t,n){for(let i=0;i<t.length;i++){const{icon:o,xOffset:s}=t[i];e[v(o)]={...o,x:s,y:n}}}class P{constructor(e,{onUpdate:t=p,onError:n=p}){this._loadOptions=null,this._texture=null,this._externalTexture=null,this._mapping={},this._textureParameters=null,this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=4,this._canvasWidth=1024,this._canvasHeight=0,this._canvas=null,this.device=e,this.onUpdate=t,this.onError=n}finalize(){this._texture?.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(e){const t=this._autoPacking?v(e):e;return this._mapping[t]||x}setProps({loadOptions:e,autoPacking:t,iconAtlas:n,iconMapping:i,textureParameters:o}){e&&(this._loadOptions=e),void 0!==t&&(this._autoPacking=t),i&&(this._mapping=i),n&&(this._texture?.delete(),this._texture=null,this._externalTexture=n),o&&(this._textureParameters=o)}get isLoaded(){return 0===this._pendingCount}packIcons(e,t){if(!this._autoPacking||"undefined"==typeof document)return;const n=Object.values(function(e,t,n){if(!e||!t)return null;n=n||{};const i={},{iterable:o,objectInfo:s}=(0,f.jB)(e);for(const r of o){s.index++;const e=t(r,s),o=v(e);if(!e)throw new Error("Icon is missing.");if(!e.url)throw new Error("Icon url is missing.");i[o]||n[o]&&e.url===n[o].url||(i[o]={...e,source:r,sourceIndex:s.index})}return i}(e,t,this._mapping)||{});if(n.length>0){const{mapping:e,xOffset:t,yOffset:i,rowHeight:o,canvasHeight:s}=function({icons:e,buffer:t,mapping:n={},xOffset:i=0,yOffset:o=0,rowHeight:s=0,canvasWidth:r}){let a=[];for(let c=0;c<e.length;c++){const l=e[c];if(!n[v(l)]){const{height:e,width:c}=l;i+c+t>r&&(m(n,a,o),i=0,o=s+o+t,s=0,a=[]),a.push({icon:l,xOffset:i}),i=i+c+t,s=Math.max(s,e)}}return a.length>0&&m(n,a,o),{mapping:n,rowHeight:s,xOffset:i,yOffset:o,canvasWidth:r,canvasHeight:(l=s+o+t,Math.pow(2,Math.ceil(Math.log2(l))))};var l}({icons:n,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=e,this._xOffset=t,this._yOffset=i,this._canvasHeight=s,this._texture||(this._texture=this.device.createTexture({format:"rgba8unorm",width:this._canvasWidth,height:this._canvasHeight,sampler:this._textureParameters||h})),this._texture.height!==this._canvasHeight&&(this._texture=function(e,t,n,i){const{width:o,height:s,device:r}=e,a=r.createTexture({format:"rgba8unorm",width:t,height:n,sampler:i}),l=r.createCommandEncoder();return l.copyTextureToTexture({source:e,destination:a,width:o,height:s}),l.finish(),e.destroy(),a}(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||h)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(n)}}_loadIcons(e){const t=this._canvas.getContext("2d",{willReadFrequently:!0});for(const n of e)this._pendingCount++,(0,d.z)(n.url,this._loadOptions).then((e=>{const i=v(n),o=this._mapping[i],{x:s,y:r,width:a,height:l}=o,{data:c,width:u,height:g}=y(t,e,a,l);this._texture.setSubImageData({data:c,x:s+(a-u)/2,y:r+(l-g)/2,width:u,height:g}),o.width=u,o.height=g,this._texture.generateMipmap(),this.onUpdate()})).catch((e=>{this.onError({url:n.url,source:n.source,sourceIndex:n.sourceIndex,loadOptions:this._loadOptions,error:e})})).finally((()=>{this._pendingCount--}))}}const _=[0,0,0,255],C={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:e=>e.position},getIcon:{type:"accessor",value:e=>e.icon},getColor:{type:"accessor",value:_},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0,value:null}};class L extends s.Z{static{this.defaultProps=C}static{this.layerName="IconLayer"}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME icon-layer-vertex-shader\nin vec2 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceSizes;\nin float instanceAngles;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec4 instanceIconFrames;\nin float instanceColorModes;\nin vec2 instanceOffsets;\nin vec2 instancePixelOffset;\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\nout float vColorMode;\nout vec4 vColor;\nout vec2 vTextureCoords;\nout vec2 uv;\nvec2 rotate_by_angle(vec2 vertex, float angle) {\nfloat angle_radian = angle * PI / 180.0;\nfloat cos_angle = cos(angle_radian);\nfloat sin_angle = sin(angle_radian);\nmat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\nreturn rotationMatrix * vertex;\n}\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.uv = positions;\ngeometry.pickingColor = instancePickingColors;\nuv = positions;\nvec2 iconSize = instanceIconFrames.zw;\nfloat sizePixels = clamp(\nproject_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\nsizeMinPixels, sizeMaxPixels\n);\nfloat instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\nvec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\npixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\npixelOffset += instancePixelOffset;\npixelOffset.y *= -1.0;\nif (billboard)  {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = vec3(pixelOffset, 0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\nDECKGL_FILTER_SIZE(offset_common, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvTextureCoords = mix(\ninstanceIconFrames.xy,\ninstanceIconFrames.xy + iconSize,\n(positions.xy + 1.0) / 2.0\n) / iconsTextureDim;\nvColor = instanceColors;\nDECKGL_FILTER_COLOR(vColor, geometry);\nvColorMode = instanceColorModes;\n}\n",fs:"#version 300 es\n#define SHADER_NAME icon-layer-fragment-shader\nprecision highp float;\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\nin float vColorMode;\nin vec4 vColor;\nin vec2 vTextureCoords;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nvec4 texColor = texture(iconsTexture, vTextureCoords);\nvec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\nfloat a = texColor.a * opacity * vColor.a;\nif (a < alphaCutoff) {\ndiscard;\n}\nfragColor = vec4(color, a);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[r.Z,a.Z]})}initializeState(){this.state={iconManager:new P(this.context.device,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:"uint8",accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:_},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(e){super.updateState(e);const{props:t,oldProps:n,changeFlags:i}=e,o=this.getAttributeManager(),{iconAtlas:s,iconMapping:r,data:a,getIcon:l,textureParameters:c}=t,{iconManager:u}=this.state;if("string"==typeof s)return;const g=s||this.internalState.isAsyncPropLoading("iconAtlas");u.setProps({loadOptions:t.loadOptions,autoPacking:!g,iconAtlas:s,iconMapping:g?r:null,textureParameters:c}),g?n.iconMapping!==t.iconMapping&&o.invalidate("getIcon"):(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getIcon))&&u.packIcons(a,l),i.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),o.invalidateAll())}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(e){super.finalizeState(e),this.state.iconManager.finalize()}draw({uniforms:e}){const{sizeScale:t,sizeMinPixels:n,sizeMaxPixels:i,sizeUnits:o,billboard:s,alphaCutoff:r}=this.props,{iconManager:a}=this.state,c=a.getTexture();if(c){const a=this.state.model;a.setBindings({iconsTexture:c}),a.setUniforms(e),a.setUniforms({iconsTextureDim:[c.width,c.height],sizeUnits:l.iI[o],sizeScale:t,sizeMinPixels:n,sizeMaxPixels:i,billboard:s,alphaCutoff:r}),a.draw(this.context.renderPass)}}_getModel(){return new u.H(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new g.Z({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array([-1,-1,1,-1,-1,1,1,1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(e){const t=this.getCurrentLayer()?.props.onIconError;t?t(e):c.Z.error(e.error.message)()}getInstanceOffset(e){const{width:t,height:n,anchorX:i=t/2,anchorY:o=n/2}=this.state.iconManager.getIconMapping(e);return[t/2-i,n/2-o]}getInstanceColorMode(e){return this.state.iconManager.getIconMapping(e).mask?1:0}getInstanceIconFrame(e){const{x:t,y:n,width:i,height:o}=this.state.iconManager.getIconMapping(e);return[t,n,i,o]}}const S=[0,0,0,255],b={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:S},getLineColor:{type:"accessor",value:S},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class w extends s.Z{static{this.defaultProps=b}static{this.layerName="ScatterplotLayer"}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME scatterplot-layer-vertex-shader\nin vec3 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nouterRadiusPixels = clamp(\nproject_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\nradiusMinPixels, radiusMaxPixels\n);\nfloat lineWidthPixels = clamp(\nproject_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\nlineWidthMinPixels, lineWidthMaxPixels\n);\nouterRadiusPixels += stroked * lineWidthPixels / 2.0;\nfloat edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\nunitPosition = edgePadding * positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\ninnerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\nif (billboard) {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = edgePadding * positions * outerRadiusPixels;\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME scatterplot-layer-fragment-shader\nprecision highp float;\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin vec2 unitPosition;\nin float innerUnitRadius;\nin float outerRadiusPixels;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition;\nfloat distToCenter = length(unitPosition) * outerRadiusPixels;\nfloat inCircle = antialiasing ?\nsmoothedge(distToCenter, outerRadiusPixels) :\nstep(distToCenter, outerRadiusPixels);\nif (inCircle == 0.0) {\ndiscard;\n}\nif (stroked > 0.5) {\nfloat isLine = antialiasing ?\nsmoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\nstep(innerUnitRadius * outerRadiusPixels, distToCenter);\nif (filled) {\nfragColor = mix(vFillColor, vLineColor, isLine);\n} else {\nif (isLine == 0.0) {\ndiscard;\n}\nfragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n}\n} else if (!filled) {\ndiscard;\n} else {\nfragColor = vFillColor;\n}\nfragColor.a *= inCircle;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[r.Z,a.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e),e.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){const{radiusUnits:t,radiusScale:n,radiusMinPixels:i,radiusMaxPixels:o,stroked:s,filled:r,billboard:a,antialiasing:c,lineWidthUnits:u,lineWidthScale:g,lineWidthMinPixels:d,lineWidthMaxPixels:f}=this.props,p=this.state.model;p.setUniforms(e),p.setUniforms({stroked:s?1:0,filled:r,billboard:a,antialiasing:c,radiusUnits:l.iI[t],radiusScale:n,radiusMinPixels:i,radiusMaxPixels:o,lineWidthUnits:l.iI[u],lineWidthScale:g,lineWidthMinPixels:d,lineWidthMaxPixels:f}),p.draw(this.context.renderPass)}_getModel(){return new u.H(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new g.Z({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,-1,1,0,1,1,0])}}}),isInstanced:!0})}}const z=.75,A=[],I={getIconOffsets:{type:"accessor",value:e=>e.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}};class M extends L{static{this.defaultProps=I}static{this.layerName="MultiIconLayer"}getShaders(){return{...super.getShaders(),fs:"#version 300 es\n#define SHADER_NAME multi-icon-layer-fragment-shader\nprecision highp float;\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\nin vec4 vColor;\nin vec2 vTextureCoords;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nif (!bool(picking.isActive)) {\nfloat alpha = texture(iconsTexture, vTextureCoords).a;\nvec4 color = vColor;\nif (sdf) {\nfloat distance = alpha;\nalpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\nif (outlineBuffer > 0.0) {\nfloat inFill = alpha;\nfloat inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\ncolor = mix(outlineColor, vColor, inFill);\nalpha = inBorder;\n}\n}\nfloat a = alpha * color.a;\nif (a < alphaCutoff) {\ndiscard;\n}\nfragColor = vec4(color.rgb, a * opacity);\n}\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n"}}initializeState(){super.initializeState();this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:"uint8",size:3,accessor:(e,{index:t,target:n})=>this.encodePickingColor(t,n)}})}updateState(e){super.updateState(e);const{props:t,oldProps:n}=e;let{outlineColor:i}=t;i!==n.outlineColor&&(i=i.map((e=>e/255)),i[3]=Number.isFinite(i[3])?i[3]:1,this.setState({outlineColor:i})),!t.sdf&&t.outlineWidth&&c.Z.warn(`${this.id}: fontSettings.sdf is required to render outline`)()}draw(e){const{sdf:t,smoothing:n,outlineWidth:i}=this.props,{outlineColor:o}=this.state,s=i?Math.max(n,z*(1-i)):-1;if(e.uniforms={...e.uniforms,sdfBuffer:z,outlineBuffer:s,gamma:n,sdf:Boolean(t),outlineColor:o},super.draw(e),t&&i){const{iconManager:e}=this.state,t=e.getTexture(),n=this.state.model;t&&(n.setUniforms({outlineBuffer:z}),n.draw(this.context.renderPass))}}getInstanceOffset(e){return e?Array.from(e).flatMap((e=>super.getInstanceOffset(e))):A}getInstanceColorMode(e){return 1}getInstanceIconFrame(e){return e?Array.from(e).flatMap((e=>super.getInstanceIconFrame(e))):A}}const T=1e20;class O{constructor({fontSize:e=24,buffer:t=3,radius:n=8,cutoff:i=.25,fontFamily:o="sans-serif",fontWeight:s="normal",fontStyle:r="normal"}={}){this.buffer=t,this.cutoff=i,this.radius=n;const a=this.size=e+4*t,l=this._createCanvas(a),c=this.ctx=l.getContext("2d",{willReadFrequently:!0});c.font=`${r} ${s} ${e}px ${o}`,c.textBaseline="alphabetic",c.textAlign="left",c.fillStyle="black",this.gridOuter=new Float64Array(a*a),this.gridInner=new Float64Array(a*a),this.f=new Float64Array(a),this.z=new Float64Array(a+1),this.v=new Uint16Array(a)}_createCanvas(e){const t=document.createElement("canvas");return t.width=t.height=e,t}draw(e){const{width:t,actualBoundingBoxAscent:n,actualBoundingBoxDescent:i,actualBoundingBoxLeft:o,actualBoundingBoxRight:s}=this.ctx.measureText(e),r=Math.ceil(n),a=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(s-o))),l=Math.min(this.size-this.buffer,r+Math.ceil(i)),c=a+2*this.buffer,u=l+2*this.buffer,g=Math.max(c*u,0),d=new Uint8ClampedArray(g),f={data:d,width:c,height:u,glyphWidth:a,glyphHeight:l,glyphTop:r,glyphLeft:0,glyphAdvance:t};if(0===a||0===l)return f;const{ctx:p,buffer:h,gridInner:x,gridOuter:y}=this;p.clearRect(h,h,a,l),p.fillText(e,h,h+r);const v=p.getImageData(h,h,a,l);y.fill(T,0,g),x.fill(0,0,g);for(let m=0;m<l;m++)for(let e=0;e<a;e++){const t=v.data[4*(m*a+e)+3]/255;if(0===t)continue;const n=(m+h)*c+e+h;if(1===t)y[n]=0,x[n]=T;else{const e=.5-t;y[n]=e>0?e*e:0,x[n]=e<0?e*e:0}}E(y,0,0,c,u,c,this.f,this.v,this.z),E(x,h,h,a,l,c,this.f,this.v,this.z);for(let m=0;m<g;m++){const e=Math.sqrt(y[m])-Math.sqrt(x[m]);d[m]=Math.round(255-255*(e/this.radius+this.cutoff))}return f}}function E(e,t,n,i,o,s,r,a,l){for(let c=t;c<t+i;c++)F(e,n*s+c,s,o,r,a,l);for(let c=n;c<n+o;c++)F(e,c*s+t,1,i,r,a,l)}function F(e,t,n,i,o,s,r){s[0]=0,r[0]=-T,r[1]=T,o[0]=e[t];for(let a=1,l=0,c=0;a<i;a++){o[a]=e[t+a*n];const i=a*a;do{const e=s[l];c=(o[a]-o[e]+i-e*e)/(a-e)/2}while(c<=r[l]&&--l>-1);l++,s[l]=a,r[l]=c,r[l+1]=T}for(let a=0,l=0;a<i;a++){for(;r[l+1]<a;)l++;const i=s[l],c=a-i;e[t+a*n]=o[i]+c*c}}const R=32,k=[];function W(e,t,n,i){let o=0;for(let s=t;s<n;s++){const t=e[s];o+=i[t]?.layoutWidth||0}return o}function B(e,t,n,i,o,s){let r=t,a=0;for(let l=t;l<n;l++){const t=W(e,l,l+1,o);a+t>i&&(r<l&&s.push(l),r=l,a=0),a+=t}return a}function G(e,t,n,i,o=0,s){void 0===s&&(s=e.length);const r=[];return"break-all"===t?B(e,o,s,n,i,r):function(e,t,n,i,o,s){let r=t,a=t,l=t,c=0;for(let u=t;u<n;u++)if(" "===e[u]?l=u+1:" "!==e[u+1]&&u+1!==n||(l=u+1),l>a){let t=W(e,a,l,o);c+t>i&&(r<a&&(s.push(a),r=a,c=0),t>i&&(t=B(e,a,l,i,o,s),r=s[s.length-1])),a=l,c+=t}}(e,o,s,n,i,r),r}function Z(e,t,n,i,o,s){let r=0,a=0;for(let l=t;l<n;l++){const t=e[l],n=i[t];n?(a||(a=n.layoutHeight),o[l]=r+n.layoutWidth/2,r+=n.layoutWidth):(c.Z.warn(`Missing character: ${t} (${t.codePointAt(0)})`)(),o[l]=r,r+=R)}s[0]=r,s[1]=a}class D{constructor(e=5){this._cache={},this._order=[],this.limit=e}get(e){const t=this._cache[e];return t&&(this._deleteOrder(e),this._appendOrder(e)),t}set(e,t){this._cache[e]?(this.delete(e),this._cache[e]=t,this._appendOrder(e)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[e]=t,this._appendOrder(e))}delete(e){this._cache[e]&&(delete this._cache[e],this._deleteOrder(e))}_deleteOrder(e){const t=this._order.indexOf(e);t>=0&&this._order.splice(t,1)}_appendOrder(e){this._order.push(e)}}const N={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:function(){const e=[];for(let t=32;t<128;t++)e.push(String.fromCharCode(t));return e}(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1};let U=new D(3);function j(e,t){for(let n=0;n<e.length;n++)t.data[4*n+3]=e[n]}function H(e,t,n,i){e.font=`${i} ${n}px ${t}`,e.fillStyle="#000",e.textBaseline="alphabetic",e.textAlign="left"}class V{constructor(){this.props={...N}}get atlas(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){const{fontSize:e,buffer:t}=this.props;return(1.2*e+2*t)/e}setProps(e={}){Object.assign(this.props,e),this._key=this._getKey();const t=function(e,t){let n;n="string"==typeof t?new Set(Array.from(t)):new Set(t);const i=U.get(e);if(!i)return n;for(const o in i.mapping)n.has(o)&&n.delete(o);return n}(this._key,this.props.characterSet),n=U.get(this._key);if(n&&0===t.size)return void(this._atlas!==n&&(this._atlas=n));const i=this._generateFontAtlas(t,n);this._atlas=i,U.set(this._key,i)}_generateFontAtlas(e,t){const{fontFamily:n,fontWeight:i,fontSize:o,buffer:s,sdf:r,radius:a,cutoff:l}=this.props;let c=t&&t.data;c||(c=document.createElement("canvas"),c.width=1024);const u=c.getContext("2d",{willReadFrequently:!0});H(u,n,o,i);const{mapping:g,canvasHeight:d,xOffset:f,yOffset:p}=function({characterSet:e,getFontWidth:t,fontHeight:n,buffer:i,maxCanvasWidth:o,mapping:s={},xOffset:r=0,yOffset:a=0}){let l=0,c=r;const u=n+2*i;for(const d of e)if(!s[d]){const e=t(d);c+e+2*i>o&&(c=0,l++),s[d]={x:c+i,y:a+l*u+i,width:e,height:u,layoutWidth:e,layoutHeight:n},c+=e+2*i}return{mapping:s,xOffset:c,yOffset:a+l*u,canvasHeight:(g=a+(l+1)*u,Math.pow(2,Math.ceil(Math.log2(g))))};var g}({getFontWidth:e=>u.measureText(e).width,fontHeight:1.2*o,buffer:s,characterSet:e,maxCanvasWidth:1024,...t&&{mapping:t.mapping,xOffset:t.xOffset,yOffset:t.yOffset}});if(c.height!==d){const e=u.getImageData(0,0,c.width,c.height);c.height=d,u.putImageData(e,0,0)}if(H(u,n,o,i),r){const t=new O({fontSize:o,buffer:s,radius:a,cutoff:l,fontFamily:n,fontWeight:`${i}`});for(const n of e){const{data:e,width:i,height:s,glyphTop:r}=t.draw(n);g[n].width=i,g[n].layoutOffsetY=.9*o-r;const a=u.createImageData(i,s);j(e,a),u.putImageData(a,g[n].x,g[n].y)}}else for(const h of e)u.fillText(h,g[h].x,g[h].y+s+.9*o);return{xOffset:f,yOffset:p,mapping:g,data:c,width:c.width,height:c.height}}_getKey(){const{fontFamily:e,fontWeight:t,fontSize:n,buffer:i,sdf:o,radius:s,cutoff:r}=this.props;return o?`${e} ${t} ${n} ${i} ${s} ${r}`:`${e} ${t} ${n} ${i}`}}const $={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:e=>e.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class K extends s.Z{static{this.defaultProps=$}static{this.layerName="TextBackgroundLayer"}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME text-background-layer-vertex-shader\nin vec2 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceRects;\nin float instanceSizes;\nin float instanceAngles;\nin vec2 instancePixelOffsets;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout float vLineWidth;\nout vec2 uv;\nout vec2 dimensions;\nvec2 rotate_by_angle(vec2 vertex, float angle) {\nfloat angle_radian = radians(angle);\nfloat cos_angle = cos(angle_radian);\nfloat sin_angle = sin(angle_radian);\nmat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\nreturn rotationMatrix * vertex;\n}\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.uv = positions;\ngeometry.pickingColor = instancePickingColors;\nuv = positions;\nvLineWidth = instanceLineWidths;\nfloat sizePixels = clamp(\nproject_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\nsizeMinPixels, sizeMaxPixels\n);\ndimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\nvec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\npixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\npixelOffset += instancePixelOffsets;\npixelOffset.y *= -1.0;\nif (billboard)  {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = vec3(pixelOffset, 0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\nDECKGL_FILTER_SIZE(offset_common, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME text-background-layer-fragment-shader\nprecision highp float;\nuniform bool stroked;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin float vLineWidth;\nin vec2 uv;\nin vec2 dimensions;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nvec2 pixelPosition = uv * dimensions;\nif (stroked) {\nfloat distToEdge = min(\nmin(pixelPosition.x, dimensions.x - pixelPosition.x),\nmin(pixelPosition.y, dimensions.y - pixelPosition.y)\n);\nfloat isBorder = smoothedge(distToEdge, vLineWidth);\nfragColor = mix(vFillColor, vLineColor, isBorder);\n} else {\nfragColor = vFillColor;\n}\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[r.Z,a.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e);const{changeFlags:t}=e;t.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){const{billboard:t,sizeScale:n,sizeUnits:i,sizeMinPixels:o,sizeMaxPixels:s,getLineWidth:r}=this.props;let{padding:a}=this.props;a.length<4&&(a=[a[0],a[1],a[0],a[1]]);const c=this.state.model;c.setUniforms(e),c.setUniforms({billboard:t,stroked:Boolean(r),padding:a,sizeUnits:l.iI[i],sizeScale:n,sizeMinPixels:o,sizeMaxPixels:s}),c.draw(this.context.renderPass)}_getModel(){return new u.H(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new g.Z({topology:"triangle-fan-webgl",vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}const J={start:1,middle:0,end:-1},X={top:1,center:0,bottom:-1},Y=[0,0,0,255],q={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:Y},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:N.characterSet},fontFamily:N.fontFamily,fontWeight:N.fontWeight,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:Y},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:e=>e.text},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:Y},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class Q extends i.Z{constructor(){super(...arguments),this.getBoundingRect=(e,t)=>{let{size:[n,i]}=this.transformParagraph(e,t);const{fontSize:o}=this.state.fontAtlasManager.props;n/=o,i/=o;const{getTextAnchor:s,getAlignmentBaseline:r}=this.props;return[(J["function"==typeof s?s(e,t):s]-1)*n/2,(X["function"==typeof r?r(e,t):r]-1)*i/2,n,i]},this.getIconOffsets=(e,t)=>{const{getTextAnchor:n,getAlignmentBaseline:i}=this.props,{x:o,y:s,rowWidth:r,size:[a,l]}=this.transformParagraph(e,t),c=J["function"==typeof n?n(e,t):n],u=X["function"==typeof i?i(e,t):i],g=o.length,d=new Array(2*g);let f=0;for(let p=0;p<g;p++){const e=(1-c)*(a-r[p])/2;d[f++]=(c-1)*a/2+e+o[p],d[f++]=(u-1)*l/2+s[p]}return d}}static{this.defaultProps=q}static{this.layerName="TextLayer"}initializeState(){this.state={styleVersion:0,fontAtlasManager:new V},this.props.maxWidth>0&&c.Z.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(e){const{props:t,oldProps:n,changeFlags:i}=e;(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getText))&&this._updateText();(this._updateFontAtlas()||t.lineHeight!==n.lineHeight||t.wordBreak!==n.wordBreak||t.maxWidth!==n.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:e}){return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(){const{fontSettings:e,fontFamily:t,fontWeight:n}=this.props,{fontAtlasManager:i,characterSet:o}=this.state,s={...e,characterSet:o,fontFamily:t,fontWeight:n};if(!i.mapping)return i.setProps(s),!0;for(const r in s)if(s[r]!==i.props[r])return i.setProps(s),!0;return!1}_updateText(){const{data:e,characterSet:t}=this.props,n=e.attributes?.getText;let i,{getText:o}=this.props,s=e.startIndices;const r="auto"===t&&new Set;if(n&&s){const{texts:t,characterCount:a}=function({value:e,length:t,stride:n,offset:i,startIndices:o,characterSet:s}){const r=e.BYTES_PER_ELEMENT,a=n?n/r:1,l=i?i/r:0,c=o[t]||Math.ceil((e.length-l)/a),u=s&&new Set,g=new Array(t);let d=e;if(a>1||l>0){d=new(0,e.constructor)(c);for(let t=0;t<c;t++)d[t]=e[t*a+l]}for(let f=0;f<t;f++){const e=o[f],t=o[f+1]||c,n=d.subarray(e,t);g[f]=String.fromCodePoint.apply(null,n),u&&n.forEach(u.add,u)}if(u)for(const f of u)s.add(String.fromCodePoint(f));return{texts:g,characterCount:c}}({...ArrayBuffer.isView(n)?{value:n}:n,length:e.length,startIndices:s,characterSet:r});i=a,o=(e,{index:n})=>t[n]}else{const{iterable:t,objectInfo:n}=(0,f.jB)(e);s=[0],i=0;for(const e of t){n.index++;const t=Array.from(o(e,n)||"");r&&t.forEach(r.add,r),i+=t.length,s.push(i)}}this.setState({getText:o,startIndices:s,numInstances:i,characterSet:r||t})}transformParagraph(e,t){const{fontAtlasManager:n}=this.state,i=n.mapping,o=this.state.getText,{wordBreak:s,lineHeight:r,maxWidth:a}=this.props;return function(e,t,n,i,o){const s=Array.from(e),r=s.length,a=new Array(r),l=new Array(r),c=new Array(r),u=("break-word"===n||"break-all"===n)&&isFinite(i)&&i>0,g=[0,0],d=[0,0];let f=0,p=0,h=0;for(let x=0;x<=r;x++){const e=s[x];if("\n"!==e&&x!==r||(h=x),h>p){const e=u?G(s,n,i,o,p,h):k;for(let n=0;n<=e.length;n++){const i=0===n?p:e[n-1],r=n<e.length?e[n]:h;Z(s,i,r,o,a,d);for(let e=i;e<r;e++){const t=s[e],n=o[t]?.layoutOffsetY||0;l[e]=f+d[1]/2+n,c[e]=d[0]}f+=d[1]*t,g[0]=Math.max(g[0],d[0])}p=h}"\n"===e&&(a[p]=0,l[p]=0,c[p]=0,p++)}return g[1]=f,{x:a,y:l,rowWidth:c,size:g}}(o(e,t)||"",r,s,a*n.props.fontSize,i)}renderLayers(){const{startIndices:e,numInstances:t,getText:n,fontAtlasManager:{scale:i,atlas:o,mapping:s},styleVersion:r}=this.state,{data:a,_dataDiff:l,getPosition:c,getColor:u,getSize:g,getAngle:d,getPixelOffset:f,getBackgroundColor:p,getBorderColor:h,getBorderWidth:x,backgroundPadding:y,background:v,billboard:m,fontSettings:P,outlineWidth:_,outlineColor:C,sizeScale:L,sizeUnits:S,sizeMinPixels:b,sizeMaxPixels:w,transitions:z,updateTriggers:A}=this.props,I=this.getSubLayerClass("characters",M),T=this.getSubLayerClass("background",K);return[v&&new T({getFillColor:p,getLineColor:h,getLineWidth:x,padding:y,getPosition:c,getSize:g,getAngle:d,getPixelOffset:f,billboard:m,sizeScale:L,sizeUnits:S,sizeMinPixels:b,sizeMaxPixels:w,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getSize:z.getSize,getFillColor:z.getBackgroundColor,getLineColor:z.getBorderColor,getLineWidth:z.getBorderWidth,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:A.getPosition,getAngle:A.getAngle,getSize:A.getSize,getFillColor:A.getBackgroundColor,getLineColor:A.getBorderColor,getLineWidth:A.getBorderWidth,getPixelOffset:A.getPixelOffset,getBoundingRect:{getText:A.getText,getTextAnchor:A.getTextAnchor,getAlignmentBaseline:A.getAlignmentBaseline,styleVersion:r}}}),{data:a.attributes&&a.attributes.background?{length:a.length,attributes:a.attributes.background}:a,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new I({sdf:P.sdf,smoothing:Number.isFinite(P.smoothing)?P.smoothing:N.smoothing,outlineWidth:_/(P.radius||N.radius),outlineColor:C,iconAtlas:o,iconMapping:s,getPosition:c,getColor:u,getSize:g,getAngle:d,getPixelOffset:f,billboard:m,sizeScale:L*i,sizeUnits:S,sizeMinPixels:b*i,sizeMaxPixels:w*i,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getColor:z.getColor,getSize:z.getSize,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:A.getText,getPosition:A.getPosition,getAngle:A.getAngle,getColor:A.getColor,getSize:A.getSize,getPixelOffset:A.getPixelOffset,getIconOffsets:{getTextAnchor:A.getTextAnchor,getAlignmentBaseline:A.getAlignmentBaseline,styleVersion:r}}}),{data:a,_dataDiff:l,startIndices:e,numInstances:t,getIconOffsets:this.getIconOffsets,getIcon:n})]}static set fontAtlasCacheLimit(e){!function(e){c.Z.assert(Number.isFinite(e)&&e>=3,"Invalid cache limit"),U=new D(e)}(e)}}var ee=n(63885),te=n(62602),ne=n(9187),ie=n(50533);const oe=ie.wG.CLOCKWISE,se=ie.wG.COUNTER_CLOCKWISE,re={isClosed:!0};function ae(e){return"positions"in e?e.positions:e}function le(e){return"holeIndices"in e?e.holeIndices:null}function ce(e,t,n,i,o){let s=t;const r=n.length;for(let a=0;a<r;a++)for(let t=0;t<i;t++)e[s++]=n[a][t]||0;if(!function(e){const t=e[0],n=e[e.length-1];return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]}(n))for(let a=0;a<i;a++)e[s++]=n[0][a]||0;return re.start=t,re.end=s,re.size=i,(0,ie.Ny)(e,o,re),s}function ue(e,t,n,i,o=0,s,r){const a=(s=s||n.length)-o;if(a<=0)return t;let l=t;for(let c=0;c<a;c++)e[l++]=n[o+c];if(!function(e,t,n,i){for(let o=0;o<t;o++)if(e[n+o]!==e[i-t+o])return!1;return!0}(n,i,o,s))for(let c=0;c<i;c++)e[l++]=n[o+c];return re.start=t,re.end=l,re.size=i,(0,ie.Ny)(e,r,re),l}function ge(e,t){!function(e){if(e=e&&e.positions||e,!Array.isArray(e)&&!ArrayBuffer.isView(e))throw new Error("invalid polygon")}(e);const n=[],i=[];if("positions"in e){const{positions:o,holeIndices:s}=e;if(s){let e=0;for(let r=0;r<=s.length;r++)e=ue(n,e,o,t,s[r-1],s[r],0===r?oe:se),i.push(e);return i.pop(),{positions:n,holeIndices:i}}e=o}if(!function(e){return Array.isArray(e[0])}(e))return ue(n,0,e,t,0,n.length,oe),n;if(!function(e){return e.length>=1&&e[0].length>=2&&Number.isFinite(e[0][0])}(e)){let o=0;for(const[s,r]of e.entries())o=ce(n,o,r,t,0===s?oe:se),i.push(o);return i.pop(),{positions:n,holeIndices:i}}return ce(n,0,e,t,oe),n}function de(e,t,n){const i=e.length/3;let o=0;for(let s=0;s<i;s++){const r=(s+1)%i;o+=e[3*s+t]*e[3*r+n],o-=e[3*r+t]*e[3*s+n]}return Math.abs(o/2)}function fe(e,t,n,i){const o=e.length/3;for(let s=0;s<o;s++){const o=3*s,r=e[o+0],a=e[o+1],l=e[o+2];e[o+t]=r,e[o+n]=a,e[o+i]=l}}var pe=n(65757);class he extends pe.Z{constructor(e){const{fp64:t,IndexType:n=Uint32Array}=e;super({...e,attributes:{positions:{size:3,type:t?Float64Array:Float32Array},vertexValid:{type:Uint16Array,size:1},indices:{type:n,size:1}}})}get(e){const{attributes:t}=this;return"indices"===e?t.indices&&t.indices.subarray(0,this.vertexCount):t[e]}updateGeometry(e){super.updateGeometry(e);const t=this.buffers.indices;if(t)this.vertexCount=(t.value||t).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(e){if(this.normalize){const t=ge(e,this.positionSize);return this.opts.resolution?(0,ie.WZ)(ae(t),le(t),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?(0,ie.GU)(ae(t),le(t),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):t}return e}getGeometrySize(e){if(xe(e)){let t=0;for(const n of e)t+=this.getGeometrySize(n);return t}return ae(e).length/this.positionSize}getGeometryFromBuffer(e){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(e):null}updateGeometryAttributes(e,t){if(e&&xe(e))for(const n of e){const e=this.getGeometrySize(n);t.geometrySize=e,this.updateGeometryAttributes(n,t),t.vertexStart+=e,t.indexStart=this.indexStarts[t.geometryIndex+1]}else{const n=e;this._updateIndices(n,t),this._updatePositions(n,t),this._updateVertexValid(n,t)}}_updateIndices(e,{geometryIndex:t,vertexStart:n,indexStart:i}){const{attributes:o,indexStarts:s,typedArrayManager:r}=this;let a=o.indices;if(!a||!e)return;let l=i;const c=function(e,t,n,i){let o=le(e);o&&(o=o.map((e=>e/t)));let s=ae(e);const r=i&&3===t;if(n){const e=s.length;s=s.slice();const i=[];for(let o=0;o<e;o+=t){i[0]=s[o],i[1]=s[o+1],r&&(i[2]=s[o+2]);const e=n(i);s[o]=e[0],s[o+1]=e[1],r&&(s[o+2]=e[2])}}if(r){const e=de(s,0,1),t=de(s,0,2),i=de(s,1,2);if(!e&&!t&&!i)return[];e>t&&e>i||(t>i?(n||(s=s.slice()),fe(s,0,2,1)):(n||(s=s.slice()),fe(s,2,0,1)))}return ne(s,o,t)}(e,this.positionSize,this.opts.preproject,this.opts.full3d);a=r.allocate(a,i+c.length,{copy:!0});for(let u=0;u<c.length;u++)a[l++]=c[u]+n;s[t+1]=i+c.length,o.indices=a}_updatePositions(e,{vertexStart:t,geometrySize:n}){const{attributes:{positions:i},positionSize:o}=this;if(!i||!e)return;const s=ae(e);for(let r=t,a=0;a<n;r++,a++){const e=s[a*o],t=s[a*o+1],n=o>2?s[a*o+2]:0;i[3*r]=e,i[3*r+1]=t,i[3*r+2]=n}}_updateVertexValid(e,{vertexStart:t,geometrySize:n}){const{positionSize:i}=this,o=this.attributes.vertexValid,s=e&&le(e);if(e&&e.edgeTypes?o.set(e.edgeTypes,t):o.fill(1,t,t+n),s)for(let r=0;r<s.length;r++)o[t+s[r]/i-1]=0;o[t+n-1]=0}}function xe(e){return Array.isArray(e)&&e.length>0&&!Number.isFinite(e[0])}const ye="uniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\nout vec4 vColor;\nstruct PolygonProps {\nvec4 fillColors;\nvec4 lineColors;\nvec3 positions;\nvec3 positions64Low;\nvec3 pickingColors;\nvec3 normal;\nfloat elevations;\n};\nvec3 project_offset_normal(vec3 vector) {\nif (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\nproject_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\nreturn normalize(vector * project_uCommonUnitsPerWorldUnit);\n}\nreturn project_normal(vector);\n}\nvoid calculatePosition(PolygonProps props) {\nvec3 pos = props.positions;\nvec3 pos64Low = props.positions64Low;\nvec3 normal = props.normal;\nvec4 colors = isWireframe ? props.lineColors : props.fillColors;\ngeometry.worldPosition = props.positions;\ngeometry.pickingColor = props.pickingColors;\nif (extruded) {\npos.z += props.elevations * elevationScale;\n}\ngl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nif (extruded) {\n#ifdef IS_SIDE_VERTEX\nnormal = project_offset_normal(normal);\n#else\nnormal = project_normal(normal);\n#endif\ngeometry.normal = normal;\nvec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\nvColor = vec4(lightColor, colors.a * opacity);\n} else {\nvColor = vec4(colors.rgb, colors.a * opacity);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",ve=`#version 300 es\n#define SHADER_NAME solid-polygon-layer-vertex-shader\nin vec3 vertexPositions;\nin vec3 vertexPositions64Low;\nin float elevations;\nin vec4 fillColors;\nin vec4 lineColors;\nin vec3 pickingColors;\n${ye}\nvoid main(void) {\nPolygonProps props;\nprops.positions = vertexPositions;\nprops.positions64Low = vertexPositions64Low;\nprops.elevations = elevations;\nprops.fillColors = fillColors;\nprops.lineColors = lineColors;\nprops.pickingColors = pickingColors;\nprops.normal = vec3(0.0, 0.0, 1.0);\ncalculatePosition(props);\n}\n`,me=`#version 300 es\n#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\nin vec2 positions;\nin vec3 instancePositions;\nin vec3 instanceNextPositions;\nin vec3 instancePositions64Low;\nin vec3 instanceNextPositions64Low;\nin float instanceElevations;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nin float instanceVertexValid;\n${ye}\nvoid main(void) {\nif(instanceVertexValid < 0.5){\ngl_Position = vec4(0.);\nreturn;\n}\nPolygonProps props;\nvec3 pos;\nvec3 pos64Low;\nvec3 nextPos;\nvec3 nextPos64Low;\n#if RING_WINDING_ORDER_CW == 1\npos = instancePositions;\npos64Low = instancePositions64Low;\nnextPos = instanceNextPositions;\nnextPos64Low = instanceNextPositions64Low;\n#else\npos = instanceNextPositions;\npos64Low = instanceNextPositions64Low;\nnextPos = instancePositions;\nnextPos64Low = instancePositions64Low;\n#endif\nprops.positions = mix(pos, nextPos, positions.x);\nprops.positions64Low = mix(pos64Low, nextPos64Low, positions.x);\nprops.normal = vec3(\npos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),\nnextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),\n0.0);\nprops.elevations = instanceElevations * positions.y;\nprops.fillColors = instanceFillColors;\nprops.lineColors = instanceLineColors;\nprops.pickingColors = instancePickingColors;\ncalculatePosition(props);\n}\n`,Pe=[0,0,0,255],_e={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:e=>e.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:Pe},getLineColor:{type:"accessor",value:Pe},material:!0},Ce={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class Le extends s.Z{static{this.defaultProps=_e}static{this.layerName="SolidPolygonLayer"}getShaders(e){return super.getShaders({vs:"top"===e?ve:me,fs:"#version 300 es\n#define SHADER_NAME solid-polygon-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[r.Z,te.N,a.Z]})}get wrapLongitude(){return!1}getBounds(){return this.getAttributeManager()?.getBounds(["vertexPositions"])}initializeState(){const{viewport:e}=this.context;let{coordinateSystem:t}=this.props;const{_full3d:n}=this.props;let i;e.isGeospatial&&t===l.COORDINATE_SYSTEM.DEFAULT&&(t=l.COORDINATE_SYSTEM.LNGLAT),t===l.COORDINATE_SYSTEM.LNGLAT&&(i=n?e.projectPosition.bind(e):e.projectFlat.bind(e)),this.setState({numInstances:0,polygonTesselator:new he({preproject:i,fp64:this.use64bitPositions(),IndexType:Uint32Array})});const o=this.getAttributeManager(),s=!0;o.remove(["instancePickingColors"]),o.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:s},vertexPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:Ce,accessor:"getPolygon",update:this.calculatePositions,noAlloc:s,shaderAttributes:{instancePositions:{vertexOffset:0,divisor:1},instanceNextPositions:{vertexOffset:1,divisor:1}}},instanceVertexValid:{size:1,type:"uint16",divisor:1,update:this.calculateVertexValid,noAlloc:s},elevations:{size:1,transition:Ce,accessor:"getElevation",shaderAttributes:{instanceElevations:{divisor:1}}},fillColors:{size:this.props.colorFormat.length,type:"unorm8",transition:Ce,accessor:"getFillColor",defaultValue:Pe,shaderAttributes:{instanceFillColors:{divisor:1}}},lineColors:{size:this.props.colorFormat.length,type:"unorm8",transition:Ce,accessor:"getLineColor",defaultValue:Pe,shaderAttributes:{instanceLineColors:{divisor:1}}},pickingColors:{size:4,type:"uint8",accessor:(e,{index:t,target:n})=>this.encodePickingColor(e&&e.__source?e.__source.index:t,n),shaderAttributes:{instancePickingColors:{divisor:1}}}})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n}=t,i=this.props.data;return i[0]&&i[0].__source&&(t.object=i.find((e=>e.__source.index===n))),t}disablePickingIndex(e){const t=this.props.data;if(t[0]&&t[0].__source)for(let n=0;n<t.length;n++)t[n].__source.index===e&&this._disablePickingIndex(n);else super.disablePickingIndex(e)}draw({uniforms:e}){const{extruded:t,filled:n,wireframe:i,elevationScale:o}=this.props,{topModel:s,sideModel:r,wireframeModel:a,polygonTesselator:l}=this.state,c={...e,extruded:Boolean(t),elevationScale:o};a&&i&&(a.setInstanceCount(l.instanceCount-1),a.setUniforms(c),a.draw(this.context.renderPass)),r&&n&&(r.setInstanceCount(l.instanceCount-1),r.setUniforms(c),r.draw(this.context.renderPass)),s&&n&&(s.setVertexCount(l.vertexCount),s.setUniforms(c),s.draw(this.context.renderPass))}updateState(e){super.updateState(e),this.updateGeometry(e);const{props:t,oldProps:n,changeFlags:i}=e,o=this.getAttributeManager();(i.extensionsChanged||t.filled!==n.filled||t.extruded!==n.extruded)&&(this.state.models?.forEach((e=>e.destroy())),this.setState(this._getModels()),o.invalidateAll())}updateGeometry({props:e,oldProps:t,changeFlags:n}){if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon)){const{polygonTesselator:t}=this.state,i=e.data.attributes||{};t.updateGeometry({data:e.data,normalize:e._normalize,geometryBuffer:i.getPolygon,buffers:i,getGeometry:e.getPolygon,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:n.dataChanged,full3d:e._full3d}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),n.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(){const{id:e,filled:t,extruded:n}=this.props;let i,o,s;const r=this.getAttributeManager().getBufferLayouts();if(t){const t=this.getShaders("top");t.defines.NON_INSTANCED_MODEL=1,i=new u.H(this.context.device,{...t,id:`${e}-top`,topology:"triangle-list",uniforms:{isWireframe:!1},bufferLayout:r,isIndexed:!0,userData:{excludeAttributes:{instanceVertexValid:!0}}})}return n&&(o=new u.H(this.context.device,{...this.getShaders("side"),id:`${e}-side`,bufferLayout:r,uniforms:{isWireframe:!1},geometry:new g.Z({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,1,1,0,1])}}}),isInstanced:1,userData:{excludeAttributes:{indices:!0}}}),s=new u.H(this.context.device,{...this.getShaders("side"),id:`${e}-wireframe`,bufferLayout:r,uniforms:{isWireframe:!0},geometry:new g.Z({topology:"line-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),isInstanced:1,userData:{excludeAttributes:{indices:!0}}})),{models:[o,s,i].filter(Boolean),topModel:i,sideModel:o,wireframeModel:s}}calculateIndices(e){const{polygonTesselator:t}=this.state;e.startIndices=t.indexStarts,e.value=t.get("indices")}calculatePositions(e){const{polygonTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateVertexValid(e){e.value=this.state.polygonTesselator.get("vertexValid")}}const Se={circle:{type:w,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:L,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:Q,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},be={type:ee.Z,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},we={type:Le,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function ze({type:e,props:t}){const n={};for(const i in t)n[i]=e.defaultProps[t[i]];return n}function Ae(e,t){const{transitions:n,updateTriggers:i}=e.props,o={updateTriggers:{},transitions:n&&{getPosition:n.geometry}};for(const s in t){const r=t[s];let a=e.props[s];s.startsWith("get")&&(a=e.getSubLayerAccessor(a),o.updateTriggers[r]=i[s],n&&(o.transitions[r]=n[s])),o[r]=a}return o}function Ie(e,t,n={}){const i={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:o=0,endRow:s=e.length}=n;for(let r=o;r<s;r++){const n=e[r],{geometry:o}=n;if(o)if("GeometryCollection"===o.type){c.Z.assert(Array.isArray(o.geometries),"GeoJSON does not have geometries array");const{geometries:e}=o;for(let o=0;o<e.length;o++){Me(e[o],i,t,n,r)}}else Me(o,i,t,n,r)}return i}function Me(e,t,n,i,o){const{type:s,coordinates:r}=e,{pointFeatures:a,lineFeatures:l,polygonFeatures:u,polygonOutlineFeatures:g}=t;if(function(e,t){let n=Te[e];c.Z.assert(n,`Unknown GeoJSON type ${e}`);for(;t&&--n>0;)t=t[0];return t&&Number.isFinite(t[0])}(s,r))switch(s){case"Point":a.push(n({geometry:e},i,o));break;case"MultiPoint":r.forEach((e=>{a.push(n({geometry:{type:"Point",coordinates:e}},i,o))}));break;case"LineString":l.push(n({geometry:e},i,o));break;case"MultiLineString":r.forEach((e=>{l.push(n({geometry:{type:"LineString",coordinates:e}},i,o))}));break;case"Polygon":u.push(n({geometry:e},i,o)),r.forEach((e=>{g.push(n({geometry:{type:"LineString",coordinates:e}},i,o))}));break;case"MultiPolygon":r.forEach((e=>{u.push(n({geometry:{type:"Polygon",coordinates:e}},i,o)),e.forEach((e=>{g.push(n({geometry:{type:"LineString",coordinates:e}},i,o))}))}))}else c.Z.warn(`${s} coordinates are malformed`)()}const Te={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function Oe(e){return e.geometry.coordinates}function Ee(e,t){const n={points:{},lines:{},polygons:{},polygonsOutline:{}},{points:i,lines:o,polygons:s}=e,r=function(e,t){const n={points:null,lines:null,polygons:null};for(const i in n){const o=e[i].globalFeatureIds.value;n[i]=new Uint8ClampedArray(3*o.length);const s=[];for(let e=0;e<o.length;e++)t(o[e],s),n[i][3*e+0]=s[0],n[i][3*e+1]=s[1],n[i][3*e+2]=s[2]}return n}(e,t);return n.points.data={length:i.positions.value.length/i.positions.size,attributes:{...i.attributes,getPosition:i.positions,instancePickingColors:{size:3,value:r.points}},properties:i.properties,numericProps:i.numericProps,featureIds:i.featureIds},n.lines.data={length:o.pathIndices.value.length-1,startIndices:o.pathIndices.value,attributes:{...o.attributes,getPath:o.positions,instancePickingColors:{size:3,value:r.lines}},properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},n.lines._pathType="open",n.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{...s.attributes,getPolygon:s.positions,pickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},n.polygons._normalize=!1,s.triangles&&(n.polygons.data.attributes.indices=s.triangles.value),n.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{...s.attributes,getPath:s.positions,instancePickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},n.polygonsOutline._pathType="open",n}const Fe=["points","linestrings","polygons"],Re={...ze(Se.circle),...ze(Se.icon),...ze(Se.text),...ze(be),...ze(we),stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:e=>e.properties.icon},getText:{type:"accessor",value:e=>e.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}};class ke extends i.Z{static{this.layerName="GeoJsonLayer"}static{this.defaultProps=Re}initializeState(){this.state={layerProps:{},features:{},featuresDiff:{}}}updateState({props:e,changeFlags:t}){if(!t.dataChanged)return;const{data:n}=this.props,i=n&&"points"in n&&"polygons"in n&&"lines"in n;this.setState({binary:i}),i?this._updateStateBinary({props:e,changeFlags:t}):this._updateStateJSON({props:e,changeFlags:t})}_updateStateBinary({props:e,changeFlags:t}){const n=Ee(e.data,this.encodePickingColor);this.setState({layerProps:n})}_updateStateJSON({props:e,changeFlags:t}){const n=function(e){if(Array.isArray(e))return e;switch(c.Z.assert(e.type,"GeoJSON does not have type"),e.type){case"Feature":return[e];case"FeatureCollection":return c.Z.assert(Array.isArray(e.features),"GeoJSON does not have features array"),e.features;default:return[{geometry:e}]}}(e.data),i=this.getSubLayerRow.bind(this);let s={};const r={};if(Array.isArray(t.dataChanged)){const e=this.state.features;for(const t in e)s[t]=e[t].slice(),r[t]=[];for(const a of t.dataChanged){const t=Ie(n,i,a);for(const n in e)r[n].push(o({data:s[n],getIndex:e=>e.__source.index,dataRange:a,replace:t[n]}))}}else s=Ie(n,i);const a=function(e,t){const n={points:{},lines:{},polygons:{},polygonsOutline:{}},{pointFeatures:i,lineFeatures:o,polygonFeatures:s,polygonOutlineFeatures:r}=e;return n.points.data=i,n.points._dataDiff=t.pointFeatures&&(()=>t.pointFeatures),n.points.getPosition=Oe,n.lines.data=o,n.lines._dataDiff=t.lineFeatures&&(()=>t.lineFeatures),n.lines.getPath=Oe,n.polygons.data=s,n.polygons._dataDiff=t.polygonFeatures&&(()=>t.polygonFeatures),n.polygons.getPolygon=Oe,n.polygonsOutline.data=r,n.polygonsOutline._dataDiff=t.polygonOutlineFeatures&&(()=>t.polygonOutlineFeatures),n.polygonsOutline.getPath=Oe,n}(s,r);this.setState({features:s,featuresDiff:r,layerProps:a})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n,sourceLayer:i}=t;return t.featureType=Fe.find((e=>i.id.startsWith(`${this.id}-${e}-`))),n>=0&&i.id.startsWith(`${this.id}-points-text`)&&this.state.binary&&(t.index=this.props.data.points.globalFeatureIds.value[n]),t}_updateAutoHighlight(e){const t=`${this.id}-points-`,n="points"===e.featureType;for(const i of this.getSubLayers())i.id.startsWith(t)===n&&i.updateAutoHighlight(e)}_renderPolygonLayer(){const{extruded:e,wireframe:t}=this.props,{layerProps:n}=this.state,i="polygons-fill",o=this.shouldRenderSubLayer(i,n.polygons?.data)&&this.getSubLayerClass(i,we.type);if(o){const s=Ae(this,we.props),r=e&&t;return r||delete s.getLineColor,s.updateTriggers.lineColors=r,new o(s,this.getSubLayerProps({id:i,updateTriggers:s.updateTriggers}),n.polygons)}return null}_renderLineLayers(){const{extruded:e,stroked:t}=this.props,{layerProps:n}=this.state,i="polygons-stroke",o="linestrings",s=!e&&t&&this.shouldRenderSubLayer(i,n.polygonsOutline?.data)&&this.getSubLayerClass(i,be.type),r=this.shouldRenderSubLayer(o,n.lines?.data)&&this.getSubLayerClass(o,be.type);if(s||r){const e=Ae(this,be.props);return[s&&new s(e,this.getSubLayerProps({id:i,updateTriggers:e.updateTriggers}),n.polygonsOutline),r&&new r(e,this.getSubLayerProps({id:o,updateTriggers:e.updateTriggers}),n.lines)]}return null}_renderPointLayers(){const{pointType:e}=this.props,{layerProps:t,binary:n}=this.state;let{highlightedObjectIndex:i}=this.props;!n&&Number.isFinite(i)&&(i=t.points.data.findIndex((e=>e.__source.index===i)));const o=new Set(e.split("+")),s=[];for(const r of o){const e=`points-${r}`,o=Se[r],a=o&&this.shouldRenderSubLayer(e,t.points?.data)&&this.getSubLayerClass(e,o.type);if(a){const l=Ae(this,o.props);let c=t.points;if("text"===r&&n){const{instancePickingColors:e,...t}=c.data.attributes;c={...c,data:{...c.data,attributes:t}}}s.push(new a(l,this.getSubLayerProps({id:e,updateTriggers:l.updateTriggers,highlightedObjectIndex:i}),c))}}return s}renderLayers(){const{extruded:e}=this.props,t=this._renderPolygonLayer();return[!e&&t,this._renderLineLayers(),this._renderPointLayers(),e&&t]}getSubLayerAccessor(e){const{binary:t}=this.state;return t&&"function"==typeof e?(t,n)=>{const{data:i,index:o}=n,s=function(e,t){if(!e)return null;const n="startIndices"in e?e.startIndices[t]:t,i=e.featureIds.value[n];return-1!==n?function(e,t,n){const i={properties:{...e.properties[t]}};for(const o in e.numericProps)i.properties[o]=e.numericProps[o].value[n];return i}(e,i,n):null}(i,o);return e(s,n)}:super.getSubLayerAccessor(e)}}},63885:(e,t,n)=>{n.d(t,{Z:()=>x});var i=n(69199),o=n(81014),s=n(76166),r=n(69180),a=n(21973),l=n(47594),c=n(65757),u=n(50533);class g extends c.Z{constructor(e){super({...e,attributes:{positions:{size:3,padding:18,initialize:!0,type:e.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(e){return this.attributes[e]}getGeometryFromBuffer(e){return this.normalize?super.getGeometryFromBuffer(e):null}normalizeGeometry(e){return this.normalize?function(e,t,n,i){let o;if(Array.isArray(e[0])){const n=e.length*t;o=new Array(n);for(let i=0;i<e.length;i++)for(let n=0;n<t;n++)o[i*t+n]=e[i][n]||0}else o=e;return n?(0,u.dj)(o,{size:t,gridResolution:n}):i?(0,u.ct)(o,{size:t}):o}(e,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):e}getGeometrySize(e){if(d(e)){let t=0;for(const n of e)t+=this.getGeometrySize(n);return t}const t=this.getPathLength(e);return t<2?0:this.isClosed(e)?t<3?0:t+2:t}updateGeometryAttributes(e,t){if(0!==t.geometrySize)if(e&&d(e))for(const n of e){const e=this.getGeometrySize(n);t.geometrySize=e,this.updateGeometryAttributes(n,t),t.vertexStart+=e}else this._updateSegmentTypes(e,t),this._updatePositions(e,t)}_updateSegmentTypes(e,t){const n=this.attributes.segmentTypes,i=!!e&&this.isClosed(e),{vertexStart:o,geometrySize:s}=t;n.fill(0,o,o+s),i?(n[o]=4,n[o+s-2]=4):(n[o]+=1,n[o+s-2]+=2),n[o+s-1]=4}_updatePositions(e,t){const{positions:n}=this.attributes;if(!n||!e)return;const{vertexStart:i,geometrySize:o}=t,s=new Array(3);for(let r=i,a=0;a<o;r++,a++)this.getPointOnPath(e,a,s),n[3*r]=s[0],n[3*r+1]=s[1],n[3*r+2]=s[2]}getPathLength(e){return e.length/this.positionSize}getPointOnPath(e,t,n=[]){const{positionSize:i}=this;t*i>=e.length&&(t+=1-e.length/i);const o=t*i;return n[0]=e[o],n[1]=e[o+1],n[2]=3===i&&e[o+2]||0,n}isClosed(e){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:t}=this,n=e.length-t;return e[0]===e[n]&&e[1]===e[n+1]&&(2===t||e[2]===e[n+2])}}function d(e){return Array.isArray(e[0])}const f=[0,0,0,255],p={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:e=>e.path},getColor:{type:"accessor",value:f},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},h={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class x extends i.Z{static{this.defaultProps=p}static{this.layerName="PathLayer"}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME path-layer-vertex-shader\nin vec2 positions;\nin float instanceTypes;\nin vec3 instanceStartPositions;\nin vec3 instanceEndPositions;\nin vec3 instanceLeftPositions;\nin vec3 instanceRightPositions;\nin vec3 instanceLeftPositions64Low;\nin vec3 instanceStartPositions64Low;\nin vec3 instanceEndPositions64Low;\nin vec3 instanceRightPositions64Low;\nin float instanceStrokeWidths;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\nuniform float opacity;\nout vec4 vColor;\nout vec2 vCornerOffset;\nout float vMiterLength;\nout vec2 vPathPosition;\nout float vPathLength;\nout float vJointType;\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\nfloat flipIfTrue(bool flag) {\nreturn -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\nvec3 prevPoint, vec3 currPoint, vec3 nextPoint,\nvec2 width\n) {\nbool isEnd = positions.x > 0.0;\nfloat sideOfPath = positions.y;\nfloat isJoint = float(sideOfPath == 0.0);\nvec3 deltaA3 = (currPoint - prevPoint);\nvec3 deltaB3 = (nextPoint - currPoint);\nmat3 rotationMatrix;\nbool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\nif (needsRotation) {\ndeltaA3 = deltaA3 * rotationMatrix;\ndeltaB3 = deltaB3 * rotationMatrix;\n}\nvec2 deltaA = deltaA3.xy / width;\nvec2 deltaB = deltaB3.xy / width;\nfloat lenA = length(deltaA);\nfloat lenB = length(deltaB);\nvec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\nvec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\nvec2 perpA = vec2(-dirA.y, dirA.x);\nvec2 perpB = vec2(-dirB.y, dirB.x);\nvec2 tangent = dirA + dirB;\ntangent = length(tangent) > 0. ? normalize(tangent) : perpA;\nvec2 miterVec = vec2(-tangent.y, tangent.x);\nvec2 dir = isEnd ? dirA : dirB;\nvec2 perp = isEnd ? perpA : perpB;\nfloat L = isEnd ? lenA : lenB;\nfloat sinHalfA = abs(dot(miterVec, perp));\nfloat cosHalfA = abs(dot(dirA, miterVec));\nfloat turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\nfloat cornerPosition = sideOfPath * turnDirection;\nfloat miterSize = 1.0 / max(sinHalfA, EPSILON);\nmiterSize = mix(\nmin(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\nmiterSize,\nstep(0.0, cornerPosition)\n);\nvec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n* (sideOfPath + isJoint * turnDirection);\nbool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\nbool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\nbool isCap = isStartCap || isEndCap;\nif (isCap) {\noffsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\nvJointType = capType;\n} else {\nvJointType = jointType;\n}\nvPathLength = L;\nvCornerOffset = offsetVec;\nvMiterLength = dot(vCornerOffset, miterVec * turnDirection);\nvMiterLength = isCap ? isJoint : vMiterLength;\nvec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\nvPathPosition = vec2(\ndot(offsetFromStartOfPath, perp),\ndot(offsetFromStartOfPath, dir)\n);\ngeometry.uv = vPathPosition;\nfloat isValid = step(instanceTypes, 3.5);\nvec3 offset = vec3(offsetVec * width * isValid, 0.0);\nif (needsRotation) {\noffset = rotationMatrix * offset;\n}\nreturn offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\nif (position.w < EPSILON) {\nfloat r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\nposition = refPosition + (position - refPosition) * r;\n}\n}\nvoid main() {\ngeometry.pickingColor = instancePickingColors;\nvColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\nfloat isEnd = positions.x;\nvec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\nvec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\nvec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\nvec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\nvec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\nvec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\ngeometry.worldPosition = currPosition;\nvec2 widthPixels = vec2(clamp(\nproject_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\nwidthMinPixels, widthMaxPixels) / 2.0);\nvec3 width;\nif (billboard) {\nvec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\nvec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\nvec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\nclipLine(prevPositionScreen, currPositionScreen);\nclipLine(nextPositionScreen, currPositionScreen);\nclipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\nwidth = vec3(widthPixels, 0.0);\nDECKGL_FILTER_SIZE(width, geometry);\nvec3 offset = getLineJoinOffset(\nprevPositionScreen.xyz / prevPositionScreen.w,\ncurrPositionScreen.xyz / currPositionScreen.w,\nnextPositionScreen.xyz / nextPositionScreen.w,\nproject_pixel_size_to_clipspace(width.xy)\n);\nDECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\ngl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n} else {\nprevPosition = project_position(prevPosition, prevPosition64Low);\ncurrPosition = project_position(currPosition, currPosition64Low);\nnextPosition = project_position(nextPosition, nextPosition64Low);\nwidth = vec3(project_pixel_size(widthPixels), 0.0);\nDECKGL_FILTER_SIZE(width, geometry);\nvec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\ngeometry.position = vec4(currPosition + offset, 1.0);\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME path-layer-fragment-shader\nprecision highp float;\nuniform float miterLimit;\nin vec4 vColor;\nin vec2 vCornerOffset;\nin float vMiterLength;\nin vec2 vPathPosition;\nin float vPathLength;\nin float vJointType;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = vPathPosition;\nif (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\nif (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\ndiscard;\n}\nif (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\ndiscard;\n}\n}\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[o.Z,s.Z]})}get wrapLongitude(){return!1}getBounds(){return this.getAttributeManager()?.getBounds(["vertexPositions"])}initializeState(){this.getAttributeManager().addInstanced({vertexPositions:{size:3,vertexOffset:1,type:"float64",fp64:this.use64bitPositions(),transition:h,accessor:"getPath",update:this.calculatePositions,noAlloc:true,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:"uint8",update:this.calculateSegmentTypes,noAlloc:true},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:h,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",accessor:"getColor",transition:h,defaultValue:f},instancePickingColors:{size:4,type:"uint8",accessor:(e,{index:t,target:n})=>this.encodePickingColor(e&&e.__source?e.__source.index:t,n)}}),this.setState({pathTesselator:new g({fp64:this.use64bitPositions()})})}updateState(e){super.updateState(e);const{props:t,changeFlags:n}=e,i=this.getAttributeManager();if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPath)){const{pathTesselator:e}=this.state,o=t.data.attributes||{};e.updateGeometry({data:t.data,geometryBuffer:o.getPath,buffers:o,normalize:!t._pathType,loop:"loop"===t._pathType,getGeometry:t.getPath,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:n.dataChanged}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),n.dataChanged||i.invalidateAll()}n.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),i.invalidateAll())}getPickingInfo(e){const t=super.getPickingInfo(e),{index:n}=t,i=this.props.data;return i[0]&&i[0].__source&&(t.object=i.find((e=>e.__source.index===n))),t}disablePickingIndex(e){const t=this.props.data;if(t[0]&&t[0].__source)for(let n=0;n<t.length;n++)t[n].__source.index===e&&this._disablePickingIndex(n);else super.disablePickingIndex(e)}draw({uniforms:e}){const{jointRounded:t,capRounded:n,billboard:i,miterLimit:o,widthUnits:s,widthScale:a,widthMinPixels:l,widthMaxPixels:c}=this.props,u=this.state.model;u.setUniforms(e),u.setUniforms({jointType:Number(t),capType:Number(n),billboard:i,widthUnits:r.iI[s],widthScale:a,miterLimit:o,widthMinPixels:l,widthMaxPixels:c}),u.draw(this.context.renderPass)}_getModel(){return new l.H(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new a.Z({topology:"triangle-list",attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateSegmentTypes(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("segmentTypes")}}},21973:(e,t,n)=>{n.d(t,{Z:()=>s});var i=n(88026),o=n(88393);class s{id;topology;vertexCount;indices;attributes;userData={};constructor(e){const{attributes:t={},indices:n=null,vertexCount:s=null}=e;this.id=e.id||(0,i.h)("geometry"),this.topology=e.topology,n&&(this.indices=ArrayBuffer.isView(n)?{value:n,size:1}:n),this.attributes={};for(const[i,r]of Object.entries(t)){const e=ArrayBuffer.isView(r)?{value:r}:r;(0,o.h)(ArrayBuffer.isView(e.value),`${this._print(i)}: must be typed array or object with value as typed array`),"POSITION"!==i&&"positions"!==i||e.size||(e.size=3),"indices"===i?((0,o.h)(!this.indices),this.indices=e):this.attributes[i]=e}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=s||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(e){return`Geometry ${this.id} attribute ${e}`}_setAttributes(e,t){return this}_calculateVertexCount(e,t){if(t)return t.value.length;let n=1/0;for(const i of Object.values(e)){const{value:e,size:t,constant:o}=i;!o&&e&&t>=1&&(n=Math.min(n,e.length/t))}return(0,o.h)(Number.isFinite(n)),n}}},1937:(e,t,n)=>{n.d(t,{H:()=>r});const i="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\nvec3 color;\n};\nstruct PointLight {\nvec3 color;\nvec3 position;\nvec3 attenuation;\n};\nstruct DirectionalLight {\nvec3 color;\nvec3 direction;\n};\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\nuniform bool lighting_uEnabled;\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\nreturn pointLight.attenuation.x\n+ pointLight.attenuation.y * distance\n+ pointLight.attenuation.z * distance * distance;\n}\n#endif\n",o={lightSources:{}};function s(e={}){const{color:t=[0,0,0],intensity:n=1}=e;return t.map((e=>e*n/255))}const r={name:"lights",vs:i,fs:i,getUniforms:function e(t=o){if("lightSources"in t){const{ambientLight:e,pointLights:n,directionalLights:i}=t.lightSources||{};return e||n&&n.length>0||i&&i.length>0?Object.assign({},function({ambientLight:e,pointLights:t=[],directionalLights:n=[]}){const i={};return i["lighting_uAmbientLight.color"]=e?s(e):[0,0,0],t.forEach(((e,t)=>{i[`lighting_uPointLight[${t}].color`]=s(e),i[`lighting_uPointLight[${t}].position`]=e.position,i[`lighting_uPointLight[${t}].attenuation`]=e.attenuation||[1,0,0]})),i.lighting_uPointLightCount=t.length,n.forEach(((e,t)=>{i[`lighting_uDirectionalLight[${t}].color`]=s(e),i[`lighting_uDirectionalLight[${t}].direction`]=e.direction})),i.lighting_uDirectionalLightCount=n.length,i}({ambientLight:e,pointLights:n,directionalLights:i}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in t){const n={pointLights:[],directionalLights:[]};for(const e of t.lights||[])switch(e.type){case"ambient":n.ambientLight=e;break;case"directional":n.directionalLights?.push(e);break;case"point":n.pointLights?.push(e)}return e({lightSources:n})}return{}},defines:{MAX_LIGHTS:3}}},62602:(e,t,n)=>{n.d(t,{N:()=>a,s:()=>l});var i=n(1937);const o="uniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\nvec3 halfway_direction = normalize(light_direction + view_direction);\nfloat lambertian = dot(light_direction, normal_worldspace);\nfloat specular = 0.0;\nif (lambertian > 0.0) {\nfloat specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\nspecular = pow(specular_angle, lighting_uShininess);\n}\nlambertian = max(lambertian, 0.0);\nreturn (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = surfaceColor;\nif (lighting_uEnabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nlightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uPointLightCount) {\nbreak;\n}\nPointLight pointLight = lighting_uPointLight[i];\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n}\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uDirectionalLightCount) {\nbreak;\n}\nDirectionalLight directionalLight = lighting_uDirectionalLight[i];\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = vec3(0, 0, 0);\nvec3 surfaceColor = vec3(0, 0, 0);\nif (lighting_uEnabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uPointLightCount) {\nbreak;\n}\nPointLight pointLight = lighting_uPointLight[i];\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n}\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uDirectionalLightCount) {\nbreak;\n}\nDirectionalLight directionalLight = lighting_uDirectionalLight[i];\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\n",s={};function r(e=s){if(!("material"in e))return{};const{material:t}=e;return t?function(e){const{ambient:t=.35,diffuse:n=.6,shininess:i=32,specularColor:o=[30,30,30]}=e;return{lighting_uAmbient:t,lighting_uDiffuse:n,lighting_uShininess:i,lighting_uSpecularColor:o.map((e=>e/255))}}(t):{lighting_uEnabled:!1}}const a={name:"gouraud-lighting",dependencies:[i.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:r},l={name:"phong-lighting",dependencies:[i.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:r}},50533:(e,t,n)=>{n.d(t,{wG:()=>i,WZ:()=>D,GU:()=>J,dj:()=>B,ct:()=>K,OT:()=>l,ap:()=>r,Ny:()=>o});const i={CLOCKWISE:1,COUNTER_CLOCKWISE:-1};function o(e,t,n={}){const i=function(e,t={}){return Math.sign(r(e,t))}(e,n);return i!==t&&(function(e,t){const{start:n=0,end:i=e.length,size:o=2}=t,s=(i-n)/o,r=Math.floor(s/2);for(let a=0;a<r;++a){const t=n+a*o,i=n+(s-1-a)*o;for(let n=0;n<o;++n){const o=e[t+n];e[t+n]=e[i+n],e[i+n]=o}}}(e,n),!0)}const s={x:0,y:1,z:2};function r(e,t={}){const{start:n=0,end:i=e.length,plane:o="xy"}=t,r=t.size||2;let a=0;const l=s[o[0]],c=s[o[1]];for(let s=n,u=i-r;s<i;s+=r)a+=(e[s+l]-e[u+l])*(e[s+c]+e[u+c]),u=s;return a/2}var a=n(81180);function l(e,t,n=2,i,o="xy"){const s=t&&t.length,r=s?t[0]*n:e.length;let a=c(e,0,r,n,!0,i&&i[0],o);const l=[];if(!a||a.next===a.prev)return l;let u,d,f,p,h,v,m;if(s&&(a=function(e,t,n,i,o,s){const r=[];let a,l,u,g,d;for(a=0,l=t.length;a<l;a++)u=t[a]*i,g=a<l-1?t[a+1]*i:e.length,d=c(e,u,g,i,!1,o&&o[a+1],s),d===d.next&&(d.steiner=!0),r.push(P(d));for(r.sort(x),a=0;a<r.length;a++)n=y(r[a],n);return n}(e,t,a,n,i,o)),e.length>80*n){p=d=e[0],h=f=e[1];for(let t=n;t<r;t+=n)v=e[t],m=e[t+1],v<p&&(p=v),m<h&&(h=m),v>d&&(d=v),m>f&&(f=m);u=Math.max(d-p,f-h),u=0!==u?32767/u:0}return g(a,l,n,p,h,u,0),l}function c(e,t,n,i,o,a,l){let c,u;void 0===a&&(a=r(e,{start:t,end:n,size:i,plane:l}));let g=s[l[0]],d=s[l[1]];if(o===a<0)for(c=t;c<n;c+=i)u=M(c,e[c+g],e[c+d],u);else for(c=n-i;c>=t;c-=i)u=M(c,e[c+g],e[c+d],u);return u&&S(u,u.next)&&(T(u),u=u.next),u}function u(e,t){if(!e)return e;t||(t=e);let n,i=e;do{if(n=!1,i.steiner||!S(i,i.next)&&0!==L(i.prev,i,i.next))i=i.next;else{if(T(i),i=t=i.prev,i===i.next)break;n=!0}}while(n||i!==t);return t}function g(e,t,n,i,o,s,r){if(!e)return;!r&&s&&function(e,t,n,i){let o=e;do{0===o.z&&(o.z=m(o.x,o.y,t,n,i)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){let t,n,i,o,s,r,a,l,c=1;do{for(o=e,e=null,l=null,i=0;o;){for(i++,r=o,s=0,n=0;n<c&&(s++,r=r.nextZ,r);n++);for(a=c;s>0||a>0&&r;)0!==s&&(0===a||!r||o.z<=r.z)?(t=o,o=o.nextZ,s--):(t=r,r=r.nextZ,a--),l?l.nextZ=t:e=t,t.prevZ=l,l=t;o=r}l.nextZ=null,c*=2}while(i>1)}(o)}(e,i,o,s);let a,l,c=e;for(;e.prev!==e.next;)if(a=e.prev,l=e.next,s?f(e,i,o,s):d(e))t.push(a.i/n|0),t.push(e.i/n|0),t.push(l.i/n|0),T(e),e=l.next,c=l.next;else if((e=l)===c){r?1===r?g(e=p(u(e),t,n),t,n,i,o,s,2):2===r&&h(e,t,n,i,o,s):g(u(e),t,n,i,o,s,1);break}}function d(e){const t=e.prev,n=e,i=e.next;if(L(t,n,i)>=0)return!1;const o=t.x,s=n.x,r=i.x,a=t.y,l=n.y,c=i.y,u=o<s?o<r?o:r:s<r?s:r,g=a<l?a<c?a:c:l<c?l:c,d=o>s?o>r?o:r:s>r?s:r,f=a>l?a>c?a:c:l>c?l:c;let p=i.next;for(;p!==t;){if(p.x>=u&&p.x<=d&&p.y>=g&&p.y<=f&&_(o,a,s,l,r,c,p.x,p.y)&&L(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function f(e,t,n,i){const o=e.prev,s=e,r=e.next;if(L(o,s,r)>=0)return!1;const a=o.x,l=s.x,c=r.x,u=o.y,g=s.y,d=r.y,f=a<l?a<c?a:c:l<c?l:c,p=u<g?u<d?u:d:g<d?g:d,h=a>l?a>c?a:c:l>c?l:c,x=u>g?u>d?u:d:g>d?g:d,y=m(f,p,t,n,i),v=m(h,x,t,n,i);let P=e.prevZ,C=e.nextZ;for(;P&&P.z>=y&&C&&C.z<=v;){if(P.x>=f&&P.x<=h&&P.y>=p&&P.y<=x&&P!==o&&P!==r&&_(a,u,l,g,c,d,P.x,P.y)&&L(P.prev,P,P.next)>=0)return!1;if(P=P.prevZ,C.x>=f&&C.x<=h&&C.y>=p&&C.y<=x&&C!==o&&C!==r&&_(a,u,l,g,c,d,C.x,C.y)&&L(C.prev,C,C.next)>=0)return!1;C=C.nextZ}for(;P&&P.z>=y;){if(P.x>=f&&P.x<=h&&P.y>=p&&P.y<=x&&P!==o&&P!==r&&_(a,u,l,g,c,d,P.x,P.y)&&L(P.prev,P,P.next)>=0)return!1;P=P.prevZ}for(;C&&C.z<=v;){if(C.x>=f&&C.x<=h&&C.y>=p&&C.y<=x&&C!==o&&C!==r&&_(a,u,l,g,c,d,C.x,C.y)&&L(C.prev,C,C.next)>=0)return!1;C=C.nextZ}return!0}function p(e,t,n){let i=e;do{const o=i.prev,s=i.next.next;!S(o,s)&&b(o,i,i.next,s)&&A(o,s)&&A(s,o)&&(t.push(o.i/n|0),t.push(i.i/n|0),t.push(s.i/n|0),T(i),T(i.next),i=e=s),i=i.next}while(i!==e);return u(i)}function h(e,t,n,i,o,s){let r=e;do{let e=r.next.next;for(;e!==r.prev;){if(r.i!==e.i&&C(r,e)){let a=I(r,e);return r=u(r,r.next),a=u(a,a.next),g(r,t,n,i,o,s,0),void g(a,t,n,i,o,s,0)}e=e.next}r=r.next}while(r!==e)}function x(e,t){return e.x-t.x}function y(e,t){const n=function(e,t){let n=t;const i=e.x,o=e.y;let s,r=-1/0;do{if(o<=n.y&&o>=n.next.y&&n.next.y!==n.y){const e=n.x+(o-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=i&&e>r&&(r=e,s=n.x<n.next.x?n:n.next,e===i))return s}n=n.next}while(n!==t);if(!s)return null;const a=s,l=s.x,c=s.y;let u,g=1/0;n=s;do{i>=n.x&&n.x>=l&&i!==n.x&&_(o<c?i:r,o,l,c,o<c?r:i,o,n.x,n.y)&&(u=Math.abs(o-n.y)/(i-n.x),A(n,e)&&(u<g||u===g&&(n.x>s.x||n.x===s.x&&v(s,n)))&&(s=n,g=u)),n=n.next}while(n!==a);return s}(e,t);if(!n)return t;const i=I(n,e);return u(i,i.next),u(n,n.next)}function v(e,t){return L(e.prev,e,t.prev)<0&&L(t.next,e,e.next)<0}function m(e,t,n,i,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function P(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function _(e,t,n,i,o,s,r,a){return(o-r)*(t-a)>=(e-r)*(s-a)&&(e-r)*(i-a)>=(n-r)*(t-a)&&(n-r)*(s-a)>=(o-r)*(i-a)}function C(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&b(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(A(e,t)&&A(t,e)&&function(e,t){let n=e,i=!1;const o=(e.x+t.x)/2,s=(e.y+t.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&o<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==e);return i}(e,t)&&(L(e.prev,e,t.prev)||L(e,t.prev,t))||S(e,t)&&L(e.prev,e,e.next)>0&&L(t.prev,t,t.next)>0)}function L(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function S(e,t){return e.x===t.x&&e.y===t.y}function b(e,t,n,i){const o=z(L(e,t,n)),s=z(L(e,t,i)),r=z(L(n,i,e)),a=z(L(n,i,t));return o!==s&&r!==a||(!(0!==o||!w(e,n,t))||(!(0!==s||!w(e,i,t))||(!(0!==r||!w(n,e,i))||!(0!==a||!w(n,t,i)))))}function w(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function z(e){return e>0?1:e<0?-1:0}function A(e,t){return L(e.prev,e,e.next)<0?L(e,t,e.next)>=0&&L(e,e.prev,t)>=0:L(e,t,e.prev)<0||L(e,e.next,t)<0}function I(e,t){const n=new O(e.i,e.x,e.y),i=new O(t.i,t.x,t.y),o=e.next,s=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function M(e,t,n,i){const o=new O(e,t,n);return i?(o.next=i.next,o.prev=i,i.next.prev=o,i.next=o):(o.prev=o,o.next=o),o}function T(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}class O{constructor(e,t,n){(0,a.Z)(this,"i",void 0),(0,a.Z)(this,"x",void 0),(0,a.Z)(this,"y",void 0),(0,a.Z)(this,"prev",null),(0,a.Z)(this,"next",null),(0,a.Z)(this,"z",0),(0,a.Z)(this,"prevZ",null),(0,a.Z)(this,"nextZ",null),(0,a.Z)(this,"steiner",!1),this.i=e,this.x=t,this.y=n}}function E(e,t,n,i,o=[]){let s,r;if(8&n)s=(i[3]-e[1])/(t[1]-e[1]),r=3;else if(4&n)s=(i[1]-e[1])/(t[1]-e[1]),r=1;else if(2&n)s=(i[2]-e[0])/(t[0]-e[0]),r=2;else{if(!(1&n))return null;s=(i[0]-e[0])/(t[0]-e[0]),r=0}for(let a=0;a<e.length;a++)o[a]=(1&r)===a?i[r]:s*(t[a]-e[a])+e[a];return o}function F(e,t){let n=0;return e[0]<t[0]?n|=1:e[0]>t[2]&&(n|=2),e[1]<t[1]?n|=4:e[1]>t[3]&&(n|=8),n}function R(e,t){const n=t.length,i=e.length;if(i>0){let o=!0;for(let s=0;s<n;s++)if(e[i-n+s]!==t[s]){o=!1;break}if(o)return!1}for(let o=0;o<n;o++)e[i+o]=t[o];return!0}function k(e,t){const n=t.length;for(let i=0;i<n;i++)e[i]=t[i]}function W(e,t,n,i,o=[]){const s=i+t*n;for(let r=0;r<n;r++)o[r]=e[s+r];return o}function B(e,t){const{size:n=2,broken:i=!1,gridResolution:o=10,gridOffset:s=[0,0],startIndex:r=0,endIndex:a=e.length}=t||{},l=(a-r)/n;let c=[];const u=[c],g=W(e,0,n,r);let d,f;const p=U(g,o,s,[]),h=[];R(c,g);for(let x=1;x<l;x++){for(d=W(e,x,n,r,d),f=F(d,p);f;){E(g,d,f,p,h);const e=F(h,p);e&&(E(g,h,e,p,h),f=e),R(c,h),k(g,h),j(p,o,f),i&&c.length>n&&(c=[],u.push(c),R(c,g)),f=F(d,p)}R(c,d),k(g,d)}return i?u:u[0]}const G=0,Z=1;function D(e,t=null,n){if(!e.length)return[];const{size:i=2,gridResolution:o=10,gridOffset:s=[0,0],edgeTypes:r=!1}=n||{},a=[],l=[{pos:e,types:r?new Array(e.length/i).fill(Z):null,holes:t||[]}],c=[[],[]];let u=[];for(;l.length;){const{pos:e,types:t,holes:n}=l.shift();H(e,i,n[0]||e.length,c),u=U(c[0],o,s,u);const g=F(c[1],u);if(g){let o=N(e,t,i,0,n[0]||e.length,u,g);const s={pos:o[0].pos,types:o[0].types,holes:[]},a={pos:o[1].pos,types:o[1].types,holes:[]};l.push(s,a);for(let l=0;l<n.length;l++)o=N(e,t,i,n[l],n[l+1]||e.length,u,g),o[0]&&(s.holes.push(s.pos.length),s.pos=V(s.pos,o[0].pos),r&&(s.types=V(s.types,o[0].types))),o[1]&&(a.holes.push(a.pos.length),a.pos=V(a.pos,o[1].pos),r&&(a.types=V(a.types,o[1].types)))}else{const i={positions:e};r&&(i.edgeTypes=t),n.length&&(i.holeIndices=n),a.push(i)}}return a}function N(e,t,n,i,o,s,r){const a=(o-i)/n,l=[],c=[],u=[],g=[],d=[];let f,p,h;const x=W(e,a-1,n,i);let y=Math.sign(8&r?x[1]-s[3]:x[0]-s[2]),v=t&&t[a-1],m=0,P=0;for(let _=0;_<a;_++)f=W(e,_,n,i,f),p=Math.sign(8&r?f[1]-s[3]:f[0]-s[2]),h=t&&t[i/n+_],p&&y&&y!==p&&(E(x,f,r,s,d),R(l,d)&&u.push(v),R(c,d)&&g.push(v)),p<=0?(R(l,f)&&u.push(h),m-=p):u.length&&(u[u.length-1]=G),p>=0?(R(c,f)&&g.push(h),P+=p):g.length&&(g[g.length-1]=G),k(x,f),y=p,v=h;return[m?{pos:l,types:t&&u}:null,P?{pos:c,types:t&&g}:null]}function U(e,t,n,i){const o=Math.floor((e[0]-n[0])/t)*t+n[0],s=Math.floor((e[1]-n[1])/t)*t+n[1];return i[0]=o,i[1]=s,i[2]=o+t,i[3]=s+t,i}function j(e,t,n){8&n?(e[1]+=t,e[3]+=t):4&n?(e[1]-=t,e[3]-=t):2&n?(e[0]+=t,e[2]+=t):1&n&&(e[0]-=t,e[2]-=t)}function H(e,t,n,i){let o=1/0,s=-1/0,r=1/0,a=-1/0;for(let l=0;l<n;l+=t){const t=e[l],n=e[l+1];o=t<o?t:o,s=t>s?t:s,r=n<r?n:r,a=n>a?n:a}return i[0][0]=o,i[0][1]=r,i[1][0]=s,i[1][1]=a,i}function V(e,t){for(let n=0;n<t.length;n++)e.push(t[n]);return e}const $=85.051129;function K(e,t){const{size:n=2,startIndex:i=0,endIndex:o=e.length,normalize:s=!0}=t||{},r=e.slice(i,o);q(r,n,0,o-i);const a=B(r,{size:n,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(s)for(const l of a)Q(l,n);return a}function J(e,t=null,n){const{size:i=2,normalize:o=!0,edgeTypes:s=!1}=n||{};t=t||[];const r=[],a=[];let l=0,c=0;for(let g=0;g<=t.length;g++){const o=t[g]||e.length,s=c,u=X(e,i,l,o);for(let t=u;t<o;t++)r[c++]=e[t];for(let t=l;t<u;t++)r[c++]=e[t];q(r,i,s,c),Y(r,i,s,c,null==n?void 0:n.maxLatitude),l=o,a[g]=c}a.pop();const u=D(r,a,{size:i,gridResolution:360,gridOffset:[-180,-180],edgeTypes:s});if(o)for(const g of u)Q(g.positions,i);return u}function X(e,t,n,i){let o=-1,s=-1;for(let r=n+1;r<i;r+=t){const t=Math.abs(e[r]);t>o&&(o=t,s=r-1)}return s}function Y(e,t,n,i,o=$){const s=e[n],r=e[i-t];if(Math.abs(s-r)>180){const i=W(e,0,t,n);i[0]+=360*Math.round((r-s)/360),R(e,i),i[1]=Math.sign(i[1])*o,R(e,i),i[0]=s,R(e,i)}}function q(e,t,n,i){let o,s=e[0];for(let r=n;r<i;r+=t){o=e[r];const t=o-s;(t>180||t<-180)&&(o-=360*Math.round(t/360)),e[r]=s=o}}function Q(e,t){let n;const i=e.length/t;for(let s=0;s<i&&(n=e[s*t],(n+180)%360==0);s++);const o=360*-Math.round(n/360);if(0!==o)for(let s=0;s<i;s++)e[s*t]+=o}}}]);