"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1890],{8854:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var t=n(62540),s=n(43023);const a={},o="Introduction",i={id:"arrowjs/developer-guide/introduction",title:"Introduction",description:"Apache Arrow is a binary specification and set of libraries for representing Tables and Columns of strongly-typed fixed-width, variable-width, and nested data structures in-memory and over-the-wire.",source:"@site/../docs/arrowjs/developer-guide/introduction.md",sourceDirName:"arrowjs/developer-guide",slug:"/arrowjs/developer-guide/introduction",permalink:"/docs/arrowjs/developer-guide/introduction",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/arrowjs/developer-guide/introduction.md",tags:[],version:"current",frontMatter:{}},d={},c=[{value:"Components",id:"components",level:2},{value:"Concepts",id:"concepts",level:2},{value:"Data Types",id:"data-types",level:2}];function l(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,t.jsx)(r.p,{children:"Apache Arrow is a binary specification and set of libraries for representing Tables and Columns of strongly-typed fixed-width, variable-width, and nested data structures in-memory and over-the-wire."}),"\n",(0,t.jsx)(r.p,{children:"Arrow represents columns of values in sets of contiguous buffers. This is in contrast to a row-oriented representation, where the values for each row are stored in a contiguous buffer. The columnar representation makes it easier to take advantage of SIMD instruction sets in modern CPUs and GPUs, and can lead to dramatic performance improvements processing large amounts of data."}),"\n",(0,t.jsx)(r.h2,{id:"components",children:"Components"}),"\n",(0,t.jsx)(r.p,{children:"The Arrow library is organized into separate components responsible for creating, reading, writing, serializing, deserializing, or manipulating Tables or Columns."}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"Data Types"})," - Classes that define the fixed-width, variable-width, and composite data types Arrow can represent"]}),"\n",(0,t.jsx)(r.li,{children:"Vectors - Classes to read and decode JavaScript values from the underlying buffers or Vectors for each data type"}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/arrowjs/developer-guide/builders",children:"Builders"})," - Classes to write and encode JavaScript values into the underlying buffers or Vectors for each data type"]}),"\n",(0,t.jsx)(r.li,{children:"Visitors - Classes to traverse, manipulate, read, write, or aggregate values from trees of Arrow Vectors or DataTypes"}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/arrowjs/developer-guide/reading-and-writing",children:"IPC Readers and Writers"})," - Classes to read and write the Arrow IPC (inter-process communication) binary file and stream formats"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"/docs/arrowjs/developer-guide/schemas",children:"Fields, Schemas, RecordBatches, Tables, and Columns"})," - Classes to describe, manipulate, read, and write groups of strongly-typed Vectors or Columns"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"concepts",children:"Concepts"}),"\n",(0,t.jsx)(r.p,{children:"it's probably good to define some terminology:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"Data"}),' a collection of rows in contiguous Arrow memory. This is called "Array" in most arrow implementations but is called ',(0,t.jsx)(r.code,{children:"Data"})," in Arrow JS to avoid shadowing the JS ",(0,t.jsx)(r.code,{children:"Array"})," type. ",(0,t.jsx)(r.code,{children:"Data"})," can have one or more underlying buffers but those buffers all represent the same data. E.g. integer storage like a ",(0,t.jsx)(r.code,{children:"Data"})," of type ",(0,t.jsx)(r.code,{children:"Uint8"})," has two buffers: one for the raw data (directly viewable by a ",(0,t.jsx)(r.code,{children:"Uint8Array"}),") and another for the nullability bitmask: one bit for each row to confer whether the row is null or not. Nested types can have more buffers. E.g. points can be represented as a ",(0,t.jsx)(r.code,{children:"Data"})," of struct type, where there's a buffer for the ",(0,t.jsx)(r.code,{children:"x"})," coordinates and another buffer for the ",(0,t.jsx)(r.code,{children:"y"})," coordinates."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"Vector"})," a collection of rows in batches. This is essentially a list of ",(0,t.jsx)(r.code,{children:"Data"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"Field"}),": metadata that describes an individual ",(0,t.jsx)(r.code,{children:"Data"})," or ",(0,t.jsx)(r.code,{children:"Vector"}),". This contains ",(0,t.jsx)(r.code,{children:"name: string"}),", data type, ",(0,t.jsx)(r.code,{children:"nullable: bool"}),", and ",(0,t.jsx)(r.code,{children:"metadata: Map<string, string>"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"Schema"}),": metadata that describes a named collection of ",(0,t.jsx)(r.code,{children:"Data"})," or ",(0,t.jsx)(r.code,{children:"Vector"}),". This is essentially ",(0,t.jsx)(r.code,{children:"List<Field>"}),", but it can also store optional associated ",(0,t.jsx)(r.code,{children:"metadata: Map<string, string>"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"RecordBatch"})," an ordered and named collection of ",(0,t.jsx)(r.code,{children:"Data"})," instances. This is essentially a ",(0,t.jsx)(r.code,{children:"List<Data>"})," plus a ",(0,t.jsx)(r.code,{children:"Schema"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"Table"}),": an ordered and named collection of ",(0,t.jsx)(r.code,{children:"Vector"})," instances. This is essentially a ",(0,t.jsx)(r.code,{children:"List<Vector>"})," plus a ",(0,t.jsx)(r.code,{children:"Schema"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"data-types",children:"Data Types"}),"\n",(0,t.jsxs)(r.p,{children:["At the heart of Arrow is set of well-known logical ",(0,t.jsx)(r.a,{href:"/docs/arrowjs/developer-guide/data-types",children:"data types"}),", ensuring each Column in an Arrow Table is strongly-typed. These data types define how a Column's underlying buffers should be constructed and read, and includes configurable (and custom) metadata fields for further annotating a Column. A Schema describing each Column's name and data type is encoded alongside each Column's data buffers, allowing you to consume an Arrow data source without knowing the data types or column layout beforehand."]}),"\n",(0,t.jsxs)(r.p,{children:["Each data type falls into one of three rough categories: Fixed-width types, variable-width types, or composite types that contain other Arrow data types. All data types can represent null values, which are stored in a separate validity ",(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Mask_(computing)",children:"bitmask"}),". Follow the links below for a more detailed description of each data type."]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},43023:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>i});var t=n(63696);const s={},a=t.createContext(s);function o(e){const r=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);