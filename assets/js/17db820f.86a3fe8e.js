"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8860],{4112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=n(85893),i=n(11151);const s={},o="Working with BigInts",a={id:"arrowjs/developer-guide/big-ints",title:"Working with BigInts",description:"Arrow supports big integers.",source:"@site/../docs/arrowjs/developer-guide/big-ints.md",sourceDirName:"arrowjs/developer-guide",slug:"/arrowjs/developer-guide/big-ints",permalink:"/docs/arrowjs/developer-guide/big-ints",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/arrowjs/developer-guide/big-ints.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Notes on Memory Management",permalink:"/docs/arrowjs/developer-guide/memory-management"},next:{title:"Data Sources and Sinks",permalink:"/docs/arrowjs/developer-guide/data-sources"}},l={},c=[{value:"Notes about Conversion Methods",id:"notes-about-conversion-methods",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"working-with-bigints",children:"Working with BigInts"}),"\n",(0,r.jsx)(t.p,{children:"Arrow supports big integers."}),"\n",(0,r.jsxs)(t.p,{children:["If the JavaScript platform supports the recently introduced ",(0,r.jsx)(t.code,{children:"BigInt64Array"})," typed array, Arrow JS will use this type."]}),"\n",(0,r.jsx)(t.p,{children:"For convenience ArrowJS inject additional methods (on the object instance) that lets it be converted to JSON, strings, values and primitives"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"bigIntArray.toJSON()"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"bigIntArray.toString()"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"bigIntArray.valueOf()"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"bigIntArray[Symbol.toPrimitive](hint: 'string' | 'number' | 'default')"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"notes-about-conversion-methods",children:"Notes about Conversion Methods"}),"\n",(0,r.jsxs)(t.p,{children:["When you have one of the wide numeric types (",(0,r.jsx)(t.code,{children:"Int64"}),", ",(0,r.jsx)(t.code,{children:"Uint64"}),", or ",(0,r.jsx)(t.code,{children:"Decimal"})," which is 128bit), those ",(0,r.jsx)(t.code,{children:"Vector"})," instances always return/accept subarray slices of the underlying 32bit typed arrays."]}),"\n",(0,r.jsxs)(t.p,{children:["But to make life easier for people consuming the typed arrays, the Arrow JS API adds some ",(0,r.jsx)(t.a,{href:"https://github.com/apache/arrow/blob/3eb07b7ed173e2ecf41d689b0780dd103df63a00/js/src/util/bn.ts#L31",children:"extra methods"})," to the typed arrays before they're returned. The goal of these methods is to handle conversion to and from the various primitive types (",(0,r.jsx)(t.code,{children:"number"}),", ",(0,r.jsx)(t.code,{children:"string"}),", ",(0,r.jsx)(t.code,{children:"bigint"}),", and ",(0,r.jsx)(t.code,{children:"JSON.stringify()"}),') so people usually "fall into the pit of success".']}),"\n",(0,r.jsxs)(t.p,{children:["One of the added methods is an implementation of ",(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive",children:(0,r.jsx)(t.code,{children:"[Symbol.toPrimitive]"})}),", which JS will use when doing certain kinds of implicit primitive coercion."]}),"\n",(0,r.jsxs)(t.p,{children:["The implementation of these methods is ",(0,r.jsx)(t.a,{href:"https://github.com/apache/arrow/blob/3eb07b7ed173e2ecf41d689b0780dd103df63a00/js/src/util/bn.ts#L125",children:"bifurcated"}),", so if you're in an environment with ",(0,r.jsx)(t.code,{children:"BigInt"})," support we use the native type, but if not, we'll make a best-effort attempt to return something meaningful (usually the unsigned decimal representation of the number as a string, though we'd appreciate help if someone knows how to compute the signed decimal representation)."]}),"\n",(0,r.jsx)(t.p,{children:"Examples:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Int64Vector } from 'apache-arrow';\nimport assert from 'assert';\n\nconst bigIntArr = new BigInt64Array([ 1n + BigInt(Number.MAX_SAFE_INTEGER) ])\nconst lilIntArr = new Int32Array(bigIntArr.buffer)\nassert(bigIntArr.length === 1)\nassert(lilIntArr.length === 2)\n\nconst bigIntVec = Int64Vector.from(bigIntArr)\nassert(bigIntVec.length === 1)\n\nconst bigIntVal = bigIntVec.get(0)\nassert(bigIntVal instanceof Int32Array)\nassert(bigIntVal[0] === 0)\nassert(bigIntVal[1] === 2097152)\n\n// these implicitly call bigIntVal[Symbol.toPrimitive]()\nassert(('' + bigIntVal) == '9007199254740992') // aka bigIntVal[Symbol.toPrimitive]('string')\nassert((0 + bigIntVal) == 9007199254740992) // aka bigIntVal[Symbol.toPrimitive]('number')\nassert((0n + bigIntVal) == 9007199254740992n) // aka bigIntVal[Symbol.toPrimitive]('default')```\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>o});var r=n(67294);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);