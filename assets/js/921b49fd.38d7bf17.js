"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[8552],{58689:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>n,metadata:()=>i,toc:()=>d});var r=s(62540),t=s(43023);const n={},o="Using Batched Loaders",i={id:"developer-guide/using-streaming-loaders",title:"Using Batched Loaders",description:"A major feature of loaders.gl is the availability of a number of batched (or streaming) loaders.",source:"@site/../docs/developer-guide/using-streaming-loaders.md",sourceDirName:"developer-guide",slug:"/developer-guide/using-streaming-loaders",permalink:"/docs/developer-guide/using-streaming-loaders",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/developer-guide/using-streaming-loaders.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Using Worker Loaders",permalink:"/docs/developer-guide/using-worker-loaders"},next:{title:"Node.js support",permalink:"/docs/developer-guide/node"}},c={},d=[{value:"Batches: Async Iterator based Streaming",id:"batches-async-iterator-based-streaming",level:2},{value:"Streaming Data Sources",id:"streaming-data-sources",level:2},{value:"Applying Transforms",id:"applying-transforms",level:2}];function l(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.header,{children:(0,r.jsx)(a.h1,{id:"using-batched-loaders",children:"Using Batched Loaders"})}),"\n",(0,r.jsx)(a.p,{children:"A major feature of loaders.gl is the availability of a number of batched (or streaming) loaders."}),"\n",(0,r.jsxs)(a.p,{children:["The advantages and characteristics of streaming are descriped in more detail in the ",(0,r.jsx)(a.a,{href:"./concepts/streaming",children:"streaming"})," concepts section, but the highlights are:"]}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsxs)(a.li,{children:["Ability to parse large data sources that exceed browser memory limits (maximum allocation limits for a single ",(0,r.jsx)(a.code,{children:"string"})," or ",(0,r.jsx)(a.code,{children:"ArrayBuffer"})," etc tends to be less tha 1GB in most browsers)."]}),"\n",(0,r.jsx)(a.li,{children:"While parsing is done on smaller chunks and does not freeze the main thread."}),"\n",(0,r.jsx)(a.li,{children:"data can be processed (and displayed) as it arrives over the network, rather than at the end of a long request, leading to a more interactive experience."}),"\n",(0,r.jsx)(a.li,{children:"transforms can be applied incrementally to the incoming data, e.g. to cryptographically hash or decrypt data"}),"\n"]}),"\n",(0,r.jsx)(a.h2,{id:"batches-async-iterator-based-streaming",children:"Batches: Async Iterator based Streaming"}),"\n",(0,r.jsxs)(a.p,{children:["The loaders.gl streaming architecture is built around ES2018 async iterators rather than the more traditional ",(0,r.jsx)(a.code,{children:"Stream"}),'s. Async iterators are arguably easier to work with than streams, are consistent across browsers and Node.js, and enable a "callback-less" programming style supported by built-in JavaScript language features, such as ',(0,r.jsx)(a.code,{children:"for await (... of ...)"})," and ",(0,r.jsx)(a.code,{children:"async function *"}),"."]}),"\n",(0,r.jsxs)(a.p,{children:["Note: ",(0,r.jsx)(a.code,{children:"Stream"}),' input sources is still accepted by loaders.gl functions, however internally processing is done via async iterators and the output of a batched parsing operation is an async iterator that yields "batches" of parsed data.']}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-typescript",children:"import {JSONLoader} from '@loaders.gl/json';\nimport {load} from '@loaders.gl/core';\n\nconst data = await load(url, JSONLoader, {json: options});\n"})}),"\n",(0,r.jsx)(a.p,{children:'The JSONLoader supports streaming JSON parsing, in which case it will yield "batches" of rows from the first array it encounters in the JSON. To e.g. parse a stream of GeoJSON:'}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-typescript",children:"import {GeoJSONLoader} from '@loaders.gl/json';\nimport {load} from '@loaders.gl/core';\n\nconst batches = await loadInBatches('geojson.json', GeoJSONLoader);\n\nfor await (const batch of batches) {\n  // batch.data will contain a number of rows\n  for (const feature of batch.data) {\n    switch (feature.geometry.type) {\n      case 'Polygon':\n      ...\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(a.h2,{id:"streaming-data-sources",children:"Streaming Data Sources"}),"\n",(0,r.jsxs)(a.p,{children:["While the primary input for ",(0,r.jsx)(a.code,{children:"parseInBatches"})," is an async iterator many input types are supported:"]}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.code,{children:"AsyncIterable<ArrayBuffer>"})," (i.e. the iterator must yield ",(0,r.jsx)(a.code,{children:"ArrayBuffer"})," chunks)."]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.code,{children:"Stream"})," instances can be used as input to ",(0,r.jsx)(a.code,{children:"parseInBatches"}),". An async iterator will automatically be created from the stream."]}),"\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.code,{children:"Response"})," objects can also be used as input (the ",(0,r.jsx)(a.code,{children:"Response.body"})," stream will be used)."]}),"\n"]}),"\n",(0,r.jsxs)(a.p,{children:["In addition, note that applications can easily wrap many data types in a ",(0,r.jsx)(a.code,{children:"Response"})," object (e.g. ",(0,r.jsx)(a.code,{children:"FormData"}),", ",(0,r.jsx)(a.code,{children:"Blob"}),", ",(0,r.jsx)(a.code,{children:"File"}),", ",(0,r.jsx)(a.code,{children:"string"}),", ",(0,r.jsx)(a.code,{children:"ArrayBuffer"})," etc), which makes it possible to do streaming loads from almost any data source."]}),"\n",(0,r.jsx)(a.h2,{id:"applying-transforms",children:"Applying Transforms"}),"\n",(0,r.jsx)("p",{class:"badges",children:(0,r.jsx)("img",{src:"https://img.shields.io/badge/From-v2.3-blue.svg?style=flat-square",alt:"From-v2.3"})}),"\n",(0,r.jsx)(a.p,{children:"Example of using a transform to calculate a cryptographic hash:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-typescript",children:"import {loadInBatches} from '@loaders.gl/core';\nimport {CRC32HashTransform} from '@loaders.gl/crypto';\n\nlet hash;\n\nconst csvIterator = await loadInBatches(CSV_URL, CSVLoader, {\n  transforms: [CRC32HashTransform],\n  crypto: {\n    onEnd: (result) => {\n      hash = result.hash;\n    }\n  }\n});\n\nlet csv;\nfor await (const batch of csvIterator) {\n}\n\nconsole.log(hash);\n"})}),"\n",(0,r.jsx)(a.p,{children:"Note that by using a transform, the hash is calculated incrementally as batches are loaded and parsed, and does not require having the entire data source loaded into memory. It also distributes the potentially heavy hash calculation over the batches, keeping the main thread responsive."})]})}function h(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},43023:(e,a,s)=>{s.d(a,{R:()=>o,x:()=>i});var r=s(63696);const t={},n=r.createContext(t);function o(e){const a=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(n.Provider,{value:a},e.children)}}}]);