"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5242],{5527:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var r=n(62540),a=n(43023);const s={},i="Streaming",o={id:"developer-guide/concepts/streaming",title:"Streaming",description:"Streaming support in loaders.gl is a work-in-progress. The ambition is that many loaders would support streaming from both Node and DOM streams, through a consistent API and set of conventions (for both applications and loader/writer objects).",source:"@site/../docs/developer-guide/concepts/streaming.md",sourceDirName:"developer-guide/concepts",slug:"/developer-guide/concepts/streaming",permalink:"/docs/developer-guide/concepts/streaming",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/developer-guide/concepts/streaming.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Binary Data",permalink:"/docs/developer-guide/concepts/binary-data"},next:{title:"AsyncIterators",permalink:"/docs/developer-guide/concepts/async-iterators"}},l={},d=[{value:"Streaming Loads",id:"streaming-loads",level:2},{value:"Incremental Parsing",id:"incremental-parsing",level:3},{value:"Incremental Loading",id:"incremental-loading",level:3},{value:"Streamed Loading",id:"streamed-loading",level:3},{value:"Batched Updates",id:"batched-updates",level:2},{value:"Streaming Writes",id:"streaming-writes",level:2},{value:"Node Streams vs DOM Streams",id:"node-streams-vs-dom-streams",level:2},{value:"Polyfills",id:"polyfills",level:2},{value:"Stream Utilities",id:"stream-utilities",level:2}];function c(e){const t={blockquote:"blockquote",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"streaming",children:"Streaming"})}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsx)(t.p,{children:"Streaming support in loaders.gl is a work-in-progress. The ambition is that many loaders would support streaming from both Node and DOM streams, through a consistent API and set of conventions (for both applications and loader/writer objects)."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"streaming-loads",children:"Streaming Loads"}),"\n",(0,r.jsx)(t.h3,{id:"incremental-parsing",children:"Incremental Parsing"}),"\n",(0,r.jsx)(t.p,{children:"Some loaders offer incremental parsing (chunks of incomplete data can be parsed, and updates will be sent after a certain batch size has been exceeded). In many cases, parsing is fast compared to loading of data, so incremental parsing on its own may not provide a lot of value for applications."}),"\n",(0,r.jsx)(t.h3,{id:"incremental-loading",children:"Incremental Loading"}),"\n",(0,r.jsx)(t.p,{children:"Incremental parsing becomes more interesting when it can be powered by incremental loading, whether through request updates or streams (see below)."}),"\n",(0,r.jsx)(t.h3,{id:"streamed-loading",children:"Streamed Loading"}),"\n",(0,r.jsx)(t.p,{children:"Streamed loading means that the entire data does not need to be loaded."}),"\n",(0,r.jsx)(t.p,{children:"This is particularly advantageous when:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"loading files with sizes that exceed browser limits (e.g. 1GB in Chrome)"}),"\n",(0,r.jsx)(t.li,{children:"doing local processing to files (tranforming one row at a time), this allows pipe constructions that can process files that far exceed internal memory."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"batched-updates",children:"Batched Updates"}),"\n",(0,r.jsx)(t.p,{children:"For incemental loading and parsing to be really effective, the application needs to be able to deal efficiently with partial batches as they arrive. Each loader category (or loader) may define a batch update conventions that are appropriate for the format being loaded."}),"\n",(0,r.jsx)(t.h2,{id:"streaming-writes",children:"Streaming Writes"}),"\n",(0,r.jsx)(t.p,{children:"TBA"}),"\n",(0,r.jsx)(t.h2,{id:"node-streams-vs-dom-streams",children:"Node Streams vs DOM Streams"}),"\n",(0,r.jsx)(t.p,{children:"Stream support is finally arriving in browsers, however DOM Streams have a slightly different API than Node streams and the support across browsers is still spotty."}),"\n",(0,r.jsx)(t.h2,{id:"polyfills",children:"Polyfills"}),"\n",(0,r.jsx)(t.p,{children:"Stream support across browsers can be somewhat improved with polyfills. TBA"}),"\n",(0,r.jsx)(t.h2,{id:"stream-utilities",children:"Stream Utilities"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Stream to memory, ..."}),"\n",(0,r.jsx)(t.li,{children:"Automatically create stream if loader/writer only supports streaming"}),"\n",(0,r.jsx)(t.li,{children:"..."}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},43023:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(63696);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);