"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1223],{16652:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>i});var t=r(74848),l=r(28453);const c={},s="Table",a={id:"arrowjs/api-reference/table",title:"Table",description:"This documentation reflects Arrow JS v4.0. Needs to be updated for the new Arrow API in v9.0 +.",source:"@site/../docs/arrowjs/api-reference/table.md",sourceDirName:"arrowjs/api-reference",slug:"/arrowjs/api-reference/table",permalink:"/docs/arrowjs/api-reference/table",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/arrowjs/api-reference/table.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Schema",permalink:"/docs/arrowjs/api-reference/schema"},next:{title:"Types",permalink:"/docs/arrowjs/api-reference/types"}},o={},i=[{value:"Overview",id:"overview",level:2},{value:"Usage",id:"usage",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"Static Methods",id:"static-methods",level:2},{value:"Table.empty() : Table",id:"tableempty--table",level:3},{value:"Table.from() : Table",id:"tablefrom--table",level:3},{value:"Table.from(source: RecordBatchReader): Table",id:"tablefromsource-recordbatchreader-table",level:3},{value:"Table.from(source: <code>Promise&lt;RecordBatchReader&gt;</code>): <code>Promise&lt;Table&gt;</code>",id:"tablefromsource-promiserecordbatchreader-promisetable",level:3},{value:"Table.from(source?: any) : Table",id:"tablefromsource-any--table",level:3},{value:"Table.fromAsync(source: import(&#39;./ipc/reader&#39;).FromArgs): <code>Promise&lt;Table&gt;</code>",id:"tablefromasyncsource-importipcreaderfromargs-promisetable",level:3},{value:"Table.fromVectors(vectors: any[], names?: String[]) : Table",id:"tablefromvectorsvectors-any-names-string--table",level:3},{value:"Table.fromStruct(struct: Vector) : Table",id:"tablefromstructstruct-vector--table",level:3},{value:"Table.new(columns: Object)",id:"tablenewcolumns-object",level:3},{value:"Table.new(...columns)",id:"tablenewcolumns",level:3},{value:"Table.new(vectors: Vector[], names: String[])",id:"tablenewvectors-vector-names-string",level:3},{value:"Members",id:"members",level:2},{value:"schema (readonly)",id:"schema-readonly",level:3},{value:"length : Number (readonly)",id:"length--number-readonly",level:3},{value:"chunks : RecordBatch[] (readonly)",id:"chunks--recordbatch-readonly",level:3},{value:"numCols : Number (readonly)",id:"numcols--number-readonly",level:3},{value:"Methods",id:"methods",level:2},{value:"constructor(batches: RecordBatch[])",id:"constructorbatches-recordbatch",level:3},{value:"constructor(...batches: RecordBatch[])",id:"constructorbatches-recordbatch-1",level:3},{value:"constructor(schema: Schema, batches: RecordBatch[])",id:"constructorschema-schema-batches-recordbatch",level:3},{value:"constructor(schema: Schema, ...batches: RecordBatch[])",id:"constructorschema-schema-batches-recordbatch-1",level:3},{value:"constructor(...args: any[])",id:"constructorargs-any",level:3},{value:"clone(chunks?:)",id:"clonechunks",level:3},{value:"getColumnAt(index: number): Column | null",id:"getcolumnatindex-number-column--null",level:3},{value:"getColumn(name: String): Column | null",id:"getcolumnname-string-column--null",level:3},{value:"getColumnIndex(name: String) : Number | null",id:"getcolumnindexname-string--number--null",level:3},{value:"getChildAt(index: number): Column | null",id:"getchildatindex-number-column--null",level:3},{value:"serialize(encoding = &#39;binary&#39;, stream = true) : Uint8Array",id:"serializeencoding--binary-stream--true--uint8array",level:3},{value:"count(): number",id:"count-number",level:3},{value:"select(...columnNames: string[]) : Table",id:"selectcolumnnames-string--table",level:3},{value:"countBy(name : Col | String) : Table",id:"countbyname--col--string--table",level:3}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"table",children:"Table"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"This documentation reflects Arrow JS v4.0. Needs to be updated for the new Arrow API in v9.0 +."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Logical table as sequence of chunked arrays"}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The JavaScript ",(0,t.jsx)(n.code,{children:"Table"})," class is not part of the Apache Arrow specification as such, but is rather a tool to allow you to work with multiple record batches and array pieces as a single logical dataset."]}),"\n",(0,t.jsx)(n.p,{children:"As a relevant example, we may receive multiple small record batches in a socket stream, then need to concatenate them into contiguous memory for use in NumPy or pandas. The Table object makes this efficient without requiring additional memory copying."}),"\n",(0,t.jsxs)(n.p,{children:["A Table\u2019s columns are instances of ",(0,t.jsx)(n.code,{children:"Column"}),", which is a container for one or more arrays of the same type."]}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Table.new()"})," accepts an ",(0,t.jsx)(n.code,{children:"Object"})," of ",(0,t.jsx)(n.code,{children:"Columns"})," or ",(0,t.jsx)(n.code,{children:"Vectors"}),", where the keys will be used as the field names for the ",(0,t.jsx)(n.code,{children:"Schema"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const i32s = Int32Vector.from([1, 2, 3]);\nconst f32s = Float32Vector.from([0.1, 0.2, 0.3]);\nconst table = Table.new({i32: i32s, f32: f32s});\nassert(table.schema.fields[0].name === 'i32');\n"})}),"\n",(0,t.jsx)(n.p,{children:"It also accepts a a list of Vectors with an optional list of names or\nFields for the resulting Schema. If the list is omitted or a name is\nmissing, the numeric index of each Vector will be used as the name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const i32s = Int32Vector.from([1, 2, 3]);\nconst f32s = Float32Vector.from([0.1, 0.2, 0.3]);\nconst table = Table.new([i32s, f32s], ['i32']);\nassert(table.schema.fields[0].name === 'i32');\nassert(table.schema.fields[1].name === '1');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If the supplied arguments are ",(0,t.jsx)(n.code,{children:"Column"})," instances, ",(0,t.jsx)(n.code,{children:"Table.new"})," will infer the ",(0,t.jsx)(n.code,{children:"Schema"})," from the ",(0,t.jsx)(n.code,{children:"Column"}),"s:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const i32s = Column.new('i32', Int32Vector.from([1, 2, 3]));\nconst f32s = Column.new('f32', Float32Vector.from([0.1, 0.2, 0.3]));\nconst table = Table.new(i32s, f32s);\nassert(table.schema.fields[0].name === 'i32');\nassert(table.schema.fields[1].name === 'f32');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If the supplied Vector or Column lengths are unequal, ",(0,t.jsx)(n.code,{children:"Table.new"})," will\nextend the lengths of the shorter Columns, allocating additional bytes\nto represent the additional null slots. The memory required to allocate\nthese additional bitmaps can be computed as:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"let additionalBytes = 0;\nfor (let vec in shorter_vectors) {\n  additionalBytes += ((longestLength - vec.length + 63) & ~63) >> 3;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For example, an additional null bitmap for one million null values would require ",(0,t.jsx)(n.code,{children:"125,000"})," bytes (",(0,t.jsx)(n.code,{children:"((1e6 + 63) & ~63) >> 3"}),"), or approx. ",(0,t.jsx)(n.code,{children:"0.11MiB"})]}),"\n",(0,t.jsx)(n.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Table"})," extends Chunked"]}),"\n",(0,t.jsx)(n.h2,{id:"static-methods",children:"Static Methods"}),"\n",(0,t.jsx)(n.h3,{id:"tableempty--table",children:"Table.empty() : Table"}),"\n",(0,t.jsx)(n.p,{children:"Creates an empty table"}),"\n",(0,t.jsx)(n.h3,{id:"tablefrom--table",children:"Table.from() : Table"}),"\n",(0,t.jsx)(n.p,{children:"Creates an empty table"}),"\n",(0,t.jsx)(n.h3,{id:"tablefromsource-recordbatchreader-table",children:"Table.from(source: RecordBatchReader): Table"}),"\n",(0,t.jsxs)(n.h3,{id:"tablefromsource-promiserecordbatchreader-promisetable",children:["Table.from(source: ",(0,t.jsx)(n.code,{children:"Promise<RecordBatchReader>"}),"): ",(0,t.jsx)(n.code,{children:"Promise<Table>"})]}),"\n",(0,t.jsx)(n.h3,{id:"tablefromsource-any--table",children:"Table.from(source?: any) : Table"}),"\n",(0,t.jsxs)(n.h3,{id:"tablefromasyncsource-importipcreaderfromargs-promisetable",children:["Table.fromAsync(source: import('./ipc/reader').FromArgs): ",(0,t.jsx)(n.code,{children:"Promise<Table>"})]}),"\n",(0,t.jsx)(n.h3,{id:"tablefromvectorsvectors-any-names-string--table",children:"Table.fromVectors(vectors: any[], names?: String[]) : Table"}),"\n",(0,t.jsx)(n.h3,{id:"tablefromstructstruct-vector--table",children:"Table.fromStruct(struct: Vector) : Table"}),"\n",(0,t.jsx)(n.h3,{id:"tablenewcolumns-object",children:"Table.new(columns: Object)"}),"\n",(0,t.jsx)(n.h3,{id:"tablenewcolumns",children:"Table.new(...columns)"}),"\n",(0,t.jsx)(n.h3,{id:"tablenewvectors-vector-names-string",children:"Table.new(vectors: Vector[], names: String[])"}),"\n",(0,t.jsxs)(n.p,{children:["Type safe constructors. Functionally equivalent to calling ",(0,t.jsx)(n.code,{children:"new Table()"})," with the same arguments, however if using Typescript using the ",(0,t.jsx)(n.code,{children:"new"}),' method instead will ensure that types inferred from the arguments "flow through" into the return Table type.']}),"\n",(0,t.jsx)(n.h2,{id:"members",children:"Members"}),"\n",(0,t.jsx)(n.h3,{id:"schema-readonly",children:"schema (readonly)"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Schema"})," of this table."]}),"\n",(0,t.jsx)(n.h3,{id:"length--number-readonly",children:"length : Number (readonly)"}),"\n",(0,t.jsx)(n.p,{children:"The number of rows in this table."}),"\n",(0,t.jsx)(n.p,{children:"TBD: this does not consider filters"}),"\n",(0,t.jsx)(n.h3,{id:"chunks--recordbatch-readonly",children:"chunks : RecordBatch[] (readonly)"}),"\n",(0,t.jsx)(n.p,{children:"The list of chunks in this table."}),"\n",(0,t.jsx)(n.h3,{id:"numcols--number-readonly",children:"numCols : Number (readonly)"}),"\n",(0,t.jsx)(n.p,{children:"The number of columns in this table."}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h3,{id:"constructorbatches-recordbatch",children:"constructor(batches: RecordBatch[])"}),"\n",(0,t.jsx)(n.p,{children:"The schema will be inferred from the record batches."}),"\n",(0,t.jsx)(n.h3,{id:"constructorbatches-recordbatch-1",children:"constructor(...batches: RecordBatch[])"}),"\n",(0,t.jsx)(n.p,{children:"The schema will be inferred from the record batches."}),"\n",(0,t.jsx)(n.h3,{id:"constructorschema-schema-batches-recordbatch",children:"constructor(schema: Schema, batches: RecordBatch[])"}),"\n",(0,t.jsx)(n.h3,{id:"constructorschema-schema-batches-recordbatch-1",children:"constructor(schema: Schema, ...batches: RecordBatch[])"}),"\n",(0,t.jsx)(n.h3,{id:"constructorargs-any",children:"constructor(...args: any[])"}),"\n",(0,t.jsxs)(n.p,{children:["Create a new ",(0,t.jsx)(n.code,{children:"Table"})," from a collection of ",(0,t.jsx)(n.code,{children:"Columns"})," or ",(0,t.jsx)(n.code,{children:"Vectors"}),", with an optional list of names or ",(0,t.jsx)(n.code,{children:"Fields"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"TBD"}),"\n",(0,t.jsx)(n.h3,{id:"clonechunks",children:"clone(chunks?:)"}),"\n",(0,t.jsx)(n.p,{children:"Returns a new copy of this table."}),"\n",(0,t.jsx)(n.h3,{id:"getcolumnatindex-number-column--null",children:"getColumnAt(index: number): Column | null"}),"\n",(0,t.jsx)(n.p,{children:"Gets a column by index."}),"\n",(0,t.jsx)(n.h3,{id:"getcolumnname-string-column--null",children:"getColumn(name: String): Column | null"}),"\n",(0,t.jsx)(n.p,{children:"Gets a column by name"}),"\n",(0,t.jsx)(n.h3,{id:"getcolumnindexname-string--number--null",children:"getColumnIndex(name: String) : Number | null"}),"\n",(0,t.jsxs)(n.p,{children:["Returns the index of the column with name ",(0,t.jsx)(n.code,{children:"name"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"getchildatindex-number-column--null",children:"getChildAt(index: number): Column | null"}),"\n",(0,t.jsx)(n.p,{children:"TBD"}),"\n",(0,t.jsx)(n.h3,{id:"serializeencoding--binary-stream--true--uint8array",children:"serialize(encoding = 'binary', stream = true) : Uint8Array"}),"\n",(0,t.jsxs)(n.p,{children:["Returns a ",(0,t.jsx)(n.code,{children:"Uint8Array"})," that contains an encoding of all the data in the table."]}),"\n",(0,t.jsxs)(n.p,{children:["Note: Passing the returned data back into ",(0,t.jsx)(n.code,{children:"Table.from()"}),' creates a "deep clone" of the table.']}),"\n",(0,t.jsx)(n.h3,{id:"count-number",children:"count(): number"}),"\n",(0,t.jsx)(n.p,{children:"TBD - Returns the number of elements."}),"\n",(0,t.jsx)(n.h3,{id:"selectcolumnnames-string--table",children:"select(...columnNames: string[]) : Table"}),"\n",(0,t.jsx)(n.p,{children:"Returns a new Table with the specified subset of columns, in the specified order."}),"\n",(0,t.jsx)(n.h3,{id:"countbyname--col--string--table",children:"countBy(name : Col | String) : Table"}),"\n",(0,t.jsxs)(n.p,{children:["Returns a new Table that contains two columns (",(0,t.jsx)(n.code,{children:"values"})," and ",(0,t.jsx)(n.code,{children:"counts"}),")."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(96540);const l={},c=t.createContext(l);function s(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);