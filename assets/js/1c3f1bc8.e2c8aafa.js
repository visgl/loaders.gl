"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[4356],{69529:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>h,frontMatter:()=>n,metadata:()=>c,toc:()=>d});var r=s(74848),a=s(28453);const n={},o="parseInBatches",c={id:"modules/core/api-reference/parse-in-batches",title:"parseInBatches",description:'The parseInBatches function can parse incrementally from a stream of data as it arrives and emit "batches" of parsed data.',source:"@site/../docs/modules/core/api-reference/parse-in-batches.md",sourceDirName:"modules/core/api-reference",slug:"/modules/core/api-reference/parse-in-batches",permalink:"/docs/modules/core/api-reference/parse-in-batches",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/loaders.gl/tree/master/website/../docs/modules/core/api-reference/parse-in-batches.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"parseSync",permalink:"/docs/modules/core/api-reference/parse-sync"},next:{title:"selectLoader",permalink:"/docs/modules/core/api-reference/select-loader"}},i={},d=[{value:"Usage",id:"usage",level:2},{value:"Functions",id:"functions",level:2},{value:"async parseInBatches(data: DataSource, loaders: object | object[], options?: object): AsyncIterator",id:"async-parseinbatchesdata-datasource-loaders-object--object-options-object-asynciterator",level:3},{value:"async parseInBatches(data: DataSource, options?: object]]): AsyncIterator",id:"async-parseinbatchesdata-datasource-options-object-asynciterator",level:3},{value:"Input Types",id:"input-types",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"parseinbatches",children:"parseInBatches"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"parseInBatches"}),' function can parse incrementally from a stream of data as it arrives and emit "batches" of parsed data.']}),"\n",(0,r.jsx)(t.p,{children:"Batched parsing is only supported by a subset of loaders. Check documentation of each loader before using this function."}),"\n",(0,r.jsxs)(t.p,{children:["From ",(0,r.jsx)(t.a,{href:"http://shields.io",children:(0,r.jsx)(t.img,{src:"https://img.shields.io/badge/v2.3-blue.svg?style=flat-square",alt:"Website shields.io"})})," ",(0,r.jsx)(t.code,{children:"parseInBatches"})," can be used with all loaders. Non-supporting loaders will wait until all data has arrived, and emit a single batch containing the parsed data for the entire input (effectively behave as if ",(0,r.jsx)(t.code,{children:"parse"})," had been called)."]}),"\n",(0,r.jsx)(t.admonition,{type:"caution",children:(0,r.jsxs)(t.p,{children:["When calling parse from a loader to invoke a sub-loader, do not use this function. Use the ",(0,r.jsx)(t.code,{children:"parseInBatchesWithContext"})," counterparts in `@loaders.gl/loader-utils``"]})}),"\n",(0,r.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(t.p,{children:"Parse CSV in batches (emitting a batch of rows every time data arrives from the network):"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import {fetchFile, parseInBatches} from '@loaders.gl/core';\nimport {CSVLoader} from '@loaders.gl/obj';\n\nconst batchIterator = await parseInBatches(fetchFile(url), CSVLoader);\nfor await (const batch of batchIterator) {\n  console.log(batch.length);\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Parse CSV in batches, requesting an initial metadata batch:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import {fetchFile, parseInBatches} from '@loaders.gl/core';\nimport {CSVLoader} from '@loaders.gl/obj';\n\nconst batchIterator = await parseInBatches(fetchFile(url), CSVLoader, {metadata: true});\nfor await (const batch of batchIterator) {\n  switch (batch.batchType) {\n    case 'metadata':\n      console.log(batch.metadata);\n      break;\n    default:\n      processBatch(batch.data);\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"functions",children:"Functions"}),"\n",(0,r.jsx)(t.h3,{id:"async-parseinbatchesdata-datasource-loaders-object--object-options-object-asynciterator",children:"async parseInBatches(data: DataSource, loaders: object | object[], options?: object): AsyncIterator"}),"\n",(0,r.jsx)(t.h3,{id:"async-parseinbatchesdata-datasource-options-object-asynciterator",children:"async parseInBatches(data: DataSource, options?: object]]): AsyncIterator"}),"\n",(0,r.jsx)(t.p,{children:"Parses data in batches from a stream, releasing each batch to the application while the stream is still being read."}),"\n",(0,r.jsxs)(t.p,{children:["Parses data with the selected ",(0,r.jsx)(t.em,{children:"loader object"}),". An array of ",(0,r.jsx)(t.code,{children:"loaders"})," can be provided, in which case an attempt will be made to autodetect which loader is appropriate for the file (using url extension and header matching)."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"data"}),": loaded data or an object that allows data to be loaded. Plese refer to the table below for valid types."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"loaders"})," can be a single loader or an array of loaders. If ommitted, will use the list of registered loaders (see ",(0,r.jsx)(t.code,{children:"registerLoaders"}),")"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"options"}),": See ",(0,r.jsx)(t.a,{href:"./loader-options",children:(0,r.jsx)(t.code,{children:"LoaderOptions"})})," for documentation of options."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"url"}),": optional, assists in the autoselection of a loader if multiple loaders are supplied to ",(0,r.jsx)(t.code,{children:"loader"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Returns:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Returns an async iterator that yields batches of data. The exact format for the batches depends on the ",(0,r.jsx)(t.em,{children:"loader object"})," category."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Notes:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"loaders"})," parameter can also be ommitted, in which case any ",(0,r.jsx)(t.em,{children:"loaders"})," previously registered with ",(0,r.jsx)(t.a,{href:"/docs/modules/core/api-reference/register-loaders",children:(0,r.jsx)(t.code,{children:"registerLoaders"})})," will be used."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"input-types",children:"Input Types"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Data Type"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Comments"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"Response"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"Response"})," object, e.g returned by ",(0,r.jsx)(t.code,{children:"fetch"})," or ",(0,r.jsx)(t.code,{children:"fetchFile"}),"."]}),(0,r.jsxs)(t.td,{children:["Data will be streamed from the ",(0,r.jsx)(t.code,{children:"response.body"})," stream."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"AsyncIterator"})}),(0,r.jsxs)(t.td,{children:["iterator that yields promises that resolve to binary (",(0,r.jsx)(t.code,{children:"ArrayBuffer"}),") chunks or string chunks."]}),(0,r.jsx)(t.td,{})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"converted into async iterators behind the scenes.)"}),(0,r.jsx)(t.td,{}),(0,r.jsx)(t.td,{})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"Iterator"})}),(0,r.jsxs)(t.td,{children:["Iterator that yields binary chunks (",(0,r.jsx)(t.code,{children:"ArrayBuffer"}),") or string chunks"]}),(0,r.jsx)(t.td,{children:"string chunks only work for loaders that support textual input."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"Promise"})}),(0,r.jsx)(t.td,{children:"A promise that resolves to any of the other supported data types can also be supplied."}),(0,r.jsx)(t.td,{})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:["Note that many other data sources can also be parsed by first converting them to ",(0,r.jsx)(t.code,{children:"Response"})," objects, e.g. with ",(0,r.jsx)(t.code,{children:"fetchResoure"}),": http urls, data urls, ",(0,r.jsx)(t.code,{children:"ArrayBuffer"}),", ",(0,r.jsx)(t.code,{children:"String"}),", ",(0,r.jsx)(t.code,{children:"File"}),", ",(0,r.jsx)(t.code,{children:"Blob"}),", ",(0,r.jsx)(t.code,{children:"ReadableStream"})," etc."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>c});var r=s(96540);const a={},n=r.createContext(a);function o(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);