import {Source, PMTiles, Header, TileType} from 'pmtiles';
// import {Source, RangeResponse, PMTiles, Header, Compression, TileType} from 'pmtiles';

// export enum Compression {
//   Unknown = 0,
//   None = 1,
//   Gzip = 2,
//   Brotli = 3,
//   Zstd = 4,
// }

export interface PMTilesMetadata {
  format: 'pmtiles';
  /** Version of pm tiles format used by this tileset */
  version: number;
  /** MIME type for tile contents. Unknown tile types will return 'application/octet-stream */
  mimeType:
    | 'application/vnd.mapbox-vector-tile'
    | 'image/png'
    | 'image/jpeg'
    | 'image/webp'
    | 'image/avif'
    | 'application/octet-stream';
  /** The original numeric tile type constant specified in the PMTiles tileset */
  tileType: TileType;
  /** Minimal zoom level of tiles in this tileset */
  minZoom: number;
  /** Maximal zoom level of tiles in this tileset */
  maxZoom: number;
  /** Bounding box of tiles in this tileset `[[w, s], [e, n]]`  */
  boundingBox: [min: [x: number, y: number], max: [x: number, y: number]];
  /** Center long, lat of this tileset */
  center: [number, number];
  /** Center zoom level of this tileset */
  centerZoom: number;
  /** Cache tag */
  etag?: string;
  /** Current assumption is that this is a tileJSON style metadata generated by e.g. tippecanoe */
  jsonMetadata?: Record<string, unknown>;
  /** PMTiles format specific header */
  formatHeader?: Header;
}

export type ParsePMTilesOptions = {
  tileZxy?: [number, number, number];
};

export async function loadPMTilesHeader(source: Source): Promise<PMTilesMetadata> {
  const pmTiles = new PMTiles(source);
  const header = await pmTiles.getHeader();
  const metadata = await pmTiles.getMetadata();
  return parsePMTilesHeader(header, metadata);
}

export async function loadPMTile(
  source: Source,
  options: ParsePMTilesOptions
): Promise<ArrayBuffer | undefined> {
  const pmTiles = new PMTiles(source);
  if (!options.tileZxy) {
    throw new Error('tile zxy missing');
  }
  const [z, x, y] = options.tileZxy;
  const tile = await pmTiles.getZxy(z, x, y);
  return tile?.data;
}

export async function parsePMTilesHeader(
  header: Header,
  metadata: unknown
): Promise<PMTilesMetadata> {
  return {
    format: 'pmtiles',
    version: header.specVersion,
    mimeType: decodeTileType(header.tileType),
    tileType: header.tileType,
    minZoom: header.minZoom,
    maxZoom: header.maxZoom,
    boundingBox: [
      [header.minLon, header.minLat],
      [header.maxLon, header.maxLat]
    ],
    center: [header.centerLon, header.centerLat],
    centerZoom: header.centerZoom,
    etag: header.etag,
    formatHeader: header,
    jsonMetadata: metadata as Record<string, unknown>
  };
}

/** Extract a MIME type for tiles from vector tile header  */
function decodeTileType(
  tileType: TileType
):
  | 'application/vnd.mapbox-vector-tile'
  | 'image/png'
  | 'image/jpeg'
  | 'image/webp'
  | 'image/avif'
  | 'application/octet-stream' {
  switch (tileType) {
    case TileType.Mvt:
      return 'application/vnd.mapbox-vector-tile';
    case TileType.Png:
      return 'image/png';
    case TileType.Jpeg:
      return 'image/jpeg';
    case TileType.Webp:
      return 'image/webp';
    case TileType.Avif:
      return 'image/avif';
    default:
      return 'application/octet-stream';
  }
}
