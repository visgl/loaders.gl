import test from 'tape-promise/tape';
import {PARQUET_CODECS} from '@loaders.gl/parquet/parquetjs/codecs';
import {assertArrayEqualEpsilon} from '../test-utils/assertions';

test('ParquetCodec::PLAIN#should encode BOOLEAN values', assert => {
  const buf = PARQUET_CODECS.PLAIN.encodeValues(
      'BOOLEAN',
      [true, false, true, true, false, true, false, false]);

  assert.deepEqual(buf, new Buffer([0x2d])); // b101101
  assert.end();
});

test('ParquetCodec::PLAIN#should decode BOOLEAN values', assert => {
  const buf = {
    offset: 0,
    buffer: new Buffer([0x2d]) // b101101
  };

  const vals = PARQUET_CODECS.PLAIN.decodeValues('BOOLEAN', buf, 8, {});
  assert.equal(buf.offset, 1);
  assert.deepEqual(vals, [true, false, true, true, false, true, false, false]);
  assert.end();
});

test('ParquetCodec::PLAIN#should encode INT32 values', assert => {
  const buf = PARQUET_CODECS.PLAIN.encodeValues(
      'INT32',
      [42, 17, 23, -1, -2, -3, 9000, 420]);

  assert.deepEqual(buf, new Buffer([
    0x2a, 0x00, 0x00, 0x00, // 42
    0x11, 0x00, 0x00, 0x00, // 17
    0x17, 0x00, 0x00, 0x00, // 23
    0xff, 0xff, 0xff, 0xff, // -1
    0xfe, 0xff, 0xff, 0xff, // -2
    0xfd, 0xff, 0xff, 0xff, // -3
    0x28, 0x23, 0x00, 0x00, // 9000
    0xa4, 0x01, 0x00, 0x00  // 420
  ]));
  assert.end();
});

test('ParquetCodec::PLAIN#should decode INT32 values', assert => {
  const buf = {
    offset: 0,
    buffer: new Buffer([
      0x2a, 0x00, 0x00, 0x00, // 42
      0x11, 0x00, 0x00, 0x00, // 17
      0x17, 0x00, 0x00, 0x00, // 23
      0xff, 0xff, 0xff, 0xff, // -1
      0xfe, 0xff, 0xff, 0xff, // -2
      0xfd, 0xff, 0xff, 0xff, // -3
      0x28, 0x23, 0x00, 0x00, // 9000
      0xa4, 0x01, 0x00, 0x00  // 420
    ])
  };

  const vals = PARQUET_CODECS.PLAIN.decodeValues('INT32', buf, 8, {});
  assert.equal(buf.offset, 32);
  assert.deepEqual(vals, [42, 17, 23, -1, -2, -3, 9000, 420]);
  assert.end();
});

test('ParquetCodec::PLAIN#should encode INT64 values', assert => {
  const buf = PARQUET_CODECS.PLAIN.encodeValues(
      'INT64',
      [42, 17, 23, -1, -2, -3, 9000, 420]);

  assert.deepEqual(buf, new Buffer([
    0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
    0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 17
    0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 23
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -1
    0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -2
    0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -3
    0x28, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 9000
    0xa4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 420
  ]));
  assert.end();
});

test('ParquetCodec::PLAIN#should decode INT64 values', assert => {
  const buf = {
    offset: 0,
    buffer: new Buffer([
      0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
      0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 17
      0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 23
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -1
      0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -2
      0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -3
      0x28, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 9000
      0xa4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 420
    ])
  };

  const vals = PARQUET_CODECS.PLAIN.decodeValues('INT64', buf, 8, {});
  assert.equal(buf.offset, 64);
  assert.deepEqual(vals, [42, 17, 23, -1, -2, -3, 9000, 420]);
  assert.end();
});

test('ParquetCodec::PLAIN#should encode INT96 values', assert => {
  const buf = PARQUET_CODECS.PLAIN.encodeValues(
      'INT96',
      [42, 17, 23, -1, -2, -3, 9000, 420]);

  assert.deepEqual(buf, new Buffer([
    0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
    0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 17
    0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 23
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -1
    0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -2
    0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -3
    0x28, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 9000
    0xa4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 420
  ]));
  assert.end();
});

test('ParquetCodec::PLAIN#should decode INT96 values', assert => {
  const buf = {
    offset: 0,
    buffer: new Buffer([
      0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
      0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 17
      0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 23
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -1
      0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -2
      0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -3
      0x28, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 9000
      0xa4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 420
    ])
  };

  const vals = PARQUET_CODECS.PLAIN.decodeValues('INT96', buf, 8, {});
  assert.equal(buf.offset, 96);
  assert.deepEqual(vals, [42, 17, 23, -1, -2, -3, 9000, 420]);
  assert.end();
});

test('ParquetCodec::PLAIN#should encode FLOAT values', assert => {
  const buf = PARQUET_CODECS.PLAIN.encodeValues(
      'FLOAT',
      [42.0, 23.5, 17.0, 4.20, 9000]);

  assert.deepEqual(buf, new Buffer([
    0x00, 0x00, 0x28, 0x42, // 42.0
    0x00, 0x00, 0xbc, 0x41, // 23.5
    0x00, 0x00, 0x88, 0x41, // 17.0
    0x66, 0x66, 0x86, 0x40, // 4.20
    0x00, 0xa0, 0x0c, 0x46  // 9000
  ]));
  assert.end();
});

test('ParquetCodec::PLAIN#should decode FLOAT values', assert => {
  const buf = {
    offset: 0,
    buffer: new Buffer([
      0x00, 0x00, 0x28, 0x42, // 42.0
      0x00, 0x00, 0xbc, 0x41, // 23.5
      0x00, 0x00, 0x88, 0x41, // 17.0
      0x66, 0x66, 0x86, 0x40, // 4.20
      0x00, 0xa0, 0x0c, 0x46  // 9000
    ])
  };

  const vals = PARQUET_CODECS.PLAIN.decodeValues('FLOAT', buf, 5, {});
  assert.equal(buf.offset, 20);
  assertArrayEqualEpsilon(assert, vals, [42.0, 23.5, 17.0, 4.20, 9000]);
  assert.end();
});

test('ParquetCodec::PLAIN#should encode DOUBLE values', assert => {
  const buf = PARQUET_CODECS.PLAIN.encodeValues(
      'DOUBLE',
      [42.0, 23.5, 17.0, 4.20, 9000]);

  assert.deepEqual(buf, new Buffer([
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x40, // 42.0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x37, 0x40, // 23.5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x40, // 17.0
    0xcd, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x10, 0x40, // 4.20
    0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xc1, 0x40  // 9000
  ]));
  assert.end();
});

test('ParquetCodec::PLAIN#should decode DOUBLE values', assert => {
  const buf = {
    offset: 0,
    buffer: new Buffer([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x40, // 42.0
      0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x37, 0x40, // 23.5
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x40, // 17.0
      0xcd, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x10, 0x40, // 4.20
      0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xc1, 0x40  // 9000
    ])
  };

  const vals = PARQUET_CODECS.PLAIN.decodeValues('DOUBLE', buf, 5, {});
  assert.equal(buf.offset, 40);
  assertArrayEqualEpsilon(assert, vals, [42.0, 23.5, 17.0, 4.20, 9000]);
  assert.end();
});

test('ParquetCodec::PLAIN#should encode BYTE_ARRAY values', assert => {
  const buf = PARQUET_CODECS.PLAIN.encodeValues(
      'BYTE_ARRAY',
      ['one', new Buffer([0xde, 0xad, 0xbe, 0xef]), 'three']);

  assert.deepEqual(buf, new Buffer([
    0x03, 0x00, 0x00, 0x00,       // (3)
    0x6f, 0x6e, 0x65,             // 'one'
    0x04, 0x00, 0x00, 0x00,       // (4)
    0xde, 0xad, 0xbe, 0xef,       // 0xdeadbeef
    0x05, 0x00, 0x00, 0x00,       // (5)
    0x74, 0x68, 0x72, 0x65, 0x65  // 'three'
  ]));
  assert.end();
});

test('ParquetCodec::PLAIN#should decode BYTE_ARRAY values', assert => {
  const buf = {
    offset: 0,
    buffer: new Buffer([
      0x03, 0x00, 0x00, 0x00,       // (3)
      0x6f, 0x6e, 0x65,             // 'one'
      0x04, 0x00, 0x00, 0x00,       // (4)
      0xde, 0xad, 0xbe, 0xef,       // 0xdeadbeef
      0x05, 0x00, 0x00, 0x00,       // (5)
      0x74, 0x68, 0x72, 0x65, 0x65  // 'three'
    ])
  };

  const vals = PARQUET_CODECS.PLAIN.decodeValues('BYTE_ARRAY', buf, 3, {});
  assert.equal(buf.offset, 24);
  assert.deepEqual(vals, [
    Buffer.from('one'),
    new Buffer([0xde, 0xad, 0xbe, 0xef]),
    Buffer.from('three')
  ]);
  assert.end();
});

test('ParquetCodec::PLAIN#should encode FIXED_LEN_BYTE_ARRAY values', assert => {
  const buf = PARQUET_CODECS.PLAIN.encodeValues(
      'FIXED_LEN_BYTE_ARRAY',
      ['oneoo', new Buffer([0xde, 0xad, 0xbe, 0xef, 0x42]), 'three'], {
        typeLength: 5
      });

  assert.deepEqual(buf, new Buffer([
    0x6f, 0x6e, 0x65, 0x6f, 0x6f, // 'oneoo'
    0xde, 0xad, 0xbe, 0xef, 0x42, // 0xdeadbeef42
    0x74, 0x68, 0x72, 0x65, 0x65  // 'three'
  ]));
  assert.end();
});

test('ParquetCodec::PLAIN#should decode FIXED_LEN_BYTE_ARRAY values', assert => {
  const buf = {
    offset: 0,
    buffer: new Buffer([
      0x6f, 0x6e, 0x65, 0x6f, 0x6f, // 'oneoo'
      0xde, 0xad, 0xbe, 0xef, 0x42, // 0xdeadbeef42
      0x74, 0x68, 0x72, 0x65, 0x65  // 'three'
    ])
  };

  const vals = PARQUET_CODECS.PLAIN.decodeValues('FIXED_LEN_BYTE_ARRAY', buf, 3, {
    typeLength: 5
  });

  assert.equal(buf.offset, 15);
  assert.deepEqual(vals, [
    Buffer.from('oneoo'),
    new Buffer([0xde, 0xad, 0xbe, 0xef, 0x42]),
    Buffer.from('three')
  ]);
  assert.end();
});
