{"version":3,"sources":["webpack:///../examples/gltf/app.js","webpack:///./templates/example-gltf.jsx","webpack:///./src/components/animation-loop-runner.jsx","webpack:///./src/components/info-panel.jsx","webpack:///../modules/gltf/src/gltf/unpack-gltf-buffers.js","webpack:///../modules/gltf/src/packed-json/unpack-binary-json.js","webpack:///../modules/gltf/src/glb/parse-glb.js","webpack:///../modules/gltf/src/gltf/gltf-type-utils.js","webpack:///../modules/gltf/src/deprecated/glb-parser.js","webpack:///../modules/gltf/src/utils/assert.js","webpack:///../modules/gltf/src/gltf/gltf-utils.js","webpack:///../modules/gltf/src/gltf/gltf-post-processor.js","webpack:///../modules/gltf/src/gltf/gltf-attribute-utils.js","webpack:///../modules/gltf/src/gltf/gltf-parser.js","webpack:///../modules/gltf/src/gltf/gltf-constants.js","webpack:///../modules/gltf/src/gltf-loader.js"],"names":["CUBE_FACE_TO_DIRECTION","_CUBE_FACE_TO_DIRECTI","GL","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_Z","GLTF_ENV_BASE_URL","GLTF_BASE_URL","GLTF_MODEL_INDEX","GLTF_DEFAULT_MODEL","LIGHT_SOURCES","default","directionalLights","color","direction","intensity","ambient","ambientLight","directional1","directional3","point1far","pointLights","position","attenuation","point1near","DEFAULT_OPTIONS","pbrDebug","imageBasedLightingEnvironment","lights","loadGLTF","_callee","urlOrPromise","gl","options","loadResult","gltf","scenes","animator","regenerator_default","a","wrap","_context","prev","next","load","gltf_scenegraph_loader","Object","assign","sent","node","_ref7","worldMatrix","log","abrupt","stop","AppAnimationLoop","_temp","_this","_ref2","_ref2$modelFile","modelFile","_ref2$initialZoom","initialZoom","_AnimationLoop","call","this","glOptions","webgl2","alpha","mouse","lastX","lastY","translate","rotation","rotationStart","u_ScaleDiffBaseMR","u_ScaleFGDSpec","onInitialize","bind","assertThisInitialized_default","onRender","getInfo","initializeEventHandling","_this2","canvas","e","clientX","clientY","buttons","dX","dY","_deleteScenes","Promise","resolve","reader","window","FileReader","ev","result","_this3","_ref3","setParameters","depthTest","blend","loadOptions","environment","gltf_environment","brdfLutUrl","getTexUrl","type","dir","mipLevel","modelSelector","document","modelUrl","value","event","modelUrl2","fetch","then","res","json","loadModelList","models","modelDropdown","VARIANTS","_ref","name","variants","variant","find","v","option","addModelsToDropdown","showSelector","split","map","x","parseFloat","lightSelector","light","iblSelector","_updateLightSettings","_rebuildModel","meshes","forEach","mesh","_mesh","nodes","_node","bufferViews","bufferView","lumaBuffers","createGLTFObjects","scene","delete","lumaStats","_ref4","count","applyLight","model","lightSources","_this4","_ref5","time","aspect","viewMatrix","projectionMatrix","clear","depth","_this$rotation","pitch","roll","cameraPos","Math","uView","matrix4","Array","rotateX","rotateY","uProjection","perspective","fov","radians","near","far","length","animate","success","traverse","_ref6","u_MVPMatrix","multiplyRight","draw","uniforms","u_Camera","u_ModelMatrix","u_NormalMatrix","invert","transpose","parameters","AnimationLoop","website","animationLoop","app_AppAnimationLoop","infoDiv","Example","render","react_default","createElement","animation_loop_runner","React","Component","global","navigator","STYLES","EXAMPLE_NOT_SUPPPORTED","display","justifyContent","alignItems","height","STAT_STYLES","fontSize","zIndex","background","padding","opacity","propTypes","example","PropTypes","object","string","AnimationLoopRunner","props","_Component","componentDidMount","showStats","_setDisplay","_luma_gl_addons__WEBPACK_IMPORTED_MODULE_5__","path","setPathPrefix","RAW_GITHUB","start","_showStats","componentWillUnmount","timeWidget","_probe_gl_stats_widget__WEBPACK_IMPORTED_MODULE_6__","stats","container","refs","renderStats","title","css","header","fontWeight","framesPerUpdate","formatters","CPU Time","GPU Time","Frame Rate","resetOnUpdate","memWidget","memStats","GPU Memory","Buffer Memory","Renderbuffer Memory","Texture Memory","animationFrame","updateStats","_stopStats","_this$props","_this$props$panel","panel","sourceLink","isSupported","altText","getAltText","react__WEBPACK_IMPORTED_MODULE_2___default","style","controls","className","width","border","ref","id","_info_panel__WEBPACK_IMPORTED_MODULE_7__","InfoPanel","tabIndex","dangerouslySetInnerHTML","__html","href","target","PureComponent","TYPE_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","COMPONENT_TYPE_BYTE_SIZE","5120","5121","5122","5123","5125","5126","COMPONENT_TYPE_ARRAY","Int8Array","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","unpackGLBBuffers","arrayBuffer","binaryByteOffset","byteOffset","binaryBuffer","ArrayBuffer","sourceArray","binaryArray","i","getArrayBufferAtOffset","assert","accessors","unpackAccessors","images","unpackImages","accessorBuffers","accessor","_getArrayTypeAndLengt","getArrayTypeAndLength","ArrayType","array","imageBuffers","image","byteLength","componentType","components","bytesPerComponent","unpackJsonArrays","buffers","unpackJsonArraysRecursive","topJson","buffer","pointer","matches","index","parseInt","_index","parseJSONPointer","field","console","decodeJSONPointer","element","newObject","key","MAGIC_glTF","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","LE","BE","parseGLBSync","glb","dataView","DataView","String","getMagicString","_options2$magic","magic","version","isJSONChunk","jsonChunkFormat","jsonChunk","jsonChunkByteOffset","jsonChunkLength","jsonText","text_encoding","textDecoder","JSON","binChunkStart","padTo4Bytes","hasBinChunk","isBinChunk","TYPES","ARRAY_TO_COMPONENT_TYPE","Map","getAccessorTypeFromSize","size","getComponentTypeFromArray","typedArray","constructor","Error","ATTRIBUTE_TYPE_TO_COMPONENTS","ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","GLBParser","isGLB","_options$magic","magic1","parse","parseSync","glbArrayBuffer","packedJson","binChunkByteOffset","unpackedBuffers","unpackGLTFBuffers","unpackBinaryJson","getApplicationData","getJSON","getArrayBuffer","getBinaryByteOffset","getBufferView","glTFBufferView","getBuffer","glTFAccessor","condition","message","getImageData","glTFImage","mimeType","getImage","arrayBufferView","blob","Blob","imageUrl","self","webkitURL","urlCreator","img","Image","getImageAsync","getFullUri","uri","base","COMPONENTS","BYTES","SAMPLER_PARAMETER_GLTF_TO_GL","magFilter","minFilter","wrapS","wrapT","GLTFPostProcessor","postProcess","glbParser","_resolveToTree","bufView","_resolveBufferView","_resolveImage","sampler","_resolveSampler","texture","_resolveTexture","_resolveAccessor","material","_resolveMaterial","_resolveMesh","_resolveNode","skin","_resolveSkin","_resolveScene","undefined","_process_extension_KHR_lights_punctual","getScene","_get","getNode","getSkin","getMesh","getMaterial","getAccessor","getCamera","getTexture","getSampler","child","_iterator","primitives","_isArray","isArray","_i","Symbol","iterator","done","primitive","attribute","attributes","normalTexture","occlusionTexture","emissiveTexture","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","glEnum","_enumSamplerParameter","_options$createImages","createImages","data","_resolveCamera","camera","orthographic","extension","KHR_lights_punctual","_removeExtension","_iterator2","_isArray2","_i2","nodeExtension","extensionsRequired","_removeStringFromArray","extensionName","extensionsUsed","extensions","found","getGLTFAccessor","gltfAttributeName","_getAccessorData","attributeName","convertTypedArrays","toTypedArray","getAccessorData","fetchLinkedResources","fetch_file","decompress","DracoLoader","GLTFParser","_loadLinkedAssets","_decompressMeshes","gltf_post_processor_GLTFPostProcessor","postProcessor","glb_parser_GLBParser","getExtraData","extras","getExtension","isExtension","getUsedExtensions","getRequiredExtension","getRequiredExtensions","_callee2","_context2","all","_loadBuffer","_callee3","response","_context3","_decompressKhronosDracoPrimitive","_decompressUberDracoPrimitive","compressedMesh","_getBufferViewArray","decodedData","getGLTFAccessors","indices","bufferViewIndex","__webpack_exports__","text","binary","gltf_parser_GLTFParser"],"mappings":"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","file":"component---templates-example-gltf-jsx-09c6310dac404c64e70c.js","sourcesContent":["/* eslint-disable camelcase */\n/* global document, window */\nimport {load} from '@loaders.gl/core';\nimport GL from '@luma.gl/constants';\nimport {AnimationLoop, setParameters, clear, log, lumaStats} from '@luma.gl/core';\nimport {GLTFScenegraphLoader, createGLTFObjects, GLTFEnvironment} from '@luma.gl/addons';\nimport {Matrix4, radians} from 'math.gl';\n\nconst CUBE_FACE_TO_DIRECTION = {\n  [GL.TEXTURE_CUBE_MAP_POSITIVE_X]: 'right',\n  [GL.TEXTURE_CUBE_MAP_NEGATIVE_X]: 'left',\n  [GL.TEXTURE_CUBE_MAP_POSITIVE_Y]: 'top',\n  [GL.TEXTURE_CUBE_MAP_NEGATIVE_Y]: 'bottom',\n  [GL.TEXTURE_CUBE_MAP_POSITIVE_Z]: 'front',\n  [GL.TEXTURE_CUBE_MAP_NEGATIVE_Z]: 'back'\n};\n\nconst GLTF_ENV_BASE_URL =\n  'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/luma.gl/examples/gltf/';\n\nconst GLTF_BASE_URL =\n  'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/';\nconst GLTF_MODEL_INDEX = `${GLTF_BASE_URL}model-index.json`;\n\nconst GLTF_DEFAULT_MODEL = 'DamagedHelmet/glTF-Binary/DamagedHelmet.glb';\n\nfunction loadModelList() {\n  return window.fetch(GLTF_MODEL_INDEX).then(res => res.json());\n}\n\nfunction addModelsToDropdown(models, modelDropdown) {\n  if (!modelDropdown) {\n    return;\n  }\n\n  const VARIANTS = ['glTF-Binary', 'glTF-Embedded', 'glTF'];\n\n  models.forEach(({name, variants}) => {\n    const variant = VARIANTS.find(v => variants[v]);\n\n    const option = document.createElement('option');\n    option.text = `${name} (${variant})`;\n    option.value = `${name}/${variant}/${variants[variant]}`;\n    modelDropdown.appendChild(option);\n  });\n}\n\nconst INFO_HTML = `\n<p><b>glTF Loader</b>.</p>\n<p>Rendered using luma.gl.</p>\n<div>\n  Model<br/>\n  <select id=\"modelSelector\" style=\"border: 1px solid gray;\">\n    <option value=\"${GLTF_DEFAULT_MODEL}\">Default</option>\n  </select>\n  <br>\n</div>\n<div>\n  Show<br/>\n  <select id=\"showSelector\" style=\"border: 1px solid gray;\">\n    <option value=\"0 0 0 0 0 0 0 0\">Final Result</option>\n\n    <option value=\"0 1 0 0 0 0 0 0\">Base Color</option>\n    <option value=\"0 0 1 0 0 0 0 0\">Metallic</option>\n    <option value=\"0 0 0 1 0 0 0 0\">Roughness</option>\n    <option value=\"1 0 0 0 0 0 0 0\">Diffuse</option>\n\n    <option value=\"0 0 0 0 1 0 0 0\">Specular Reflection</option>\n    <option value=\"0 0 0 0 0 1 0 0\">Geometric Occlusion</option>\n    <option value=\"0 0 0 0 0 0 1 0\">Microfacet Distribution</option>\n    <option value=\"0 0 0 0 0 0 0 1\">Specular</option>\n  </select>\n  <br>\n</div>\n<div>\n  Regular Lights<br/>\n  <select id=\"lightSelector\" style=\"border: 1px solid gray;\">\n    <option value=\"default\">Default</option>\n    <option value=\"ambient\">Ambient Only</option>\n    <option value=\"directional1\">1x Directional (Red) + Ambient</option>\n    <option value=\"directional3\">3x Directional (RGB)</option>\n    <option value=\"point1far\">1x Point Light Far (Red) + Ambient</option>\n    <option value=\"point1near\">1x Point Light Near (Red) + Ambient</option>\n  </select>\n  <br>\n</div>\n<div>\n  Image-Based Light<br/>\n  <select id=\"iblSelector\" style=\"border: 1px solid gray;\">\n    <option value=\"exclusive\">On (Exclusive)</option>\n    <option value=\"addition\">On (Addition to Regular)</option>\n    <option value=\"off\">Off (Only Regular)</option>\n  </select>\n  <br/>\n</div>\n<p><img src=\"https://img.shields.io/badge/WebVR-Supported-orange.svg\" /></p>\n`;\n\nconst LIGHT_SOURCES = {\n  default: {\n    directionalLights: [\n      {\n        color: [255, 255, 255],\n        direction: [0.0, 0.5, 0.5],\n        intensity: 1.0\n      }\n    ]\n  },\n  ambient: {\n    ambientLight: {\n      color: [255, 255, 255],\n      intensity: 1.0\n    }\n  },\n  directional1: {\n    directionalLights: [\n      {\n        color: [255, 0, 0],\n        direction: [1.0, 0.0, 0.0],\n        intensity: 1.0\n      }\n    ],\n    ambientLight: {\n      color: [255, 255, 255],\n      intensity: 1.0\n    }\n  },\n  directional3: {\n    directionalLights: [\n      {\n        color: [255, 0.0, 0.0],\n        direction: [1.0, 0.0, 0.0],\n        intensity: 1.0\n      },\n      {\n        color: [0.0, 0.0, 255],\n        direction: [0.0, 0.0, 1.0],\n        intensity: 1.0\n      },\n      {\n        color: [0.0, 255, 0.0],\n        direction: [0.0, 1.0, 0.0],\n        intensity: 1.0\n      }\n    ]\n  },\n  point1far: {\n    pointLights: [\n      {\n        color: [255, 0, 0],\n        position: [200.0, 0.0, 0.0],\n        attenuation: [0, 0, 0.01],\n        intensity: 1.0\n      }\n    ],\n    ambientLight: {\n      color: [255, 255, 255],\n      intensity: 1.0\n    }\n  },\n  point1near: {\n    pointLights: [\n      {\n        color: [255, 0, 0],\n        position: [10.0, 0.0, 0.0],\n        attenuation: [0, 0, 0.01],\n        intensity: 1.0\n      }\n    ],\n    ambientLight: {\n      color: [255, 255, 255],\n      intensity: 1.0\n    }\n  }\n};\n\nconst DEFAULT_OPTIONS = {\n  pbrDebug: true,\n  imageBasedLightingEnvironment: null,\n  lights: false\n};\n\nasync function loadGLTF(urlOrPromise, gl, options) {\n  const loadResult = await load(urlOrPromise, GLTFScenegraphLoader, {\n    ...options,\n    gl\n    // DracoLoader\n  });\n  const {gltf, scenes, animator} = loadResult;\n  scenes[0].traverse((node, {worldMatrix}) => log.info(4, 'Using model: ', node)());\n  return {scenes, animator, gltf};\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  constructor({modelFile = null, initialZoom = 2} = {}) {\n    super();\n\n    this.scenes = [];\n    this.animator = null;\n    this.gl = null;\n    this.modelFile = modelFile;\n\n    this.glOptions = {\n      // Use to test gltf with webgl 1.0 and 2.0\n      webgl2: true,\n      // alpha causes issues with some glTF demos\n      alpha: false\n    };\n\n    this.mouse = {\n      lastX: 0,\n      lastY: 0\n    };\n\n    this.translate = initialZoom;\n    this.rotation = [0, 0];\n    this.rotationStart = [0, 0];\n\n    this.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n    this.u_ScaleFGDSpec = [0, 0, 0, 0];\n\n    this.onInitialize = this.onInitialize.bind(this);\n    this.onRender = this.onRender.bind(this);\n  }\n\n  initializeEventHandling(canvas) {\n    canvas.onwheel = e => {\n      this.translate += e.deltaY / 10;\n      if (this.translate < 0.5) {\n        this.translate = 0.5;\n      }\n      e.preventDefault();\n    };\n\n    canvas.onpointerdown = e => {\n      this.mouse.lastX = e.clientX;\n      this.mouse.lastY = e.clientY;\n\n      this.rotationStart[0] = this.rotation[0];\n      this.rotationStart[1] = this.rotation[1];\n\n      canvas.setPointerCapture(e.pointerId);\n      e.preventDefault();\n    };\n\n    canvas.onpointermove = e => {\n      if (e.buttons) {\n        const dX = e.clientX - this.mouse.lastX;\n        const dY = e.clientY - this.mouse.lastY;\n\n        this.rotation[0] = this.rotationStart[0] + dY / 100;\n        this.rotation[1] = this.rotationStart[1] + dX / 100;\n      }\n    };\n\n    canvas.ondragover = e => {\n      e.dataTransfer.dropEffect = 'link';\n      e.preventDefault();\n    };\n\n    canvas.ondrop = e => {\n      e.preventDefault();\n      if (e.dataTransfer.files && e.dataTransfer.files.length === 1) {\n        this._deleteScenes();\n        const readPromise = new Promise(resolve => {\n          const reader = new window.FileReader();\n          reader.onload = ev => resolve(ev.target.result);\n          reader.readAsArrayBuffer(e.dataTransfer.files[0]);\n        });\n\n        loadGLTF(readPromise, this.gl, this.loadOptions).then(result =>\n          Object.assign(this, result)\n        );\n      }\n    };\n  }\n\n  onInitialize({gl, canvas}) {\n    setParameters(gl, {\n      depthTest: true,\n      blend: false\n    });\n\n    this.loadOptions = Object.assign({}, DEFAULT_OPTIONS);\n    this.environment = new GLTFEnvironment(gl, {\n      brdfLutUrl: `${GLTF_ENV_BASE_URL}/brdfLUT.png`,\n      getTexUrl: (type, dir, mipLevel) =>\n        `${GLTF_ENV_BASE_URL}/papermill/${type}/${type}_${\n          CUBE_FACE_TO_DIRECTION[dir]\n        }_${mipLevel}.jpg`\n    });\n    this.loadOptions.imageBasedLightingEnvironment = this.environment;\n\n    this.gl = gl;\n    if (this.modelFile) {\n      // options for unit testing\n      const options = {\n        pbrDebug: false,\n        imageBasedLightingEnvironment: null,\n        lights: true\n      };\n      loadGLTF(this.modelFile, this.gl, options).then(result => Object.assign(this, result));\n    } else {\n      const modelSelector = document.getElementById('modelSelector');\n      const modelUrl = (modelSelector && modelSelector.value) || GLTF_DEFAULT_MODEL;\n      loadGLTF(GLTF_BASE_URL + modelUrl, this.gl, this.loadOptions).then(result =>\n        Object.assign(this, result)\n      );\n\n      if (modelSelector) {\n        modelSelector.onchange = event => {\n          this._deleteScenes();\n          const modelUrl2 = (modelSelector && modelSelector.value) || GLTF_DEFAULT_MODEL;\n          loadGLTF(GLTF_BASE_URL + modelUrl2, this.gl, this.loadOptions).then(result =>\n            Object.assign(this, result)\n          );\n        };\n      }\n\n      loadModelList().then(models => addModelsToDropdown(models, modelSelector));\n    }\n\n    const showSelector = document.getElementById('showSelector');\n    if (showSelector) {\n      showSelector.onchange = event => {\n        const value = showSelector.value.split(' ').map(x => parseFloat(x));\n        this.u_ScaleDiffBaseMR = value.slice(0, 4);\n        this.u_ScaleFGDSpec = value.slice(4);\n      };\n    }\n\n    const lightSelector = document.getElementById('lightSelector');\n    if (lightSelector) {\n      lightSelector.onchange = event => {\n        this.light = lightSelector.value;\n      };\n    }\n\n    const iblSelector = document.getElementById('iblSelector');\n    if (iblSelector) {\n      iblSelector.onchange = event => {\n        this._updateLightSettings(iblSelector.value);\n        this._rebuildModel();\n      };\n    }\n\n    this.initializeEventHandling(canvas);\n  }\n\n  _updateLightSettings(value) {\n    switch (value) {\n      case 'exclusive':\n        Object.assign(this.loadOptions, {\n          imageBasedLightingEnvironment: this.environment,\n          lights: false\n        });\n        break;\n\n      case 'addition':\n        Object.assign(this.loadOptions, {\n          imageBasedLightingEnvironment: this.environment,\n          lights: true\n        });\n        break;\n\n      case 'off':\n        Object.assign(this.loadOptions, {\n          imageBasedLightingEnvironment: null,\n          lights: true\n        });\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  _rebuildModel() {\n    // Clean and regenerate model so we have new \"#defines\"\n    // TODO: Find better way to do this\n    (this.gltf.meshes || []).forEach(mesh => delete mesh._mesh);\n    (this.gltf.nodes || []).forEach(node => delete node._node);\n    (this.gltf.bufferViews || []).forEach(bufferView => delete bufferView.lumaBuffers);\n\n    this._deleteScenes();\n    Object.assign(this, createGLTFObjects(this.gl, this.gltf, this.loadOptions));\n  }\n\n  _deleteScenes() {\n    this.scenes.forEach(scene => scene.delete());\n    this.scenes = [];\n\n    lumaStats.get('Resource Counts').forEach(({name, count}) => {\n      log.info(3, `${name}: ${count}`)();\n    });\n  }\n\n  applyLight(model) {\n    // TODO: only do this when light changes\n    model.updateModuleSettings({\n      lightSources: LIGHT_SOURCES[this.light || 'default']\n    });\n  }\n\n  onRender({gl, time, aspect, viewMatrix, projectionMatrix}) {\n    clear(gl, {color: [0.2, 0.2, 0.2, 1.0], depth: true});\n\n    const [pitch, roll] = this.rotation;\n    const cameraPos = [\n      -this.translate * Math.sin(roll) * Math.cos(-pitch),\n      -this.translate * Math.sin(-pitch),\n      this.translate * Math.cos(roll) * Math.cos(-pitch)\n    ];\n\n    // TODO: find how to avoid using Array.from() to convert TypedArray to regular array\n    const uView = new Matrix4(viewMatrix ? Array.from(viewMatrix) : null)\n      .translate([0, 0, -this.translate])\n      .rotateX(pitch)\n      .rotateY(roll);\n\n    const uProjection = projectionMatrix\n      ? new Matrix4(Array.from(projectionMatrix))\n      : new Matrix4().perspective({fov: radians(40), aspect, near: 0.1, far: 9000});\n\n    if (!this.scenes.length) return false;\n\n    if (this.animator) {\n      this.animator.animate(time);\n    }\n\n    let success = true;\n\n    this.scenes[0].traverse((model, {worldMatrix}) => {\n      // In glTF, meshes and primitives do no have their own matrix.\n      const u_MVPMatrix = new Matrix4(uProjection).multiplyRight(uView).multiplyRight(worldMatrix);\n      this.applyLight(model);\n      success =\n        success &&\n        model.draw({\n          uniforms: {\n            u_Camera: cameraPos,\n            u_MVPMatrix,\n            u_ModelMatrix: worldMatrix,\n            u_NormalMatrix: new Matrix4(worldMatrix).invert().transpose(),\n\n            u_ScaleDiffBaseMR: this.u_ScaleDiffBaseMR,\n            u_ScaleFGDSpec: this.u_ScaleFGDSpec\n          },\n          parameters: model.props.parameters\n        });\n    });\n\n    return success;\n  }\n}\n\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n\n  const infoDiv = document.createElement('div');\n  infoDiv.innerHTML = animationLoop.getInfo();\n  document.body.appendChild(infoDiv);\n}\n","import React from 'react';\n\nimport AnimationLoopRunner from '../src/components/animation-loop-runner';\nimport AnimationLoop from '../../examples/gltf/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopRunner AnimationLoop={AnimationLoop} />\n    );\n  }\n}\n","import React, {Component} from 'react'; // eslint-disable-line\nimport PropTypes from 'prop-types';\nimport {lumaStats, setPathPrefix} from '@luma.gl/core';\nimport {VRDisplay} from '@luma.gl/addons';\nimport StatsWidget from '@probe.gl/stats-widget';\n\nimport InfoPanel from './info-panel';\n\n// WORKAROUND FOR luma.gl VRDisplay\nif (typeof global !== 'undefined' && !global.navigator) {\n  global.navigator = {};\n}\n\nif (typeof window !== 'undefined') {\n  window.website = true;\n}\n\nconst STYLES = {\n  EXAMPLE_NOT_SUPPPORTED: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    height: '100vh'\n  }\n};\n\nconst STAT_STYLES = {\n  position: 'fixed',\n  fontSize: '12px',\n  zIndex: 10000,\n  color: '#fff',\n  background: '#000',\n  padding: '8px',\n  opacity: 0.8\n};\n\nconst propTypes = {\n  example: PropTypes.object,\n  canvas: PropTypes.string\n};\n\nconst defaultProps = {\n  canvas: 'example-canvas'\n};\n\nconst DEFAULT_ALT_TEXT = 'THIS EXAMPLE IS NOT SUPPORTED';\n\nexport default class AnimationLoopRunner extends Component {\n  constructor(props) {\n    super(props);\n    const {AnimationLoop} = this.props;\n    this.animationLoop = new AnimationLoop();\n  }\n\n  componentDidMount() {\n    const {showStats} = this.props;\n\n    this.animationLoop._setDisplay(new VRDisplay());\n\n    // Ensure the example can find its images\n    // TODO - ideally ocular-gatsby should extract images from example source?\n    const {path} = this.props;\n    if (path) {\n      const RAW_GITHUB = 'https://raw.githubusercontent.com/uber/loaders.gl/master';\n      setPathPrefix(`${RAW_GITHUB}/${path}`);\n    }\n\n    // Start the actual example\n    this.animationLoop.start(this.props);\n\n    // animationLoop.stats.reset();\n\n    if (showStats) {\n      this._showStats(this.animationLoop);\n    }\n  }\n\n  componentWillUnmount() {\n    this.animationLoop.stop(this.props);\n    this.animationLoop.delete();\n    this.animationLoop = null;\n    // this._stopStats();\n  }\n\n  _showStats(animationLoop) {\n    const timeWidget = new StatsWidget(animationLoop.stats, {\n      container: this.refs.renderStats,\n      title: 'Render Time',\n      css: {\n        header: {\n          fontWeight: 'bold'\n        }\n      },\n      framesPerUpdate: 60,\n      formatters: {\n        'CPU Time': 'averageTime',\n        'GPU Time': 'averageTime',\n        'Frame Rate': 'fps'\n      },\n      resetOnUpdate: {\n        'CPU Time': true,\n        'GPU Time': true,\n        'Frame Rate': true\n      }\n    });\n\n    lumaStats.get('Memory Usage').reset();\n    const memWidget = new StatsWidget(lumaStats.get('Memory Usage'), {\n      container: this.refs.memStats,\n      css: {\n        header: {\n          fontWeight: 'bold'\n        }\n      },\n      framesPerUpdate: 60,\n      formatters: {\n        'GPU Memory': 'memory',\n        'Buffer Memory': 'memory',\n        'Renderbuffer Memory': 'memory',\n        'Texture Memory': 'memory'\n      }\n    });\n\n    const updateStats = () => {\n      timeWidget.update();\n      memWidget.update();\n      this.animationFrame = window.requestAnimationFrame(updateStats);\n    };\n\n    this.animationFrame = window.requestAnimationFrame(updateStats);\n  }\n\n  _stopStats() {\n    window.cancelAnimationFrame(this.animationFrame);\n  }\n\n  render() {\n    const {name, panel = true, stats, sourceLink} = this.props;\n\n    const notSupported = this.animationLoop.isSupported && !this.animationLoop.isSupported();\n\n    if (notSupported) {\n      const altText = this.animationLoop.getAltText ? this.animationLoop.getAltText() : DEFAULT_ALT_TEXT;\n      return (\n        <div style={STYLES.EXAMPLE_NOT_SUPPPORTED}>\n          <h2> {altText} </h2>\n        </div>\n      );\n    }\n\n    // HTML is stored on the app\n    const controls = this.props.AnimationLoop.getInfo() ||\n      (this.animationLoop.getInfo && this.animationLoop.getInfo());\n\n    return (\n      <div className=\"fg\" style={{width: '100%', height: '100%', padding: 0, border: 0}}>\n        {\n          stats ?\n          <div ref=\"stats\" className=\"stats\" style={STAT_STYLES}>\n            <div ref=\"renderStats\" className=\"renderStats\"/>\n            <div ref=\"memStats\" className=\"memStats\"/>\n          </div> : null\n        }\n        <canvas\n          id={this.props.canvas}\n          style={{width: '100%', height: '100%', padding: 0, border: 0}}\n        />\n        {panel ? <InfoPanel name={name} controls={controls} sourceLink={sourceLink} /> : null}\n      </div>\n    );\n  }\n}\n\nAnimationLoopRunner.propTypes = propTypes;\nAnimationLoopRunner.defaultProps = defaultProps;\nAnimationLoopRunner.displayName = 'AnimationLoop';\n","import React, {PureComponent} from 'react';\n\nexport default class InfoPanel extends PureComponent {\n  render() {\n    const { name, controls, sourceLink} = this.props;\n\n    return (\n      <div className=\"options-panel top-right\" tabIndex=\"0\">\n        <h3>{name}</h3>\n        <div className=\"control-panel\" dangerouslySetInnerHTML={{__html: controls}} />\n\n        {sourceLink && (\n          <div className=\"source-link\">\n            <a href={sourceLink} target=\"_new\">\n              {'View Code '}\n            </a>\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n","import {assert} from '@loaders.gl/core';\n\n// TODO - use ./gltf-type-utils.js\nconst TYPE_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst COMPONENT_TYPE_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst COMPONENT_TYPE_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nexport default function unpackGLBBuffers(arrayBuffer, json, binaryByteOffset) {\n  // TODO - really inefficient, should just use the offset into the original array buffer\n  if (binaryByteOffset) {\n    arrayBuffer = getArrayBufferAtOffset(arrayBuffer, binaryByteOffset);\n  }\n\n  const bufferViews = json.bufferViews || [];\n\n  for (let i = 0; i < bufferViews.length; ++i) {\n    const bufferView = bufferViews[i];\n    assert(bufferView.byteLength >= 0);\n  }\n\n  return {\n    // TODO: delete unpackAccessors and use buffer views only?\n    accessors: unpackAccessors(arrayBuffer, bufferViews, json),\n    images: unpackImages(arrayBuffer, bufferViews, json)\n  };\n}\n\nfunction unpackAccessors(arrayBuffer, bufferViews, json) {\n  // unpack accessors\n  const accessors = json.accessors || [];\n\n  const accessorBuffers = [];\n\n  for (let i = 0; i < accessors.length; ++i) {\n    const accessor = accessors[i];\n    assert(accessor);\n\n    const bufferView = bufferViews[accessor.bufferView];\n    // Draco encoded meshes don't have bufferView in accessor\n    if (bufferView) {\n      // Create a new typed array as a view into the combined buffer\n      const {ArrayType, length} = getArrayTypeAndLength(accessor, bufferView);\n      const array = new ArrayType(arrayBuffer, bufferView.byteOffset, length);\n      // Store the metadata on the array (e.g. needed to determine number of components per element)\n      array.accessor = accessor;\n      accessorBuffers.push(array);\n    }\n  }\n\n  return accessorBuffers;\n}\n\nfunction unpackImages(arrayBuffer, bufferViews, json) {\n  // unpack images\n  const images = json.images || [];\n\n  const imageBuffers = [];\n\n  for (let i = 0; i < images.length; ++i) {\n    const image = images[i];\n    assert(image);\n\n    const bufferView = bufferViews[image.bufferView];\n    assert(bufferView);\n\n    // Create a new typed array as a view into the combined buffer\n    const array = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);\n    // Store the metadata on the array (e.g. needed to determine number of components per element)\n    array.imate = image;\n    imageBuffers.push(array);\n  }\n\n  return imageBuffers;\n}\n\n// Helper methods\n\nfunction getArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = COMPONENT_TYPE_ARRAY[accessor.componentType];\n  const components = TYPE_COMPONENTS[accessor.type];\n  const bytesPerComponent = COMPONENT_TYPE_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {ArrayType, length, byteLength};\n}\n\n// json.accessors = json.accessors || [];\n// json.bufferViews = json.bufferViews || [];\n\n// Creates a new ArrayBuffer starting at the offset, containing all remaining bytes\n// TODO - should not be needed, see above\nfunction getArrayBufferAtOffset(arrayBuffer, byteOffset) {\n  const length = arrayBuffer.byteLength - byteOffset;\n  const binaryBuffer = new ArrayBuffer(length);\n  const sourceArray = new Uint8Array(arrayBuffer);\n  const binaryArray = new Uint8Array(binaryBuffer);\n  for (let i = 0; i < length; i++) {\n    binaryArray[i] = sourceArray[byteOffset + i];\n  }\n  return binaryBuffer;\n}\n","export default function unpackJsonArrays(json, buffers, options = {}) {\n  return unpackJsonArraysRecursive(json, json, buffers, options);\n}\n\n// Recursively unpacks objects, replacing \"JSON pointers\" with typed arrays\nfunction unpackJsonArraysRecursive(json, topJson, buffers, options = {}) {\n  const object = json;\n\n  const buffer = decodeJSONPointer(object, buffers);\n  if (buffer) {\n    return buffer;\n  }\n\n  // Copy array\n  if (Array.isArray(object)) {\n    return object.map(element => unpackJsonArraysRecursive(element, topJson, buffers, options));\n  }\n\n  // Copy object\n  if (object !== null && typeof object === 'object') {\n    const newObject = {};\n    for (const key in object) {\n      newObject[key] = unpackJsonArraysRecursive(object[key], topJson, buffers, options);\n    }\n    return newObject;\n  }\n\n  return object;\n}\n\nfunction decodeJSONPointer(object, buffers) {\n  const pointer = parseJSONPointer(object);\n  if (pointer) {\n    const [field, index] = pointer;\n    const buffer = buffers[field] && buffers[field][index];\n    if (buffer) {\n      return buffer;\n    }\n    console.error(`Invalid JSON pointer ${object}: #/${field}/${index}`); // eslint-disable-line\n  }\n  return null;\n}\n\nfunction parseJSONPointer(value) {\n  if (typeof value === 'string') {\n    // Remove escape character\n    if (value.indexOf('##/') === 0) {\n      return value.slice(1);\n    }\n\n    let matches = value.match(/#\\/([a-z]+)\\/([0-9]+)/);\n    if (matches) {\n      const index = parseInt(matches[2], 10);\n      return [matches[1], index];\n    }\n\n    // Legacy: `$$$i`\n    matches = value.match(/\\$\\$\\$([0-9]+)/);\n    if (matches) {\n      const index = parseInt(matches[1], 10);\n      return ['accessors', index];\n    }\n  }\n\n  return null;\n}\n","/* eslint-disable camelcase, max-statements */\nimport {TextDecoder, padTo4Bytes, assert} from '@loaders.gl/core';\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\n\nconst LE = true; // Binary GLTF is little endian.\nconst BE = false; // Magic needs to be written as BE\n\nfunction getMagicString(dataView) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(0))}\\\n${String.fromCharCode(dataView.getUint8(1))}\\\n${String.fromCharCode(dataView.getUint8(2))}\\\n${String.fromCharCode(dataView.getUint8(3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(dataView, byteOffset = 0, options = {}) {\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n/*\nReturns {\n  // Header\n  type: String,\n  magic: number,\n  version: number,\n  byteLength: number,\n  byteOffset: number,\n  // JSON Chunk\n  json: any,\n  jsonChunkFormat: number,\n  jsonChunkByteOffset: number,\n  jsonChunkLength: number,\n  // BIN Chunk\n  hasBinChunk: boolean,\n  binChunkFormat: number,\n  binChunkByteOffset: number,\n  binChunkLength: number\n}\n*/\nexport default function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  glb.byteOffset = byteOffset; // Byte offset into the initial arrayBuffer\n\n  // GLB Header\n  glb.magic = dataView.getUint32(byteOffset + 0, BE); // Magic number (the ASCII string 'glTF').\n  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  glb.byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of generated file\n\n  glb.type = getMagicString(dataView);\n\n  // TODO - switch type checks to use strings\n  const {magic = MAGIC_glTF} = options;\n  const isMagicValid = glb.magic === MAGIC_glTF || glb.magic === magic;\n  if (!isMagicValid) {\n    console.warn(`Invalid GLB magic string ${glb.type}`); // eslint-disable-line\n  }\n\n  assert(glb.version === 2, `Invalid GLB version ${glb.version}. Only .glb v2 supported`);\n  assert(glb.byteLength > 20);\n\n  // Parse the JSON chunk\n\n  glb.jsonChunkLength = dataView.getUint32(byteOffset + 12, LE); // Byte length of json chunk\n  glb.jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE); // Chunk format as uint32\n\n  // Check JSON Chunk format (0 = Back compat)\n  const isJSONChunk = glb.jsonChunkFormat === GLB_CHUNK_TYPE_JSON || glb.jsonChunkFormat === 0;\n  assert(isJSONChunk, `JSON chunk format ${glb.jsonChunkFormat}`);\n\n  // Create a \"view\" of the binary encoded JSON data\n  glb.jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE; // First headers: 20 bytes\n  const jsonChunk = new Uint8Array(\n    arrayBuffer,\n    byteOffset + glb.jsonChunkByteOffset,\n    glb.jsonChunkLength\n  );\n\n  // Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  const binChunkStart = glb.jsonChunkByteOffset + padTo4Bytes(glb.jsonChunkLength);\n\n  // Parse and check BIN chunk header\n  // Note: BIN chunk can be optional\n  glb.hasBinChunk = binChunkStart + 8 <= glb.byteLength;\n  glb.binChunkByteOffset = 0;\n  glb.binChunkLength = 0;\n\n  if (glb.hasBinChunk) {\n    glb.binChunkLength = dataView.getUint32(byteOffset + binChunkStart + 0, LE);\n    glb.binChunkFormat = dataView.getUint32(byteOffset + binChunkStart + 4, LE);\n    const isBinChunk = glb.binChunkFormat === GLB_CHUNK_TYPE_BIN || glb.binChunkFormat === 1; // Back compat\n    assert(isBinChunk, `BIN chunk format ${glb.binChunkFormat}`);\n\n    glb.binChunkByteOffset = binChunkStart + GLB_CHUNK_HEADER_SIZE;\n  }\n\n  return byteOffset + glb.byteLength;\n}\n","// TODO - Remove: glTF constants should not be know to the GLB layer\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\n\nconst ARRAY_TO_COMPONENT_TYPE = new Map([\n  [Int8Array, 5120],\n  [Uint8Array, 5121],\n  [Int16Array, 5122],\n  [Uint16Array, 5123],\n  [Uint32Array, 5125],\n  [Float32Array, 5126]\n]);\n\nexport function getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\n\nexport function getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\n\n// glTF ACCESSOR CONSTANTS\n\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n","/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport unpackGLTFBuffers from '../gltf/unpack-gltf-buffers';\nimport unpackBinaryJson from '../packed-json/unpack-binary-json';\nimport assert from '../utils/assert';\nimport parseGLBSync, {isGLB} from '../glb/parse-glb';\n\nimport {\n  ATTRIBUTE_TYPE_TO_COMPONENTS,\n  ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE,\n  ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY\n} from '../gltf/gltf-type-utils';\n\nexport default class GLBParser {\n  static isGLB(arrayBuffer, options = {}) {\n    const dataView = new DataView(arrayBuffer);\n    const byteOffset = 0;\n    return isGLB(dataView, byteOffset);\n  }\n\n  // Return the gltf JSON and the original arrayBuffer\n  parse(arrayBuffer, options = {}) {\n    return this.parseSync(arrayBuffer, options);\n  }\n\n  parseSync(arrayBuffer, options = {}) {\n    this.glbArrayBuffer = arrayBuffer;\n\n    this.binaryByteOffset = null;\n    this.packedJson = null;\n    this.json = null;\n\n    // Only parse once\n    if (this.json === null && this.binaryByteOffset === null) {\n      const byteOffset = 0;\n\n      // Populates the supplied object (`this`) with parsed data members.\n      parseGLBSync(this, this.glbArrayBuffer, byteOffset, options);\n\n      // Backwards compat\n      this.binaryByteOffset = this.binChunkByteOffset;\n\n      // Unpack binary JSON\n      this.packedJson = this.json;\n      this.unpackedBuffers = unpackGLTFBuffers(\n        this.glbArrayBuffer,\n        this.json,\n        this.binaryByteOffset\n      );\n      this.json = unpackBinaryJson(this.json, this.unpackedBuffers);\n    }\n\n    return this;\n  }\n\n  // Returns application JSON data stored in `key`\n  getApplicationData(key) {\n    return this.json[key];\n  }\n\n  // Returns JSON envelope\n  getJSON() {\n    return this.json;\n  }\n\n  // Return binary chunk\n  getArrayBuffer() {\n    return this.glbArrayBuffer;\n  }\n\n  // Return index into binary chunk\n  getBinaryByteOffset() {\n    return this.binaryByteOffset;\n  }\n\n  // Unpacks a bufferview into a new Uint8Array that is a view into the binary chunk\n  getBufferView(glTFBufferView) {\n    const byteOffset = (glTFBufferView.byteOffset || 0) + this.binaryByteOffset;\n    return new Uint8Array(this.glbArrayBuffer, byteOffset, glTFBufferView.byteLength);\n  }\n\n  // Unpacks a glTF accessor into a new typed array that is a view into the binary chunk\n  getBuffer(glTFAccessor) {\n    // Decode the glTF accessor format\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[glTFAccessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[glTFAccessor.type];\n    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[glTFAccessor.componentType];\n    const length = glTFAccessor.count * components;\n    const byteLength = glTFAccessor.count * components * bytesPerComponent;\n\n    // Get the boundaries of the binary sub-chunk for this bufferView\n    const glTFBufferView = this.json.bufferViews[glTFAccessor.bufferView];\n    assert(byteLength >= 0 && glTFAccessor.byteOffset + byteLength <= glTFBufferView.byteLength);\n\n    const byteOffset = glTFBufferView.byteOffset + this.binaryByteOffset + glTFAccessor.byteOffset;\n    return new ArrayType(this.glbArrayBuffer, byteOffset, length);\n  }\n\n  // Unpacks an image into an HTML image\n  getImageData(glTFImage) {\n    return {\n      typedArray: this.getBufferView(glTFImage.bufferView),\n      mimeType: glTFImage.mimeType || 'image/jpeg'\n    };\n  }\n\n  getImage(glTFImage) {\n    /* global self, Blob, Image */\n    const arrayBufferView = this.getBufferView(glTFImage.bufferView);\n    const mimeType = glTFImage.mimeType || 'image/jpeg';\n    const blob = new Blob([arrayBufferView], {type: mimeType});\n    const urlCreator = self.URL || self.webkitURL;\n    const imageUrl = urlCreator.createObjectURL(blob);\n    const img = new Image();\n    img.src = imageUrl;\n    return img;\n  }\n\n  getImageAsync(glTFImage) {\n    /* global self, Blob, Image */\n    return new Promise(resolve => {\n      const arrayBufferView = this.getBufferView(glTFImage.bufferView);\n      const mimeType = glTFImage.mimeType || 'image/jpeg';\n      const blob = new Blob([arrayBufferView], {type: mimeType});\n      const urlCreator = self.URL || self.webkitURL;\n      const imageUrl = urlCreator.createObjectURL(blob);\n      const img = new Image();\n      img.onload = () => resolve(img);\n      img.src = imageUrl;\n    });\n  }\n}\n","// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'gltf/glb assertion failed.');\n  }\n}\n","export function getFullUri(uri, base) {\n  // TODO: Use better logic to handle all protocols plus not delay on data\n  const absolute = uri.startsWith('data:') || uri.startsWith('http:') || uri.startsWith('https:');\n  return absolute ? uri : base.substr(0, base.lastIndexOf('/') + 1) + uri;\n}\n","import {getFullUri} from './gltf-utils';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nexport default class GLTFPostProcessor {\n  postProcess(gltf, glbParser, options = {}) {\n    this.gltf = gltf;\n    this.glbParser = glbParser;\n\n    this._resolveToTree(options);\n    return this.gltf;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // PREPARATION STEP: CROSS-LINK INDEX RESOLUTION, ENUM LOOKUP, CONVENIENCE CALCULATIONS\n  /* eslint-disable complexity */\n  _resolveToTree(options = {}) {\n    const {gltf} = this;\n\n    (gltf.bufferViews || []).forEach((bufView, i) => this._resolveBufferView(bufView, i));\n\n    (gltf.images || []).forEach((image, i) => this._resolveImage(image, i, options));\n    (gltf.samplers || []).forEach((sampler, i) => this._resolveSampler(sampler, i));\n    (gltf.textures || []).forEach((texture, i) => this._resolveTexture(texture, i));\n\n    (gltf.accessors || []).forEach((accessor, i) => this._resolveAccessor(accessor, i));\n    (gltf.materials || []).forEach((material, i) => this._resolveMaterial(material, i));\n    (gltf.meshes || []).forEach((mesh, i) => this._resolveMesh(mesh, i));\n\n    (gltf.nodes || []).forEach((node, i) => this._resolveNode(node, i));\n\n    (gltf.skins || []).forEach((skin, i) => this._resolveSkin(skin, i));\n\n    (gltf.scenes || []).forEach((scene, i) => this._resolveScene(scene, i));\n\n    if (gltf.scene !== undefined) {\n      gltf.scene = gltf.scenes[this.gltf.scene];\n    }\n\n    // EXTENSIONS\n    this._process_extension_KHR_lights_punctual();\n\n    return gltf;\n  }\n  /* eslint-enable complexity */\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.gltf[array] && this.gltf[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    scene.id = `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));\n  }\n\n  _resolveNode(node, index) {\n    node.id = `node-${index}`;\n    node.children = (node.children || []).map(child => this.getNode(child));\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n  }\n\n  _resolveSkin(skin, index) {\n    skin.id = `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n  }\n\n  _resolveMesh(mesh, index) {\n    mesh.id = `mesh-${index}`;\n    for (const primitive of mesh.primitives) {\n      for (const attribute in primitive.attributes) {\n        primitive.attributes[attribute] = this.getAccessor(primitive.attributes[attribute]);\n      }\n      if (primitive.indices !== undefined) {\n        primitive.indices = this.getAccessor(primitive.indices);\n      }\n      if (primitive.material !== undefined) {\n        primitive.material = this.getMaterial(primitive.material);\n      }\n    }\n  }\n\n  _resolveMaterial(material, index) {\n    material.id = `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n\n    if (material.pbrMetallicRoughness) {\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n  }\n\n  _resolveAccessor(accessor, index) {\n    accessor.id = `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor);\n    accessor.components = getSizeFromAccessorType(accessor);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n  }\n\n  _resolveTexture(texture, index) {\n    texture.id = `texture-${index}`;\n    texture.sampler = this.getSampler(texture.sampler);\n    texture.source = this.getImage(texture.source);\n  }\n\n  _resolveSampler(sampler, index) {\n    sampler.id = `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index, options) {\n    image.id = `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // TODO - Handle non-binary-chunk images, data URIs, URLs etc\n    // TODO - Image creation could be done on getImage instead of during load\n    const {createImages = true} = options;\n    if (createImages) {\n      image.image = this.glbParser.getImage(image);\n    } else {\n      image.getImageAsync = () => {\n        if (this.glbParser) {\n          return this.glbParser.getImageAsync(image);\n        } else if (image.uri) {\n          // TODO: Maybe just return the URL?\n          // TODO: Maybe use loaders.gl/core loadImage?\n          return new Promise(resolve => {\n            /* global Image */\n            const img = new Image();\n            img.crossOrigin = 'anonymous';\n            img.onload = () => resolve(img);\n            img.src = getFullUri(image.uri, options.uri);\n          });\n        }\n\n        // cannot get image\n        return null;\n      };\n    }\n  }\n\n  _resolveBufferView(bufferView, index) {\n    bufferView.id = `bufferView-${index}`;\n    bufferView.buffer = this.getBuffer(bufferView.buffer);\n\n    if (this.glbParser) {\n      bufferView.data = this.glbParser.getBufferView(bufferView);\n    } else {\n      const byteOffset = bufferView.byteOffset || 0;\n      bufferView.data = new Uint8Array(bufferView.buffer.data, byteOffset, bufferView.byteLength);\n    }\n  }\n\n  _resolveCamera(camera) {\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n  }\n\n  // EXTENSIONS\n\n  // eslint-disable-next-line camelcase\n  _process_extension_KHR_lights_punctual() {\n    const {gltf} = this;\n\n    // Move the light array out of the extension and remove the extension\n    const extension = gltf.extensions && gltf.extensions.KHR_lights_punctual;\n    if (extension) {\n      gltf.lights = extension.lights;\n    }\n\n    this._removeExtension('KHR_lights_punctual');\n\n    // Any nodes that have the extension, add lights field pointing to light object\n    // and remove the extension\n    for (const node of gltf.nodes || []) {\n      const nodeExtension = node.extensions && node.extensions.KHR_lights_punctual;\n      if (nodeExtension) {\n        node.light = this._get('lights', nodeExtension.light);\n        delete node.extensions.KHR_lights_punctual;\n      }\n    }\n\n    delete gltf.lights;\n  }\n\n  // Removes an extension from the top-level list\n  _removeExtension(extensionName) {\n    if (this.gltf.extensionsRequired) {\n      this._removeStringFromArray(this.gltf.extensionsRequired, extensionName);\n    }\n    if (this.gltf.extensionsUsed) {\n      this._removeStringFromArray(this.gltf.extensionsUsed, extensionName);\n    }\n    if (this.gltf.extensions) {\n      delete this.gltf.extensions[extensionName];\n    }\n  }\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n}\n","// TODO - remove\nimport {getAccessorTypeFromSize, getComponentTypeFromArray} from './gltf-type-utils';\n\n// Returns a fresh attributes object with glTF-standardized attributes names\n// Attributes that cannot be identified will not be included\n// Removes `indices` if present, as it should be stored separately from the attributes\nexport function getGLTFAccessors(attributes) {\n  const accessors = {};\n  for (const name in attributes) {\n    const attribute = attributes[name];\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n  return accessors;\n}\n\n// Fix up a single accessor.\n// Input: typed array or a partial accessor object\n// Return: accessor object\nexport function getGLTFAccessor(attribute, gltfAttributeName) {\n  const {buffer, size, count} = getAccessorData(attribute, gltfAttributeName);\n\n  const glTFAccessor = {\n    // TODO: Deprecate `value` in favor of bufferView?\n    value: buffer,\n    size, // Decoded `type` (e.g. SCALAR)\n\n    // glTF Accessor values\n    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)\n    bufferView: null,\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n\n  return glTFAccessor;\n}\n\nexport function getGLTFAttribute(data, gltfAttributeName) {\n  return data.attributes[data.glTFAttributeMap[gltfAttributeName]];\n}\n\nfunction getAccessorData(attribute, attributeName) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n    count = buffer.length / size;\n  }\n\n  return {buffer, size, count};\n}\n\n// Convert non-typed arrays to arrays of specified format\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n  if (!array) {\n    return null;\n  }\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n  return array;\n}\n","import {TextDecoder, fetchFile} from '@loaders.gl/core';\nimport GLBParser from '../deprecated/glb-parser';\nimport GLTFPostProcessor from './gltf-post-processor';\nimport {getFullUri} from './gltf-utils';\nimport {KHR_DRACO_MESH_COMPRESSION, UBER_POINT_CLOUD_EXTENSION} from './gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from './gltf-attribute-utils';\n\nconst DEFAULT_OPTIONS = {\n  fetchLinkedResources: true, // Fetch any linked .BIN buffers, decode base64\n  fetch: fetchFile,\n  decompress: false, // Decompress Draco compressed meshes (if DracoLoader available)\n  DracoLoader: null,\n  postProcess: true,\n  createImages: false, // Create image objects\n  log: console // eslint-disable-line\n};\n\nexport default class GLTFParser {\n  async parse(gltf, options = {}) {\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    // Postpone decompressing/postprocessing to make sure we load any linked files first\n    // TODO - is this really needed?\n    this.parseSync(gltf, {...options, postProcess: false, decompress: false});\n\n    // Load linked buffers asynchronously and decodes base64 buffers in parallel\n    if (options.fetchLinkedResources) {\n      await this._loadLinkedAssets(options);\n    }\n\n    if (options.decompress) {\n      this._decompressMeshes(options);\n    }\n\n    if (options.postProcess) {\n      const postProcessor = new GLTFPostProcessor();\n      postProcessor.postProcess(this.gltf, this.glbParser, options);\n    }\n\n    return this.gltf;\n  }\n\n  // NOTE: The sync parser cannot handle linked assets or base64 encoded resources\n  // gtlf - input can be arrayBuffer (GLB or UTF8 encoded JSON), string (JSON), or parsed JSON.\n  parseSync(gltf, options = {}) {\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    // If binary is not starting with magic bytes, convert to string\n    if (gltf instanceof ArrayBuffer && !GLBParser.isGLB(gltf, options)) {\n      const textDecoder = new TextDecoder();\n      gltf = textDecoder.decode(gltf);\n    }\n\n    // If string, try to parse as JSON\n    if (typeof gltf === 'string') {\n      gltf = JSON.parse(gltf);\n    }\n\n    if (gltf instanceof ArrayBuffer) {\n      // Extract JSON from the GLB container\n      this.glbParser = new GLBParser();\n      this.gltf = this.glbParser.parseSync(gltf).json;\n      this.json = this.gltf;\n    } else {\n      this.glbParser = null;\n      this.gltf = gltf;\n      this.json = gltf;\n    }\n\n    // TODO: we could handle base64 encoded files in the non-async path\n    // await this._loadBuffersSync(options);\n\n    // TODO: we could synchronously decode base64 encoded URIs in the non-async path\n    // await this._loadLinkedAssetsSync(options);\n\n    if (options.decompress) {\n      this._decompressMeshes(options);\n    }\n\n    if (options.postProcess) {\n      const postProcessor = new GLTFPostProcessor();\n      postProcessor.postProcess(this.gltf, this.glbParser, options);\n    }\n\n    return this.gltf;\n  }\n\n  // Accessors\n\n  getApplicationData(key) {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key) {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension(extensionName) {\n    const isExtension = this.getUsedExtensions().find(name => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension(extensionName) {\n    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  // PARSING HELPERS\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.gltf[array] && this.gltf[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  // Load linked assets\n  async _loadLinkedAssets(options) {\n    return await Promise.all(this.gltf.buffers.map(buffer => this._loadBuffer(buffer, options)));\n  }\n\n  async _loadBuffer(buffer, options) {\n    if (buffer.uri) {\n      const fetch = options.fetch || window.fetch;\n      const uri = getFullUri(buffer.uri, options.uri);\n      const response = await fetch(uri);\n      const arrayBuffer = await response.arrayBuffer();\n      buffer.data = arrayBuffer;\n      buffer.uri = null;\n    }\n  }\n\n  // POST PROCESSING\n\n  _decompressMeshes(options) {\n    // We have a \"soft dependency\" on Draco to avoid bundling it when not needed\n    // DracoEncoder needs to be imported and supplied by app\n    if (!options.DracoLoader || !options.decompress) {\n      return;\n    }\n\n    for (const mesh of this.gltf.meshes || []) {\n      // Decompress all the primitives in a mesh\n      for (const primitive of mesh.primitives) {\n        this._decompressKhronosDracoPrimitive(primitive, options);\n        this._decompressUberDracoPrimitive(primitive, options);\n        if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {\n          throw new Error('Empty glTF primitive: decompression failure?');\n        }\n      }\n    }\n\n    // We have now decompressed all primitives, we can remove the top-level extensions\n    this._removeExtension(KHR_DRACO_MESH_COMPRESSION);\n    this._removeExtension(UBER_POINT_CLOUD_EXTENSION);\n  }\n\n  // Unpacks one mesh primitive and removes the extension from the primitive\n  // TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n  // TODO - Decompression could be threaded: Use DracoWorkerLoader?\n  //\n  // eslint-disable-next-line max-len\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n  _decompressKhronosDracoPrimitive(primitive, options) {\n    const compressedMesh = primitive.extensions && primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n    if (!compressedMesh) {\n      return;\n    }\n\n    // Extension will be processed, delete it\n    delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n    const buffer = this._getBufferViewArray(compressedMesh.bufferView);\n    const decodedData = options.DracoLoader.parseSync(buffer);\n    primitive.attributes = getGLTFAccessors(decodedData.attributes);\n    if (decodedData.indices) {\n      primitive.indices = getGLTFAccessor(decodedData.indices);\n    }\n  }\n\n  // Unpacks one mesh primitive and removes the extension from the primitive\n  _decompressUberDracoPrimitive(primitive, options) {\n    const compressedMesh = primitive.extensions && primitive.extensions[UBER_POINT_CLOUD_EXTENSION];\n    if (!compressedMesh) {\n      return;\n    }\n\n    if (primitive.mode !== 0) {\n      throw new Error(UBER_POINT_CLOUD_EXTENSION);\n    }\n\n    // Extension will be processed, delete it\n    delete primitive.extensions[UBER_POINT_CLOUD_EXTENSION];\n\n    const buffer = this._getBufferViewArray(compressedMesh.bufferView);\n    const decodedData = options.DracoLoader.parseSync(buffer);\n    primitive.attributes = decodedData.attributes;\n  }\n\n  _getBufferViewArray(bufferViewIndex) {\n    const bufferView = this.gltf.bufferViews[bufferViewIndex];\n    if (this.glbParser) {\n      return this.glbParser.getBufferView(bufferView);\n    }\n\n    const buffer = this.gltf.buffers[bufferView.buffer].data;\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(buffer, byteOffset, bufferView.byteLength);\n  }\n\n  // Removes an extension from the top-level list\n  _removeExtension(extensionName) {\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n  }\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n}\n","// GLTF extension\n\n// Ideally we should just use KHR_draco_mesh_compression, but it does not support point clouds\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const UBER_POINT_CLOUD_EXTENSION = 'UBER_draco_point_cloud_compression';\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\n// ENUM LOOKUP\n\nexport function getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nexport function getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nexport function getGLEnumFromSamplerParameter(parameter) {\n  const GL_TEXTURE_MAG_FILTER = 0x2800;\n  const GL_TEXTURE_MIN_FILTER = 0x2801;\n  const GL_TEXTURE_WRAP_S = 0x2802;\n  const GL_TEXTURE_WRAP_T = 0x2803;\n\n  const PARAMETER_MAP = {\n    magFilter: GL_TEXTURE_MAG_FILTER,\n    minFilter: GL_TEXTURE_MIN_FILTER,\n    wrapS: GL_TEXTURE_WRAP_S,\n    wrapT: GL_TEXTURE_WRAP_T\n  };\n\n  return PARAMETER_MAP[parameter];\n}\n","// Binary container format for glTF\n\nimport GLTFParser from './gltf/gltf-parser';\n\nexport function parseGLTF(arrayBuffer, options = {}) {\n  return new GLTFParser().parse(arrayBuffer, options);\n}\n\nexport function parseGLTFSync(arrayBuffer, options = {}) {\n  return new GLTFParser().parseSync(arrayBuffer, options);\n}\n\nexport default {\n  name: 'glTF',\n  extension: ['gltf', 'glb'],\n  text: true,\n  binary: true,\n  parse: parseGLTF,\n  parseSync: parseGLTFSync // Less features\n};\n"],"sourceRoot":""}